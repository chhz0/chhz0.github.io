<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Golang/Context | &lt;chang/></title>
<link rel=icon href=/images/favicon.png type=image/png><meta property="og:url" content="https://chhz0.github.io/posts/golang/context/"><meta property="og:title" content="Golang/Context"><meta property="og:description" content="Context 是Go语言于v1.7引入，用于在goroutine中传递截止时间、取消信号和其他请求范围值的标准库，也是Go语言的一个特殊机制.
为什么需要 Context ？ 在经典的网络服务器中，每个传入的请求都在一个单独的goroutine中处理，这里处理过程可能涉及到多个下游调用，例如访问数据库、调用 RPC 服务等，这时会面临几个问题：
请求取消：如果客户端连接关闭或者请求超时，那么需要关闭所有相关的 goroutine ，避免资源浪费. 超时控制：某些操作需要明确的执行时间，超过该时间该停止，并返回超时错误. 数据传递：在整个请求链中，共享一些数据（例如：user_id, trace_id…），需要一种安全的方式将共享的数据传递到各个函数，同时不污染函数签名. context.Context 正是为了优雅解决这些问题，提供了一个在 API 边界之间和 goroutine 之间传递“元数据”的标准方式.
Context 的核心原理 Context 接口 context 包的核心是 Context 接口，它定义了四个方法：
type Context interface { // Deadline 返回一个时间点，当到达该时间点后，Context 将被自动取消。 // 如果没有设置 Deadline，ok 将返回 false。 Deadline() (deadline time.Time, ok bool) // Done 返回一个 channel。当 Context 被取消或超时时，该 channel 会被关闭。 // 如果 Context 不可取消，Done() 可能返回 nil。 Done() <-chan struct{} // Err 在 Done() channel 关闭后，返回 Context 被取消的原因。 // 如果 Context 未被取消，返回 nil。 // 常见原因为 context.Canceled 和 context.DeadlineExceeded。 Err() error // Value 返回与该 Context 关联的键（key）对应的值（value）。 // 主要用于在请求处理链中传递请求范围的数据。 Value(key any) any } Context 树状结构和传播机制 Go 中的 Context 具有继承关系，可以形成一棵树状结构。当你基于一个父 Context 创建一个子 Context 时，它们之间就建立了关联."><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-09-15T15:29:25+08:00"><meta property="article:modified_time" content="2025-09-15T15:29:25+08:00"><meta property="article:tag" content="Golang"><meta property="article:tag" content="Context"><meta name=twitter:card content="summary"><meta name=twitter:title content="Golang/Context"><meta name=twitter:description content="Context 是Go语言于v1.7引入，用于在goroutine中传递截止时间、取消信号和其他请求范围值的标准库，也是Go语言的一个特殊机制.
为什么需要 Context ？ 在经典的网络服务器中，每个传入的请求都在一个单独的goroutine中处理，这里处理过程可能涉及到多个下游调用，例如访问数据库、调用 RPC 服务等，这时会面临几个问题：
请求取消：如果客户端连接关闭或者请求超时，那么需要关闭所有相关的 goroutine ，避免资源浪费. 超时控制：某些操作需要明确的执行时间，超过该时间该停止，并返回超时错误. 数据传递：在整个请求链中，共享一些数据（例如：user_id, trace_id…），需要一种安全的方式将共享的数据传递到各个函数，同时不污染函数签名. context.Context 正是为了优雅解决这些问题，提供了一个在 API 边界之间和 goroutine 之间传递“元数据”的标准方式.
Context 的核心原理 Context 接口 context 包的核心是 Context 接口，它定义了四个方法：
type Context interface { // Deadline 返回一个时间点，当到达该时间点后，Context 将被自动取消。 // 如果没有设置 Deadline，ok 将返回 false。 Deadline() (deadline time.Time, ok bool) // Done 返回一个 channel。当 Context 被取消或超时时，该 channel 会被关闭。 // 如果 Context 不可取消，Done() 可能返回 nil。 Done() <-chan struct{} // Err 在 Done() channel 关闭后，返回 Context 被取消的原因。 // 如果 Context 未被取消，返回 nil。 // 常见原因为 context.Canceled 和 context.DeadlineExceeded。 Err() error // Value 返回与该 Context 关联的键（key）对应的值（value）。 // 主要用于在请求处理链中传递请求范围的数据。 Value(key any) any } Context 树状结构和传播机制 Go 中的 Context 具有继承关系，可以形成一棵树状结构。当你基于一个父 Context 创建一个子 Context 时，它们之间就建立了关联."><link rel=stylesheet href=/css/components.min.afc5fef3746a097cac11deee0eb4ce444828bfd4c8079369c0b55b957701e0fd.css integrity="sha256-r8X+83RqCXysEd7uDrTOREgov9TIB5NpwLVblXcB4P0=" crossorigin=anonymous><link rel=stylesheet href=/css/fonts.min.33e6dd0941fa2112644bb3cd2b809b0fb9e7e7f798c98cef013e8318e027297b.css integrity="sha256-M+bdCUH6IRJkS7PNK4CbD7nn5/eYyYzvAT6DGOAnKXs=" crossorigin=anonymous><link rel=stylesheet href=/css/main.min.e2f9a4785479b6e817f37c2382ee27a03cc985c3e9149c638029565e06267476.css integrity="sha256-4vmkeFR5tugX83wjgu4noDzJhcPpFJxjgClWXgYmdHY=" crossorigin=anonymous><link rel=stylesheet href=/css/root.min.d34829801c321eaef316317967d4e2cad714d194d0647c7d18340f64b28d77ef.css integrity="sha256-00gpgBwyHq7zFjF5Z9TiytcU0ZTQZHx9GDQPZLKNd+8=" crossorigin=anonymous><link rel=stylesheet href=/css/sane.min.b7b1b531675079d1427ed3c1a9693679dece6cb4186f0e6f0734eea145bf06d6.css integrity="sha256-t7G1MWdQedFCftPBqWk2ed7ObLQYbw5vBzTuoUW/BtY=" crossorigin=anonymous><link rel=stylesheet href=/css/search.min.5704733e1e76fd38026ea4d65a1a6e8120ac5a8187a1627d8fc4b5f9fc8c4f06.css integrity="sha256-VwRzPh52/TgCbqTWWhpugSCsWoGHoWJ9j8S1+fyMTwY=" crossorigin=anonymous><link rel=stylesheet href=/css/bundle.min.59eb1a059f8cd558e64375ede3e68d3e9120ddb0c6bdbab555c247689cef59e1.css integrity="sha256-WesaBZ+M1VjmQ3Xt4+aNPpEg3bDGvbq1VcJHaJzvWeE=" crossorigin=anonymous><script src=/js/search_popup.4471e0425634435b641a97f0fe6f5f5960394b5262f4eb2cf77c098b2d5121e4.js integrity="sha256-RHHgQlY0Q1tkGpfw/m9fWWA5S1Ji9Oss93wJiy1RIeQ=" crossorigin=anonymous></script><script src=/js/bundle.995e4ec99401021e081ec256bee66154ef7f4e5136809432513b2e6d014b4b1d.js integrity="sha256-mV5OyZQBAh4IHsJWvuZhVO9/TlE2gJQyUTsubQFLSx0=" crossorigin=anonymous></script><script defer src=/js/search/flexsearch.compact.64594b125f7b78bdf4fa8316955922bbebb1cd6baef3f16654bfca20309f18f8.js integrity="sha256-ZFlLEl97eL30+oMWlVkiu+uxzWuu8/FmVL/KIDCfGPg="></script><script defer src=/js/search/search.1d980f84df11f3eb7c8c5f17f541d49a0611608df179dd74fa7f06225eb56ace.js integrity="sha256-HZgPhN8R8+t8jF8X9UHUmgYRYI3xed10+n8GIl61as4="></script><script defer src=/js/search/search_popup.fe0c2f77683b4fb13e25223fadbc0a8e65058c2a235370879053c1552f7746ab.js integrity="sha256-/gwvd2g7T7E+JSI/rbwKjmUFjCojU3CHkFPBVS93Rqs="></script></head><body class=notransition><div id=container style="padding:.625rem 1rem 1rem"><header id=main-header><div role=navigation aria-label=Main><div class=nav-left><a href=https://chhz0.github.io/ style=color:inherit>&lt;chang/></a></div><div class=nav-right><div style=position:absolute;width:0;height:0><div id=nav-dropdown-menu class=hidden href=#><div class=nav-item><a style=color:inherit aria-current=true class=ancestor href=/posts/>文章</a></div><div class=nav-item><a style=color:inherit href=/about/>关于</a></div></div></div><a id=nav-dropdown-button href=#><svg width="20" height="20" viewBox="0 0 24 24" fill="none"><path d="M4 6H20M4 12H20M4 18H20" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></a><div id=nav-menu><div class=nav-item><a style=color:inherit aria-current=true class=ancestor href=/posts/>文章</a></div><div class=nav-item><a style=color:inherit href=/about/>关于</a></div></div><a id=theme-switcher href=#><svg class="light-icon" viewBox="0 0 24 24" fill="none"><path d="M12 3V4m0 16v1M4 12H3M6.31412 6.31412 5.5 5.5m12.1859.81412L18.5 5.5M6.31412 17.69 5.5 18.5001M17.6859 17.69 18.5 18.5001M21 12H20m-4 0c0 2.2091-1.7909 4-4 4-2.20914.0-4-1.7909-4-4 0-2.20914 1.79086-4 4-4 2.2091.0 4 1.79086 4 4z" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
<svg class="dark-icon" viewBox="0 0 24 24" fill="none"><path d="M3.32031 11.6835c0 4.9706 4.02944 9 8.99999 9 3.7872.0 7.028-2.3392 8.3565-5.6515C19.6402 15.4486 18.5059 15.6834 17.3203 15.6834c-4.9706.0-8.99999-4.0294-8.99999-8.99998C8.32031 5.50338 8.55165 4.36259 8.96453 3.32996 5.65605 4.66028 3.32031 7.89912 3.32031 11.6835z" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
</a>|
<a id=theme-switcher href=https://github.com/chhz0 aria-label=GitHub><svg class="light-icon" width="800" height="800" viewBox="0 0 20 20" xmlns:xlink="http://www.w3.org/1999/xlink"><title>github [#142]</title><desc>Created with Sketch.</desc><defs/><g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="Dribbble-Light-Preview" transform="translate(-140.000000, -7559.000000)" fill="#fff"><g id="icons" transform="translate(56.000000, 160.000000)"><path d="M94 7399C99.523 7399 104 7403.59 104 7409.253 104 7413.782 101.138 7417.624 97.167 7418.981 96.66 7419.082 96.48 7418.762 96.48 7418.489 96.48 7418.151 96.492 7417.047 96.492 7415.675 96.492 7414.719 96.172 7414.095 95.813 7413.777 98.04 7413.523 100.38 7412.656 100.38 7408.718 100.38 7407.598 99.992 7406.684 99.35 7405.966 99.454 7405.707 99.797 7404.664 99.252 7403.252 99.252 7403.252 98.414 7402.977 96.505 7404.303 95.706 7404.076 94.85 7403.962 94 7403.958 93.15 7403.962 92.295 7404.076 91.497 7404.303 89.586 7402.977 88.746 7403.252 88.746 7403.252 88.203 7404.664 88.546 7405.707 88.649 7405.966 88.01 7406.684 87.619 7407.598 87.619 7408.718 87.619 7412.646 89.954 7413.526 92.175 7413.785 91.889 7414.041 91.63 7414.493 91.54 7415.156 90.97 7415.418 89.522 7415.871 88.63 7414.304 88.63 7414.304 88.101 7413.319 87.097 7413.247 87.097 7413.247 86.122 7413.234 87.029 7413.87 87.029 7413.87 87.684 7414.185 88.139 7415.37 88.139 7415.37 88.726 7417.2 91.508 7416.58 91.513 7417.437 91.522 7418.245 91.522 7418.489 91.522 7418.76 91.338 7419.077 90.839 7418.982 86.865 7417.627 84 7413.783 84 7409.253 84 7403.59 88.478 7399 94 7399" id="github-[#142]"/></g></g></g></svg><svg class="dark-icon" width="800" height="800" viewBox="0 0 20 20" xmlns:xlink="http://www.w3.org/1999/xlink"><title>github [#142]</title><desc>Created with Sketch.</desc><defs/><g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="Dribbble-Light-Preview" transform="translate(-140.000000, -7559.000000)" fill="#000"><g id="icons" transform="translate(56.000000, 160.000000)"><path d="M94 7399C99.523 7399 104 7403.59 104 7409.253 104 7413.782 101.138 7417.624 97.167 7418.981 96.66 7419.082 96.48 7418.762 96.48 7418.489 96.48 7418.151 96.492 7417.047 96.492 7415.675 96.492 7414.719 96.172 7414.095 95.813 7413.777 98.04 7413.523 100.38 7412.656 100.38 7408.718 100.38 7407.598 99.992 7406.684 99.35 7405.966 99.454 7405.707 99.797 7404.664 99.252 7403.252 99.252 7403.252 98.414 7402.977 96.505 7404.303 95.706 7404.076 94.85 7403.962 94 7403.958 93.15 7403.962 92.295 7404.076 91.497 7404.303 89.586 7402.977 88.746 7403.252 88.746 7403.252 88.203 7404.664 88.546 7405.707 88.649 7405.966 88.01 7406.684 87.619 7407.598 87.619 7408.718 87.619 7412.646 89.954 7413.526 92.175 7413.785 91.889 7414.041 91.63 7414.493 91.54 7415.156 90.97 7415.418 89.522 7415.871 88.63 7414.304 88.63 7414.304 88.101 7413.319 87.097 7413.247 87.097 7413.247 86.122 7413.234 87.029 7413.87 87.029 7413.87 87.684 7414.185 88.139 7415.37 88.139 7415.37 88.726 7417.2 91.508 7416.58 91.513 7417.437 91.522 7418.245 91.522 7418.489 91.522 7418.76 91.338 7419.077 90.839 7418.982 86.865 7417.627 84 7413.783 84 7409.253 84 7403.59 88.478 7399 94 7399" id="github-[#142]"/></g></g></g></svg></a></div><p class=hidden></p><p class="search-loading hidden">加载中...</p><div id=searchPopupOverlay class=search-popup-overlay><div class=search-popup><div class=search-popup-header><form id=search-popup-form class=search-popup-form action=# method=post accept-charset=UTF-8 role=search onsubmit=searchPopupSubmit(event)><div class=search-popup-bar><div style=margin-top:6px;margin-left:.5rem><svg style="min-width:16px" width="16" height="16" viewBox="0 0 24 24" fill="none"><path d="M15.7955 15.8111 21 21M18 10.5c0 4.1421-3.3579 7.5-7.5 7.5C6.35786 18 3 14.6421 3 10.5 3 6.35786 6.35786 3 10.5 3 14.6421 3 18 6.35786 18 10.5z" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></div><input id=popupQuery class=search-popup-query type=text placeholder autocomplete=off></div></form></div><div class=search-popup-content><div class=search-popup-results></div></div><div class=search-popup-footer>esc to dismiss | click to select</div></div></div><template><article class=search-popup-result><header><h2 class=title><a href=#></a></h2><div class=submitted style=margin-left:auto;font-size:14px;color:var(--secondary-text-color)><time class=created-date></time></div></header><p class=content></p></article></template><script>function searchPopupSubmit(e){e.preventDefault();const t=`https://chhz0.github.io/search/?q=${encodeURIComponent(e.target.elements.popupQuery.value)}`;window.location.href=t}</script></div></header><div class="flex grow"><div class=grid-background></div><div id=main-pane><main id=main-content><div class=single-header><ol class=breadcrumbs itemscope itemtype=https://schema.org/BreadcrumbList><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://chhz0.github.io/><span itemprop=name>Home</span>
</a><meta itemprop=position content='1'></li><span>&nbsp»&nbsp</span><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://chhz0.github.io/posts/><span itemprop=name>posts</span>
</a><meta itemprop=position content='2'></li><span>&nbsp»&nbsp</span><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://chhz0.github.io/posts/golang/><span itemprop=name>Golang</span>
</a><meta itemprop=position content='3'></li><span>&nbsp»&nbsp</span></ol><h1>Golang/Context</h1><time class=dim datetime=2025-09-15T15:29:25+08:00>September 15, 2025</time><div class=term-container><div class=tag><a href=https://chhz0.github.io/tags/golang/>#golang</a></div><div class=tag><a href=https://chhz0.github.io/tags/context/>#context</a></div></ol></div><section class=page-section><blockquote><p><code>Context</code> 是<strong>Go</strong>语言于<strong>v1.7</strong>引入，用于在<code>goroutine</code>中传递截止时间、取消信号和其他请求范围值的标准库，也是Go语言的一个特殊机制.</p></blockquote><h2 id=为什么需要-context->为什么需要 Context ？</h2><p>在经典的网络服务器中，每个传入的请求都在一个单独的<code>goroutine</code>中处理，这里处理过程可能涉及到多个下游调用，例如访问数据库、调用 RPC 服务等，这时会面临几个问题：</p><ol><li><strong>请求取消</strong>：如果客户端连接关闭或者请求超时，那么需要关闭所有相关的 <code>goroutine</code> ，避免资源浪费.</li><li><strong>超时控制</strong>：某些操作需要明确的执行时间，超过该时间该停止，并返回超时错误.</li><li><strong>数据传递</strong>：在整个请求链中，共享一些数据（例如：user_id, trace_id&mldr;），需要一种安全的方式将共享的数据传递到各个函数，同时不污染函数签名.</li></ol><p><code>context.Context</code> 正是为了优雅解决这些问题，提供了一个在 API 边界之间和 <code>goroutine</code> 之间传递“元数据”的标准方式.</p><h2 id=context-的核心原理>Context 的核心原理</h2><h3 id=context-接口>Context 接口</h3><p><code>context</code> 包的核心是 <code>Context</code> 接口，它定义了四个方法：</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#c678dd>type</span> <span style=color:#e06c75>Context</span> <span style=color:#c678dd>interface</span> {
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// Deadline 返回一个时间点，当到达该时间点后，Context 将被自动取消。</span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// 如果没有设置 Deadline，ok 将返回 false。</span>
</span></span><span style=display:flex><span>    <span style=color:#61afef;font-weight:700>Deadline</span>() (<span style=color:#e06c75>deadline</span> <span style=color:#e06c75>time</span>.<span style=color:#e06c75>Time</span>, <span style=color:#e06c75>ok</span> <span style=color:#e5c07b>bool</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// Done 返回一个 channel。当 Context 被取消或超时时，该 channel 会被关闭。</span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// 如果 Context 不可取消，Done() 可能返回 nil。</span>
</span></span><span style=display:flex><span>    <span style=color:#61afef;font-weight:700>Done</span>() <span style=color:#56b6c2>&lt;-</span><span style=color:#c678dd>chan</span> <span style=color:#c678dd>struct</span>{}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// Err 在 Done() channel 关闭后，返回 Context 被取消的原因。</span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// 如果 Context 未被取消，返回 nil。</span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// 常见原因为 context.Canceled 和 context.DeadlineExceeded。</span>
</span></span><span style=display:flex><span>    <span style=color:#61afef;font-weight:700>Err</span>() <span style=color:#e5c07b>error</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// Value 返回与该 Context 关联的键（key）对应的值（value）。</span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// 主要用于在请求处理链中传递请求范围的数据。</span>
</span></span><span style=display:flex><span>    <span style=color:#61afef;font-weight:700>Value</span>(<span style=color:#e06c75>key</span> <span style=color:#e5c07b>any</span>) <span style=color:#e5c07b>any</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=context-树状结构和传播机制>Context 树状结构和传播机制</h3><p>Go 中的 <code>Context</code> 具有<strong>继承关系</strong>，可以形成一棵树状结构。当你基于一个父 <code>Context</code> 创建一个子 <code>Context</code> 时，它们之间就建立了关联.</p><p>这种结构的核心特性是<strong>取消信号的单向传播</strong>：</p><blockquote><p><strong>当一个父 <code>Context</code> 被取消时，所有由它派生出的子 <code>Context</code> 也会被立即取消</strong></p></blockquote><p>这个机制是 <code>context</code> 实现优雅取消和超时控制的关键。例如，一个代表 HTTP 请求的 <code>Context</code> 如果因为客户端断开连接而被取消，那么由它派生出的、用于数据库查询和 RPC 调用的子 <code>Context</code> 也会随之取消，从而中断这些下游操作.</p><h2 id=context-的使用>Context 的使用</h2><p><code>context</code> 包提供了几种创建和派生 <code>Context</code> 的方法.</p><h3 id=顶层空-context>顶层(空) Context</h3><p><code>context</code> 包提供了两个顶层的、空的 <code>Context</code>，它们是所有 <code>Context</code> 树的根节点：</p><ul><li><code>context.Background()</code>: 通常用于主函数、初始化和测试代码中，作为最顶层的 <code>Context</code>。它永远不会被取消。</li><li><code>context.TODO()</code>: 当你不清楚应该使用哪个 <code>Context</code>，或者当前函数未来可能会更新以接收 <code>Context</code> 时，可以使用它。它本质上和 <code>Background()</code> 一样。</li></ul><h3 id=可取消-context>可取消 Context</h3><p>有三种主要方式可以创建可被取消的子 <code>Context</code>：</p><ol><li><p><strong><code>context.WithCancel(parent Context) (ctx Context, cancel CancelFunc)</code></strong></p><p><code>WithCancel</code> 返回一个派生的 <code>ctx</code> 和一个 <code>cancel</code> 函数。当 <code>cancel</code> 函数被调用时，<code>ctx</code> 及其所有子 <code>Context</code> 都会被取消</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#7f848e>// 假设我们启动一个长时间运行的后台任务，并希望能在需要时手动停止它。</span>
</span></span><span style=display:flex><span><span style=color:#c678dd>package</span> <span style=color:#e06c75>main</span>
</span></span><span style=display:flex><span><span style=color:#c678dd>import</span> (
</span></span><span style=display:flex><span>    <span style=color:#98c379>&#34;context&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#98c379>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#98c379>&#34;time&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>worker</span>(<span style=color:#e06c75>ctx</span> <span style=color:#e06c75>context</span>.<span style=color:#e06c75>Context</span>, <span style=color:#e06c75>name</span> <span style=color:#e5c07b>string</span>) {
</span></span><span style=display:flex><span>	<span style=color:#c678dd>for</span> {
</span></span><span style=display:flex><span>		<span style=color:#c678dd>select</span> {
</span></span><span style=display:flex><span>		<span style=color:#c678dd>case</span> <span style=color:#56b6c2>&lt;-</span><span style=color:#e06c75>ctx</span>.<span style=color:#61afef;font-weight:700>Done</span>(): <span style=color:#7f848e>// 监听取消信号</span>
</span></span><span style=display:flex><span>			<span style=color:#e06c75>fmt</span>.<span style=color:#61afef;font-weight:700>Printf</span>(<span style=color:#98c379>&#34;%s: worker cancelled\n&#34;</span>, <span style=color:#e06c75>name</span>)
</span></span><span style=display:flex><span>			<span style=color:#c678dd>return</span>
</span></span><span style=display:flex><span>		<span style=color:#c678dd>default</span>:
</span></span><span style=display:flex><span>			<span style=color:#e06c75>fmt</span>.<span style=color:#61afef;font-weight:700>Printf</span>(<span style=color:#98c379>&#34;%s: working...\n&#34;</span>, <span style=color:#e06c75>name</span>)
</span></span><span style=display:flex><span>			<span style=color:#e06c75>time</span>.<span style=color:#61afef;font-weight:700>Sleep</span>(<span style=color:#d19a66>1</span> <span style=color:#56b6c2>*</span> <span style=color:#e06c75>time</span>.<span style=color:#e06c75>Second</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#7f848e>// 创建一个可取消的 context</span>
</span></span><span style=display:flex><span>	<span style=color:#e06c75>ctx</span>, <span style=color:#e06c75>cancel</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>context</span>.<span style=color:#61afef;font-weight:700>WithCancel</span>(<span style=color:#e06c75>context</span>.<span style=color:#61afef;font-weight:700>Background</span>())
</span></span><span style=display:flex><span>	<span style=color:#c678dd>go</span> <span style=color:#61afef;font-weight:700>worker</span>(<span style=color:#e06c75>ctx</span>, <span style=color:#98c379>&#34;Worker 1&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#c678dd>go</span> <span style=color:#61afef;font-weight:700>worker</span>(<span style=color:#e06c75>ctx</span>, <span style=color:#98c379>&#34;Worker 2&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#7f848e>// 运行 3 秒后发出取消信号</span>
</span></span><span style=display:flex><span>	<span style=color:#e06c75>time</span>.<span style=color:#61afef;font-weight:700>Sleep</span>(<span style=color:#d19a66>3</span> <span style=color:#56b6c2>*</span> <span style=color:#e06c75>time</span>.<span style=color:#e06c75>Second</span>)
</span></span><span style=display:flex><span>	<span style=color:#e06c75>fmt</span>.<span style=color:#61afef;font-weight:700>Println</span>(<span style=color:#98c379>&#34;Main: sending cancellation signal&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#61afef;font-weight:700>cancel</span>() <span style=color:#7f848e>// 调用 cancel 函数</span>
</span></span><span style=display:flex><span>	<span style=color:#7f848e>// 等待一小段时间，确保 worker 有时间退出</span>
</span></span><span style=display:flex><span>	<span style=color:#e06c75>time</span>.<span style=color:#61afef;font-weight:700>Sleep</span>(<span style=color:#d19a66>1</span> <span style=color:#56b6c2>*</span> <span style=color:#e06c75>time</span>.<span style=color:#e06c75>Second</span>)
</span></span><span style=display:flex><span>	<span style=color:#e06c75>fmt</span>.<span style=color:#61afef;font-weight:700>Println</span>(<span style=color:#98c379>&#34;Main: finished&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在这个例子中，<code>worker</code> <code>goroutine</code> 通过 <code>select</code> 语句监听 <code>ctx.Done()</code>。一旦 <code>main</code> 函数调用 <code>cancel()</code>，<code>ctx.Done()</code> 的 channel 会被关闭，<code>worker</code> 就能收到信号并优雅退出。</p></li><li><p><code>context.WithDeadline(parent Context, d time.Time) (Context, CancelFunc)</code></p><p><code>WithDeadline</code> 设置了一个具体的截止时间点。当系统时间到达或超过这个时间点时，<code>Context</code> 会被自动取消。</p></li><li><p><code>context.WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)</code></p><p><code>WithTimeout</code> 是 <code>WithDeadline</code> 的一个常用封装。它设置一个从当前时间开始的超时时长。当超时后，<code>Context</code> 会被自动取消。</p><blockquote><p><strong>tips</strong>：无论是 <code>WithCancel</code>、<code>WithDeadline</code> 还是 <code>WithTimeout</code>，都应该总是使用 <code>defer cancel()</code> 来确保在函数返回时释放与 <code>Context</code> 相关的资源，即使操作成功完成</p></blockquote><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#7f848e>// 在处理外部 API 请求时，设置超时是非常重要的，可以防止服务因下游依赖的缓慢而卡死。</span>
</span></span><span style=display:flex><span><span style=color:#c678dd>package</span> <span style=color:#e06c75>main</span>
</span></span><span style=display:flex><span><span style=color:#c678dd>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#98c379>&#34;context&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#98c379>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#98c379>&#34;time&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span><span style=color:#7f848e>// 模拟一个耗时的 API 调用</span>
</span></span><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>thirdPartyAPICall</span>(<span style=color:#e06c75>ctx</span> <span style=color:#e06c75>context</span>.<span style=color:#e06c75>Context</span>) (<span style=color:#e5c07b>string</span>, <span style=color:#e5c07b>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#c678dd>select</span> {
</span></span><span style=display:flex><span>	<span style=color:#c678dd>case</span> <span style=color:#56b6c2>&lt;-</span><span style=color:#e06c75>time</span>.<span style=color:#61afef;font-weight:700>After</span>(<span style=color:#d19a66>5</span> <span style=color:#56b6c2>*</span> <span style=color:#e06c75>time</span>.<span style=color:#e06c75>Second</span>): <span style=color:#7f848e>// 模拟 API 调用需要 5 秒</span>
</span></span><span style=display:flex><span>		<span style=color:#c678dd>return</span> <span style=color:#98c379>&#34;API response&#34;</span>, <span style=color:#e5c07b>nil</span>
</span></span><span style=display:flex><span>	<span style=color:#c678dd>case</span> <span style=color:#56b6c2>&lt;-</span><span style=color:#e06c75>ctx</span>.<span style=color:#61afef;font-weight:700>Done</span>(): <span style=color:#7f848e>// 监听超时或取消</span>
</span></span><span style=display:flex><span>		<span style=color:#c678dd>return</span> <span style=color:#98c379>&#34;&#34;</span>, <span style=color:#e06c75>ctx</span>.<span style=color:#61afef;font-weight:700>Err</span>() <span style=color:#7f848e>// 返回 context 的错误信息</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#7f848e>// 创建一个 3 秒超时的 context</span>
</span></span><span style=display:flex><span>	<span style=color:#e06c75>ctx</span>, <span style=color:#e06c75>cancel</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>context</span>.<span style=color:#61afef;font-weight:700>WithTimeout</span>(<span style=color:#e06c75>context</span>.<span style=color:#61afef;font-weight:700>Background</span>(), <span style=color:#d19a66>3</span><span style=color:#56b6c2>*</span><span style=color:#e06c75>time</span>.<span style=color:#e06c75>Second</span>)
</span></span><span style=display:flex><span>	<span style=color:#c678dd>defer</span> <span style=color:#61afef;font-weight:700>cancel</span>() <span style=color:#7f848e>// 确保 cancel 被调用</span>
</span></span><span style=display:flex><span>	<span style=color:#e06c75>fmt</span>.<span style=color:#61afef;font-weight:700>Println</span>(<span style=color:#98c379>&#34;Making API call...&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#e06c75>result</span>, <span style=color:#e06c75>err</span> <span style=color:#56b6c2>:=</span> <span style=color:#61afef;font-weight:700>thirdPartyAPICall</span>(<span style=color:#e06c75>ctx</span>)
</span></span><span style=display:flex><span>	<span style=color:#c678dd>if</span> <span style=color:#e06c75>err</span> <span style=color:#56b6c2>!=</span> <span style=color:#e5c07b>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#e06c75>fmt</span>.<span style=color:#61afef;font-weight:700>Printf</span>(<span style=color:#98c379>&#34;API call failed: %v\n&#34;</span>, <span style=color:#e06c75>err</span>) <span style=color:#7f848e>// 输出: API call failed: context deadline exceeded</span>
</span></span><span style=display:flex><span>	} <span style=color:#c678dd>else</span> {
</span></span><span style=display:flex><span>		<span style=color:#e06c75>fmt</span>.<span style=color:#61afef;font-weight:700>Printf</span>(<span style=color:#98c379>&#34;API call successful: %s\n&#34;</span>, <span style=color:#e06c75>result</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在这个例子中，<code>thirdPartyAPICall</code> 需要 5 秒才能完成，但我们的 <code>Context</code> 设置了 3 秒的超时。因此，在 3 秒后，<code>ctx.Done()</code> 会被关闭，函数将返回 <code>context.DeadlineExceeded</code> 错误</p></li></ol><h3 id=传递值-context>传递值 Context</h3><ul><li><p><strong><code>context.WithValue(parent Context, key, val any) Context</code></strong></p><p><code>WithValue</code> 可以将一个键值对附加到 <code>Context</code> 上，并返回一个新的 <code>Context</code>。获取值时，使用 <code>ctx.Value(key)</code>。
<strong>最佳实践</strong>：</p><ol><li><strong>不要使用内置类型作为键</strong>：为了避免键冲突，应该使用自定义的、不可导出的类型作为 <code>Context</code> 的键。</li><li><strong>只传递请求范围的数据</strong>：<code>Context</code> 的 <code>Value</code> 只应该用于传递贯穿整个请求处理链路的数据，例如用户认证信息、追踪 ID 等。<strong>不应该</strong>用它来传递可选参数。</li></ol><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#7f848e>// 传递追踪 ID (Trace ID) 在微服务架构中，为了方便日志追踪和故障排查，</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// 通常会为每个请求生成一个唯一的追踪 ID，并将其在所有服务调用中传递</span>
</span></span><span style=display:flex><span><span style=color:#c678dd>package</span> <span style=color:#e06c75>main</span>
</span></span><span style=display:flex><span><span style=color:#c678dd>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#98c379>&#34;context&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#98c379>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span><span style=color:#7f848e>// 定义一个不可导出的自定义类型作为 key</span>
</span></span><span style=display:flex><span><span style=color:#c678dd>type</span> <span style=color:#e06c75>traceIDKey</span> <span style=color:#e5c07b>string</span>
</span></span><span style=display:flex><span><span style=color:#c678dd>const</span> <span style=color:#e06c75>key</span> <span style=color:#e06c75>traceIDKey</span> = <span style=color:#98c379>&#34;traceID&#34;</span>
</span></span><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>processRequest</span>(<span style=color:#e06c75>ctx</span> <span style=color:#e06c75>context</span>.<span style=color:#e06c75>Context</span>) {
</span></span><span style=display:flex><span>	<span style=color:#7f848e>// 从 context 中获取 traceID</span>
</span></span><span style=display:flex><span>	<span style=color:#e06c75>traceID</span>, <span style=color:#e06c75>ok</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>ctx</span>.<span style=color:#61afef;font-weight:700>Value</span>(<span style=color:#e06c75>key</span>).(<span style=color:#e5c07b>string</span>)
</span></span><span style=display:flex><span>	<span style=color:#c678dd>if</span> !<span style=color:#e06c75>ok</span> {
</span></span><span style=display:flex><span>		<span style=color:#e06c75>traceID</span> = <span style=color:#98c379>&#34;unknown&#34;</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#e06c75>fmt</span>.<span style=color:#61afef;font-weight:700>Printf</span>(<span style=color:#98c379>&#34;Processing request with Trace ID: %s\n&#34;</span>, <span style=color:#e06c75>traceID</span>)
</span></span><span style=display:flex><span>	<span style=color:#61afef;font-weight:700>logSomething</span>(<span style=color:#e06c75>ctx</span>, <span style=color:#98c379>&#34;Starting database query...&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>logSomething</span>(<span style=color:#e06c75>ctx</span> <span style=color:#e06c75>context</span>.<span style=color:#e06c75>Context</span>, <span style=color:#e06c75>message</span> <span style=color:#e5c07b>string</span>) {
</span></span><span style=display:flex><span>	<span style=color:#e06c75>traceID</span>, <span style=color:#e06c75>ok</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>ctx</span>.<span style=color:#61afef;font-weight:700>Value</span>(<span style=color:#e06c75>key</span>).(<span style=color:#e5c07b>string</span>)
</span></span><span style=display:flex><span>	<span style=color:#c678dd>if</span> !<span style=color:#e06c75>ok</span> {
</span></span><span style=display:flex><span>		<span style=color:#e06c75>traceID</span> = <span style=color:#98c379>&#34;unknown&#34;</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#e06c75>fmt</span>.<span style=color:#61afef;font-weight:700>Printf</span>(<span style=color:#98c379>&#34;[Log - Trace ID: %s] %s\n&#34;</span>, <span style=color:#e06c75>traceID</span>, <span style=color:#e06c75>message</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#7f848e>// 假设这是请求的入口，我们生成一个 traceID 并存入 context</span>
</span></span><span style=display:flex><span>	<span style=color:#e06c75>ctx</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>context</span>.<span style=color:#61afef;font-weight:700>WithValue</span>(<span style=color:#e06c75>context</span>.<span style=color:#61afef;font-weight:700>Background</span>(), <span style=color:#e06c75>key</span>, <span style=color:#98c379>&#34;xyz-123-abc&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#61afef;font-weight:700>processRequest</span>(<span style=color:#e06c75>ctx</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul><h2 id=context-最佳实践>Context 最佳实践</h2><ol><li><p><strong><code>Context</code> 作为函数第一个参数</strong>：按照惯例，如果函数需要接受 <code>Context</code>，应该将其作为第一个参数，通常命名为 <code>ctx</code>。</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>DoSomething</span>(<span style=color:#e06c75>ctx</span> <span style=color:#e06c75>context</span>.<span style=color:#e06c75>Context</span>, <span style=color:#e06c75>arg1</span> <span style=color:#e5c07b>string</span>, <span style=color:#e06c75>arg2</span> <span style=color:#e5c07b>int</span>) <span style=color:#e5c07b>error</span> { <span style=color:#56b6c2>...</span> }
</span></span></code></pre></div></li><li><p><strong>不要将 <code>Context</code> 存储在结构体中</strong>：应该显式地在函数间传递 <code>Context</code>。将其存储在结构体中会使其生命周期变得不明确。</p></li><li><p><strong><code>Context</code> 是线程安全的</strong>：可以放心地在多个 <code>goroutine</code> 中同时使用同一个 <code>Context</code>。</p></li><li><p><strong>只传递真正必要的数据</strong>：<code>WithValue</code> 很方便，但也容易被滥用。只用它来传递那些必须贯穿整个调用链的请求范围数据。</p></li><li><p><strong>空 <code>Context</code> 不应为 <code>nil</code></strong>：即使一个函数允许，也不要传递一个 <code>nil</code> 的 <code>Context</code>。如果你不确定用什么，就使用 <code>context.TODO()</code>。</p></li></ol><h2 id=总结>总结</h2><p><code>context</code> 是 Go 并发编程模型中不可或缺的一部分。它通过简洁的接口和强大的树状传播机制，为处理并发操作的取消、超时和数据传递提供了标准化的解决方案。深刻理解其原理并遵循最佳实践，将帮助你编写出更健壮、更可靠、更易于维护的 Go 程序</p><h2 id=推荐阅读>推荐阅读</h2><ul><li><a href=https://go.dev/src/context/context.go>context.go</a></li><li><a href=https://go.dev/blog/context>Go Concurrency Patterns: Context</a></li><li><a href=https://go.dev/blog/context-and-structs>Contexts and structs</a></li><li><a href=https://www.sohamkamani.com/golang/context/>How to Use Context in Golang (Deadlines, Cancellation, and Passing Values)</a></li></ul></section></main><footer id=main-footer><div class=footer><a href=#>回到顶部 ↑</a><div class=footer-copyright><div>© 2025 Chen-Hang</div><div>powered by <a href=https://github.com/math-queiroz/rusty-typewriter target=_blank>Rusty Typewriter</a> theme for <a href=https://gohugo.io/ target=_blank>Hugo</a></div></div></div></footer></div><aside id=side-pane class=side-sticky><div class=side-details><span>2539 字数</span>
<span>9 - 11 阅读时间</span></div><h3>目录</h3><nav id=TableOfContents><ul><li><a href=#为什么需要-context->为什么需要 Context ？</a></li><li><a href=#context-的核心原理>Context 的核心原理</a><ul><li><a href=#context-接口>Context 接口</a></li><li><a href=#context-树状结构和传播机制>Context 树状结构和传播机制</a></li></ul></li><li><a href=#context-的使用>Context 的使用</a><ul><li><a href=#顶层空-context>顶层(空) Context</a></li><li><a href=#可取消-context>可取消 Context</a></li><li><a href=#传递值-context>传递值 Context</a></li></ul></li><li><a href=#context-最佳实践>Context 最佳实践</a></li><li><a href=#总结>总结</a></li><li><a href=#推荐阅读>推荐阅读</a></li></ul></nav></aside></div></div></body></html>