[{"content":"Goose 是一个 Go 语言包，提供了一系列快速构建服务的工具。\n设计原则 约定优于配置 - 提供合理的默认值 模块化设计 - 可插入函数 易于使用 - 简单直观的 API 可扩展性 - 允许用户替换默认实现 设计模式： 构建器模式 新功能和功能选项模式 上下文模式 使用声明式编程风格 ","date":"8 April, 2025","id":0,"permalink":"/blogs/2025-04-08.goose/","summary":"Goose 是一个 Go 语言包，提供了一系列快速构建服务的工具。","tags":"go","title":"Goose"},{"content":" Hugo 是最受欢迎的开源静态网站生成器之一. 凭借其惊人的速度和灵活性，Hugo 让网站建设再次变得有趣.\n本篇内容将全部基于Hugo 官方文档以及个人的实际操作. 实际上Hugo 的官方文档非常加十分的详细，我也超级推荐直接阅读官方的文档. 但是官方文档的内容太多，这对新手来说第一时间很难上手，包括我，所以我想将整个文档进行阅读记录，以方便入门.\n于此同时，本站点也是使用了Hugo 进行搭建，所以进行这样一份学习记录也许有助于我改进网站.\nHugo Hugo是一个用Go语言编写的静态网站生成器，针对速度进行优化，并且灵活设计. 它凭借先进的模板系统和快速的资产管道，Hugo可以在几秒钟内渲染出完整的站点.\n其灵活的框架设计、多语言支持和强大的分类系统，Hugo很适合搭建文档站点，博客站点，以及各种静态网站.\n安装 这里仅演示linux 下的安装过程\n在按照Hugo前，你需要先了解Hugo提供的三个版本：标准版、扩展版和扩展/部署版.\n标准版：仅包含核心功能，适合于开发者和普通用户使用. 扩展版：包含标准版所有功能，并且提供了许多扩展功能，如图片WebP格式处理, 使用嵌入的LibSass转化CSS, 使用Dart Sass转换器等. 扩展/部署版：包含扩展版所有功能，并且提供了许多部署功能，如Google Cloud Storage、AWS S3或者Azure存储容器等. Hugo官方推荐使用扩展版, 下面的安装过程也展示扩展版的安装.\n环境准备 使用Hugo时，Git, Go和Dart Sass是经常使用的. 其中Git是必须的，Go和Dart Sass如果不选择安装仅影响部分功能的使用.\n安装Git(必要) 安装Go(可选) 安装Dart Sass(可选) 直接下载 源码构建 仓库软件包 快速上手 配置 部署 模板 ","date":"8 April, 2025","id":1,"permalink":"/hugoes/hugo-docs/","summary":"Hugo 是最受欢迎的开源静态网站生成器之一. 凭借其惊人的速度和灵活性，Hugo 让网站建设再次变得有趣.","tags":"hugo","title":"Hugo Docs (Continuous Updates)"},{"content":" 这是一个归档|推荐|测试的文章.\nBitcask是一个高性能的键值存储系统，设计之初的目的是提供高写入吞吐量和高效读取性能。采用了日志化结构哈希表(Log-Structured Hash Table)，核心是写前日志(WAL)、内存哈希表和定期merge.\n具体细节均在官方的设计论文 Bitcask Design Paper 中可以查看。\n官方论文中提到的bitcask应该具备的特性\nlow latency per item read or written high throughput, especially when writing an incoming stream of random items ability to handle datasets much larger than RAM w/o degradation crash friendliness, both in terms of fast recovery and not losing data ease of backup and restore a relatively simple, understandable (and thus supportable) code structure and data format predictable behavior under heavy access load or large volume a license that allowed for easy default use in Riak 目前已经有优秀的开源实现：\nprologic/bitcask ahmeducf/bitcask rosedblabs/mini-bitcask Bitcask 核心 目录结构(bitcask)：作为一个目录，存储数据文件，仅允许一个进程同时写入 数据文件(datafile)： activefile: 当前用于写入的文件，达到阈值（1GB）时关闭，变成仅读文件 readonlyfile: 仅读文件，存储旧数据条目 dataentry: 写入数据文件的数据条目 =\u0026gt; { crc | tstamp | key_sz | value_sz | key | value } 内存结构(keydir): 映射键值到数据文件中的位置，每次写入时原子更新 index: [key] -\u0026gt; { file_id | value_sz | value_pos | tstamp } 合并(merge): 定期或者主动触发合并操作，遍历不可变文件，创建新的包含最新现有键的数据文件，同时生成提示文件(hint) 提示文件(hint): 包含数据文件中值的位置和大小信息，即保存keydir，加速启动流程 恢复崩溃(recover): 由于数据文件的不可变且作为提交日志，恢复简单，扫描提示文件进行恢复 在bitcask论文中提到，允许处理比内存大得多的数据集，且不显著降低性能，是因为其采用了将键和元数据存储在内存中，而将数据值存储在磁盘上，通过键值分离的设计，使其能够处理比内存大得多的数据集。但是因此bitcask将所有的键存储在内存中，这可能在键数量极多的时候成为瓶颈。\n","date":"7 April, 2025","id":2,"permalink":"/archive/projects/bitcask/","summary":"这是一个归档|推荐|测试的文章.","tags":"","title":"Archive - Bitcask"},{"content":"Bitcask是一个高性能的键值存储系统，设计之初的目的是提供高写入吞吐量和高效读取性能。采用了日志化结构哈希表(Log-Structured Hash Table)，核心是写前日志(WAL)、内存哈希表和定期merge.\n具体细节均在官方的设计论文 Bitcask Design Paper 中可以查看。\n官方论文中提到的bitcask应该具备的特性\nlow latency per item read or written high throughput, especially when writing an incoming stream of random items ability to handle datasets much larger than RAM w/o degradation crash friendliness, both in terms of fast recovery and not losing data ease of backup and restore a relatively simple, understandable (and thus supportable) code structure and data format predictable behavior under heavy access load or large volume a license that allowed for easy default use in Riak 目前已经有优秀的开源实现：\nprologic/bitcask ahmeducf/bitcask rosedblabs/mini-bitcask Bitcask 核心 目录结构(bitcask)：作为一个目录，存储数据文件，仅允许一个进程同时写入 数据文件(datafile)： activefile: 当前用于写入的文件，达到阈值（1GB）时关闭，变成仅读文件 readonlyfile: 仅读文件，存储旧数据条目 dataentry: 写入数据文件的数据条目 =\u0026gt; { crc | tstamp | key_sz | value_sz | key | value } 内存结构(keydir): 映射键值到数据文件中的位置，每次写入时原子更新 index: [key] -\u0026gt; { file_id | value_sz | value_pos | tstamp } 合并(merge): 定期或者主动触发合并操作，遍历不可变文件，创建新的包含最新现有键的数据文件，同时生成提示文件(hint) 提示文件(hint): 包含数据文件中值的位置和大小信息，即保存keydir，加速启动流程 恢复崩溃(recover): 由于数据文件的不可变且作为提交日志，恢复简单，扫描提示文件进行恢复 在bitcask论文中提到，允许处理比内存大得多的数据集，且不显著降低性能，是因为其采用了将键和元数据存储在内存中，而将数据值存储在磁盘上，通过键值分离的设计，使其能够处理比内存大得多的数据集。但是因此bitcask将所有的键存储在内存中，这可能在键数量极多的时候成为瓶颈。\n","date":"5 April, 2025","id":3,"permalink":"/blogs/bitcask/2025-04-05.bitcask-core/","summary":"Bitcask是一个高性能的键值存储系统，设计之初的目的是提供高写入吞吐量和高效读取性能。采用了日志化结构哈希表(Log-Structured Hash Table)，核心是写前日志(WAL)、内存哈希表和定期merge.","tags":"bitcask","title":"Bitcask"},{"content":"关于本站 本站由 Hugo 搭建，使用基于math-queiroz/Rusty-Typewriter 二次开发的 chhz0/Rusty-Typewriter 主题.\n我计划在这里记录自己的学习笔记，包括但不限于 Golang, Java, Cangjie, 计算机基础, Linux, 计算机网络, Git, Docker, Kubernetes, Message Queue, MySQL, Redis, HTML, CSS, JavaScript, TypeScript, Vue, React以及一些 开源项目 等\u0026hellip;\n哈哈，这里画的饼有点多，未来将以单个主题来写，希望能坚持下去!\n文章结构 this is a example of directory structure content/ ├── archive │ ├── _index.md │ └── projects │ ├── bitcask.md │ └── _index.md ├── blogs │ ├── 2025-04-08.goose.md │ ├── bitcask │ │ ├── 2025-04-05.bitcask-core.md │ │ └── 2025-04-08.build-your-own-bitcask.md │ └── _index.md ├── hugoes │ ├── build-my-hugo-site.md │ └── hugo-docs.md ├── about.md └── search.md 在content/blogs 目录下，将以 date.title.md 的markdown文件列表. content/archive/**/* 将存在目录层级，以方便查找想要阅读的博客，\n计划未来支持 更加灵活的i18n支持 更多元的markdown支持 更加丰富的icon支持 更多丰富的组件支持 更详细的TODO列表 提供ctl+k打开搜索功能 ==\u0026gt; 已支持 修复不同语言下details_read_time错误 ==\u0026gt; 支持中文 修复归档文章的shortcode无法正常显示toc以及details_read_time 修复search搜索时查找错误 修复白天黑夜主题不点击主题按钮却发生主题切换的bug ","date":"5 April, 2025","id":4,"permalink":"/about/","summary":"本站由 Hugo 搭建，使用基于math-queiroz/Rusty-Typewriter 二次开发的 chhz0/Rusty-Typewriter 主题.","tags":"","title":"About"}]