<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>| ch.hugo</title>
<link rel=icon href=favicon.svg sizes=any type=image/svg+xml><meta property="og:url" content="https://chhz0.github.io/interviews/mysql/"><meta property="og:site_name" content="ch.hugo"><meta property="og:title" content="ch.hugo"><meta property="og:description" content="0. SQL语法 0.1 count主键和count非主键结果会不同吗？ 分析：count()函数是返回表中某个列的非NULL值数量
主键不能存储NULL值，所以count(主键)返回的结果，可以表示数据库中所有行数据的量 非主键可以保存NULL值，所以count(非主键)返回表中非主键列的非NULL值的数量 回答： 主键不能存NULL值，所以count主键代表统计表中所有行数据的数量 而非主键可以存储NULL值，所以count非主键返回的是表中这个列的非NULL值的数量
一、索引面试题 1.1 MySQL有哪些索引？ 分析：索引是由存储引擎来实现的，不同存储引擎支持的索引类型也是不同的，大多数存储引擎都是支持
B+树索引，哈希索引，全文索引的区别：
B+树索引：InnoDB引擎默认的索引，支持排序，分组，模糊查询等，并且性能稳定 哈希索引：多用于等值查询，时间复杂度为O(1)，效率非常高，但不支持排序，范围查询以及模糊查询 全文索引：一般用于查询文本中的关键字，而不是直接比较是否相等等，主要用来解决 WHERE name LIKE “%aaaa%” dev.mysql.com
回答：我了解到Mysql支持B+树索引，哈希索引，全文索引这三种索引类型，比较常用的是B+树索引，因为它是InnoDB引擎默认使用的索引类型，支持排序，分组，范围查询，模糊查询等
1.2 InnoDB引擎的索引数据结构是什么？ 回答：InnoDB引擎是采用B+树作为索引的数据结构
1.3.0 mysql为什么使用B+树？ 分析：这里要回答对平衡树、红黑树，跳表，B树等的对比
回答：
B+树是多叉树，平衡二叉树、红黑树是二叉树，在同等数据量下，平衡二叉树、红黑树高度更高，磁盘IO次数更多，性能更差，而且它们会频繁执行在平衡过程，来保证树形结构平衡 和B+树相比，跳表在极端情况下会退化为链表，平衡性差，而数据库查询需要一个可预期的查询时间，并且跳表需要更多的内存 和B+树相比，B树的数据结构存储在全部节点，对范围查询不友好，非叶子节点存储了数据，导致内存中难以放下全部非叶子节点，如果内存放不下非叶子节点，那么意味着查询非叶子节点的时候都需要磁盘IO 学习：10｜数据库索引：为什么MySQL用B+树而不用B树？ | JUST DO IT
1.3 为什么索引用B+树？而不用红黑树？ 分析：InnoDB引擎的数据是存储在磁盘上的，所以选择数据结构的第一优先级是考虑从磁盘查询数据的成本，如果树的高度越高，意味着磁盘I/O就越多，这样会影响查询性能
对于N个叶子节点的B+树，其搜索复杂度为O(logdN) ，其中d表示节点允许的最大子节点个数为d
在实际的应用中，即使数据达到了千万级别，B+树的高度依旧维持在34层，也就是说一次数据查询操作只需要做34次的磁盘I/O操作
而红黑树本质上是二叉树，二叉树的每个父节点的儿子节点只能是2个，意味着其搜索复杂度为O(logN) ，这已经比B+Tree高出不少，因此二叉树搜索到目标数据所经历的磁盘I/O次数要更多
回答：主要原因是随着数据量的增多，红黑树的树高会比B+树高 ，这样查询数据的时候会面临更多的磁盘I/O，查询性能没那么好。
因为红黑树本质是二叉树，而b+树是多叉树，存储相同数量的数据量下，红黑树的树高会比B+树的树高，由于InnoDB引擎的数据都是存储在磁盘上的，如果树的高度过高，意味着磁盘I/O就越多，会影响到查询性能，所以InnoDB引擎的索引选择了B+树
1.4 为什么索引用B+树？而不是B树？ 分析：考察对B+树 和 B 树的理解，可以从三个角度分析
磁盘I/O角度
范围查询角度
增删改查角度
回答：我觉得主要有三个原因：
B+树的磁盘读写代价更低：B+树只有叶子节点存储索引和数据，非叶子节点只存放索引，而B树所有节点都会存放索引和数据，因此存储相同数据量的情况下，B+树可以比B树更矮胖，查询叶子节点的磁盘I/O次数也少
B+树便于范围查询：MySQL经常需要使用范围查询，B+树所有叶子节点间都有链表进行连接，这种设计对范围查询查询非常有帮助，B树没有将所有叶子节点用链表串联起来的结构，只能用中序遍历来完成范围查询，这会比B+树范围查询涉及多个节点的磁盘I/O操作，一次范围查询的效率不如B+树
B+树增删改查效率更加稳定：B+树有大量冗余节点，这些冗余数据可以让B+树在插入、删除的效率都更高，比如删除根节点的时候，不会像B树那样会发生复杂的树的变化。另外，B+树把所有指向数据的指针都放在叶子节点，因此查询、插入、删除数据都需要走到最后一层，这不同于B树可能在任意一层找到数据，所以B+树更为稳定
1.5 为什么索引用B+树？而不用哈希表？ 分析：
哈希表的数据是散列分布的，不具有序性，无法进行范围和排序
哈希表存在哈希冲突，哈希冲突严重，也会降低查询效率
回答：MySQL会有会多范围和排序的场景，虽然哈希表的搜索时间复杂度是O(1)，但是由于哈希表的数据都是通过哈希函数计算后散列分布的，所以哈希表索引不支持范围和排序操作，不支持联合索引最左匹配原则，如果重复键比较多，还容易操作哈希碰撞导致效率进一步降低。而B+树可以满足这些应用
1.6聚簇索引和非聚簇索引有什么区别？ 分析：先说聚簇索引和非聚簇索引B+树叶子节点存放内容的区别，然后再引出回表查询和覆盖索引查询"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="interviews"><meta name=twitter:card content="summary"><meta name=twitter:title content="ch.hugo"><meta name=twitter:description content="0. SQL语法 0.1 count主键和count非主键结果会不同吗？ 分析：count()函数是返回表中某个列的非NULL值数量
主键不能存储NULL值，所以count(主键)返回的结果，可以表示数据库中所有行数据的量 非主键可以保存NULL值，所以count(非主键)返回表中非主键列的非NULL值的数量 回答： 主键不能存NULL值，所以count主键代表统计表中所有行数据的数量 而非主键可以存储NULL值，所以count非主键返回的是表中这个列的非NULL值的数量
一、索引面试题 1.1 MySQL有哪些索引？ 分析：索引是由存储引擎来实现的，不同存储引擎支持的索引类型也是不同的，大多数存储引擎都是支持
B+树索引，哈希索引，全文索引的区别：
B+树索引：InnoDB引擎默认的索引，支持排序，分组，模糊查询等，并且性能稳定 哈希索引：多用于等值查询，时间复杂度为O(1)，效率非常高，但不支持排序，范围查询以及模糊查询 全文索引：一般用于查询文本中的关键字，而不是直接比较是否相等等，主要用来解决 WHERE name LIKE “%aaaa%” dev.mysql.com
回答：我了解到Mysql支持B+树索引，哈希索引，全文索引这三种索引类型，比较常用的是B+树索引，因为它是InnoDB引擎默认使用的索引类型，支持排序，分组，范围查询，模糊查询等
1.2 InnoDB引擎的索引数据结构是什么？ 回答：InnoDB引擎是采用B+树作为索引的数据结构
1.3.0 mysql为什么使用B+树？ 分析：这里要回答对平衡树、红黑树，跳表，B树等的对比
回答：
B+树是多叉树，平衡二叉树、红黑树是二叉树，在同等数据量下，平衡二叉树、红黑树高度更高，磁盘IO次数更多，性能更差，而且它们会频繁执行在平衡过程，来保证树形结构平衡 和B+树相比，跳表在极端情况下会退化为链表，平衡性差，而数据库查询需要一个可预期的查询时间，并且跳表需要更多的内存 和B+树相比，B树的数据结构存储在全部节点，对范围查询不友好，非叶子节点存储了数据，导致内存中难以放下全部非叶子节点，如果内存放不下非叶子节点，那么意味着查询非叶子节点的时候都需要磁盘IO 学习：10｜数据库索引：为什么MySQL用B+树而不用B树？ | JUST DO IT
1.3 为什么索引用B+树？而不用红黑树？ 分析：InnoDB引擎的数据是存储在磁盘上的，所以选择数据结构的第一优先级是考虑从磁盘查询数据的成本，如果树的高度越高，意味着磁盘I/O就越多，这样会影响查询性能
对于N个叶子节点的B+树，其搜索复杂度为O(logdN) ，其中d表示节点允许的最大子节点个数为d
在实际的应用中，即使数据达到了千万级别，B+树的高度依旧维持在34层，也就是说一次数据查询操作只需要做34次的磁盘I/O操作
而红黑树本质上是二叉树，二叉树的每个父节点的儿子节点只能是2个，意味着其搜索复杂度为O(logN) ，这已经比B+Tree高出不少，因此二叉树搜索到目标数据所经历的磁盘I/O次数要更多
回答：主要原因是随着数据量的增多，红黑树的树高会比B+树高 ，这样查询数据的时候会面临更多的磁盘I/O，查询性能没那么好。
因为红黑树本质是二叉树，而b+树是多叉树，存储相同数量的数据量下，红黑树的树高会比B+树的树高，由于InnoDB引擎的数据都是存储在磁盘上的，如果树的高度过高，意味着磁盘I/O就越多，会影响到查询性能，所以InnoDB引擎的索引选择了B+树
1.4 为什么索引用B+树？而不是B树？ 分析：考察对B+树 和 B 树的理解，可以从三个角度分析
磁盘I/O角度
范围查询角度
增删改查角度
回答：我觉得主要有三个原因：
B+树的磁盘读写代价更低：B+树只有叶子节点存储索引和数据，非叶子节点只存放索引，而B树所有节点都会存放索引和数据，因此存储相同数据量的情况下，B+树可以比B树更矮胖，查询叶子节点的磁盘I/O次数也少
B+树便于范围查询：MySQL经常需要使用范围查询，B+树所有叶子节点间都有链表进行连接，这种设计对范围查询查询非常有帮助，B树没有将所有叶子节点用链表串联起来的结构，只能用中序遍历来完成范围查询，这会比B+树范围查询涉及多个节点的磁盘I/O操作，一次范围查询的效率不如B+树
B+树增删改查效率更加稳定：B+树有大量冗余节点，这些冗余数据可以让B+树在插入、删除的效率都更高，比如删除根节点的时候，不会像B树那样会发生复杂的树的变化。另外，B+树把所有指向数据的指针都放在叶子节点，因此查询、插入、删除数据都需要走到最后一层，这不同于B树可能在任意一层找到数据，所以B+树更为稳定
1.5 为什么索引用B+树？而不用哈希表？ 分析：
哈希表的数据是散列分布的，不具有序性，无法进行范围和排序
哈希表存在哈希冲突，哈希冲突严重，也会降低查询效率
回答：MySQL会有会多范围和排序的场景，虽然哈希表的搜索时间复杂度是O(1)，但是由于哈希表的数据都是通过哈希函数计算后散列分布的，所以哈希表索引不支持范围和排序操作，不支持联合索引最左匹配原则，如果重复键比较多，还容易操作哈希碰撞导致效率进一步降低。而B+树可以满足这些应用
1.6聚簇索引和非聚簇索引有什么区别？ 分析：先说聚簇索引和非聚簇索引B+树叶子节点存放内容的区别，然后再引出回表查询和覆盖索引查询"><link rel=stylesheet href=/css/components.min.9d886688d3ae94cecf1b057e706bf74497fcd5cea352d433c34cda3b9425a8d4.css integrity="sha256-nYhmiNOulM7PGwV+cGv3RJf81c6jUtQzw0zaO5QlqNQ=" crossorigin=anonymous><link rel=stylesheet href=/css/main.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css integrity="sha256-47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=" crossorigin=anonymous><link rel=stylesheet href=/css/root.min.1677bc99f2421f7cb9fc1d00b09addcc951fd9d4c785e22b20ed55c0602786fc.css integrity="sha256-Fne8mfJCH3y5/B0AsJrdzJUf2dTHheIrIO1VwGAnhvw=" crossorigin=anonymous><link rel=stylesheet href=/css/search.min.cb1ed1dad3ee872e229e9f1fc681bdbd20d923389f1fa6aaf89f9aee93af4fbf.css integrity="sha256-yx7R2tPuhy4inp8fxoG9vSDZIzifH6aq+J+a7pOvT78=" crossorigin=anonymous><link rel=stylesheet href=/css/bundle.min.4878d16c866148ae8cfd6f4f44052d25f2548b24ab4a9bc857279dc6d06df2b5.css integrity="sha256-SHjRbIZhSK6M/W9PRAUtJfJUiySrSpvIVyedxtBt8rU=" crossorigin=anonymous><script src=/js/bundle.995e4ec99401021e081ec256bee66154ef7f4e5136809432513b2e6d014b4b1d.js integrity="sha256-mV5OyZQBAh4IHsJWvuZhVO9/TlE2gJQyUTsubQFLSx0=" crossorigin=anonymous></script><script defer src=/js/search/flexsearch.compact.64594b125f7b78bdf4fa8316955922bbebb1cd6baef3f16654bfca20309f18f8.js integrity="sha256-ZFlLEl97eL30+oMWlVkiu+uxzWuu8/FmVL/KIDCfGPg="></script><script defer src=/js/search/search.1d980f84df11f3eb7c8c5f17f541d49a0611608df179dd74fa7f06225eb56ace.js integrity="sha256-HZgPhN8R8+t8jF8X9UHUmgYRYI3xed10+n8GIl61as4="></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:opsz,wght@12..96,200..800&family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel=stylesheet></head><body class=notransition><div id=container><header id=main-header><div role=navigation aria-label=Main><div class=nav-left><a href=https://chhz0.github.io/ style=color:inherit>ch.hugo</a></div><div class=nav-right><div style=position:absolute;width:0;height:0><div id=nav-dropdown-menu class=hidden href=#><div class=nav-item><a href=/blogs/>博客</a></div><div class=nav-item><a href=/notes/>笔记</a></div><div class=nav-item><a href=/about/>关于</a></div></div></div><a id=nav-dropdown-button href=#><svg width="20" height="20" viewBox="0 0 24 24" fill="none"><path d="M4 6H20M4 12H20M4 18H20" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></a><div id=nav-menu><div class=nav-item><a href=/blogs/>博客</a></div><div class=nav-item><a href=/notes/>笔记</a></div><div class=nav-item><a href=/about/>关于</a></div></div><a id=theme-switcher href=#><svg class="light-icon" viewBox="0 0 24 24" fill="none"><path d="M12 3V4m0 16v1M4 12H3M6.31412 6.31412 5.5 5.5m12.1859.81412L18.5 5.5M6.31412 17.69 5.5 18.5001M17.6859 17.69 18.5 18.5001M21 12H20m-4 0c0 2.2091-1.7909 4-4 4-2.20914.0-4-1.7909-4-4 0-2.20914 1.79086-4 4-4 2.2091.0 4 1.79086 4 4z" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
<svg class="dark-icon" viewBox="0 0 24 24" fill="none"><path d="M3.32031 11.6835c0 4.9706 4.02944 9 8.99999 9 3.7872.0 7.028-2.3392 8.3565-5.6515C19.6402 15.4486 18.5059 15.6834 17.3203 15.6834c-4.9706.0-8.99999-4.0294-8.99999-8.99998C8.32031 5.50338 8.55165 4.36259 8.96453 3.32996 5.65605 4.66028 3.32031 7.89912 3.32031 11.6835z" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
</a>|
<a id=theme-switcher href=https://github.com/chhz0 aria-label=GitHub><svg class="light-icon" width="800" height="800" viewBox="0 0 20 20" xmlns:xlink="http://www.w3.org/1999/xlink"><title>github [#142]</title><desc>Created with Sketch.</desc><defs/><g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="Dribbble-Light-Preview" transform="translate(-140.000000, -7559.000000)" fill="#fff"><g id="icons" transform="translate(56.000000, 160.000000)"><path d="M94 7399C99.523 7399 104 7403.59 104 7409.253 104 7413.782 101.138 7417.624 97.167 7418.981 96.66 7419.082 96.48 7418.762 96.48 7418.489 96.48 7418.151 96.492 7417.047 96.492 7415.675 96.492 7414.719 96.172 7414.095 95.813 7413.777 98.04 7413.523 100.38 7412.656 100.38 7408.718 100.38 7407.598 99.992 7406.684 99.35 7405.966 99.454 7405.707 99.797 7404.664 99.252 7403.252 99.252 7403.252 98.414 7402.977 96.505 7404.303 95.706 7404.076 94.85 7403.962 94 7403.958 93.15 7403.962 92.295 7404.076 91.497 7404.303 89.586 7402.977 88.746 7403.252 88.746 7403.252 88.203 7404.664 88.546 7405.707 88.649 7405.966 88.01 7406.684 87.619 7407.598 87.619 7408.718 87.619 7412.646 89.954 7413.526 92.175 7413.785 91.889 7414.041 91.63 7414.493 91.54 7415.156 90.97 7415.418 89.522 7415.871 88.63 7414.304 88.63 7414.304 88.101 7413.319 87.097 7413.247 87.097 7413.247 86.122 7413.234 87.029 7413.87 87.029 7413.87 87.684 7414.185 88.139 7415.37 88.139 7415.37 88.726 7417.2 91.508 7416.58 91.513 7417.437 91.522 7418.245 91.522 7418.489 91.522 7418.76 91.338 7419.077 90.839 7418.982 86.865 7417.627 84 7413.783 84 7409.253 84 7403.59 88.478 7399 94 7399" id="github-[#142]"/></g></g></g></svg><svg class="dark-icon" width="800" height="800" viewBox="0 0 20 20" xmlns:xlink="http://www.w3.org/1999/xlink"><title>github [#142]</title><desc>Created with Sketch.</desc><defs/><g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="Dribbble-Light-Preview" transform="translate(-140.000000, -7559.000000)" fill="#000"><g id="icons" transform="translate(56.000000, 160.000000)"><path d="M94 7399C99.523 7399 104 7403.59 104 7409.253 104 7413.782 101.138 7417.624 97.167 7418.981 96.66 7419.082 96.48 7418.762 96.48 7418.489 96.48 7418.151 96.492 7417.047 96.492 7415.675 96.492 7414.719 96.172 7414.095 95.813 7413.777 98.04 7413.523 100.38 7412.656 100.38 7408.718 100.38 7407.598 99.992 7406.684 99.35 7405.966 99.454 7405.707 99.797 7404.664 99.252 7403.252 99.252 7403.252 98.414 7402.977 96.505 7404.303 95.706 7404.076 94.85 7403.962 94 7403.958 93.15 7403.962 92.295 7404.076 91.497 7404.303 89.586 7402.977 88.746 7403.252 88.746 7403.252 88.203 7404.664 88.546 7405.707 88.649 7405.966 88.01 7406.684 87.619 7407.598 87.619 7408.718 87.619 7412.646 89.954 7413.526 92.175 7413.785 91.889 7414.041 91.63 7414.493 91.54 7415.156 90.97 7415.418 89.522 7415.871 88.63 7414.304 88.63 7414.304 88.101 7413.319 87.097 7413.247 87.097 7413.247 86.122 7413.234 87.029 7413.87 87.029 7413.87 87.684 7414.185 88.139 7415.37 88.139 7415.37 88.726 7417.2 91.508 7416.58 91.513 7417.437 91.522 7418.245 91.522 7418.489 91.522 7418.76 91.338 7419.077 90.839 7418.982 86.865 7417.627 84 7413.783 84 7409.253 84 7403.59 88.478 7399 94 7399" id="github-[#142]"/></g></g></g></svg></a></div></div></header><div class="flex grow"><div id=main-pane><main id=main-content><div class=single-header><ol class=breadcrumbs itemscope itemtype=https://schema.org/BreadcrumbList><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://chhz0.github.io/><span itemprop=name>Home</span>
</a><meta itemprop=position content='1'></li><span>&nbsp»&nbsp</span><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://chhz0.github.io/interviews/><span itemprop=name>Interviews</span>
</a><meta itemprop=position content='2'></li><span>&nbsp»&nbsp</span></ol><h1>Interviews</h1><time class=dim datetime=0001-01-01T00:00:00+00:00>January 1, 1</time></div><section class=page-section><h2 id=0-sql语法>0. SQL语法</h2><h3 id=01-count主键和count非主键结果会不同吗>0.1 count主键和count非主键结果会不同吗？</h3><p>分析：count()函数是返回表中某个列的非NULL值数量</p><ul><li>主键不能存储NULL值，所以count(主键)返回的结果，可以表示数据库中所有行数据的量</li><li>非主键可以保存NULL值，所以count(非主键)返回表中非主键列的非NULL值的数量</li></ul><p>回答：
主键不能存NULL值，所以count主键代表统计表中所有行数据的数量
而非主键可以存储NULL值，所以count非主键返回的是表中这个列的非NULL值的数量</p><h2 id=一索引面试题>一、索引面试题</h2><h3 id=11-mysql有哪些索引>1.1 MySQL有哪些索引？</h3><p>分析：索引是由存储引擎来实现的，不同存储引擎支持的索引类型也是不同的，大多数存储引擎都是支持</p><p>B+树索引，哈希索引，全文索引的区别：</p><ul><li>B+树索引：InnoDB引擎默认的索引，支持排序，分组，模糊查询等，并且性能稳定</li><li>哈希索引：多用于等值查询，时间复杂度为O(1)，效率非常高，但不支持排序，范围查询以及模糊查询</li><li>全文索引：一般用于查询文本中的关键字，而不是直接比较是否相等等，主要用来解决 WHERE name LIKE &ldquo;%aaaa%&rdquo;</li></ul><p><a href=https://dev.mysql.com/doc/refman/8.0/en/storage-engines.html>dev.mysql.com</a></p><p>回答：我了解到Mysql支持B+树索引，哈希索引，全文索引这三种索引类型，比较常用的是B+树索引，因为它是InnoDB引擎默认使用的索引类型，支持排序，分组，范围查询，模糊查询等</p><h3 id=12-innodb引擎的索引数据结构是什么>1.2 InnoDB引擎的索引数据结构是什么？</h3><p>回答：InnoDB引擎是采用B+树作为索引的数据结构</p><h3 id=130-mysql为什么使用b树>1.3.0 mysql为什么使用B+树？</h3><p>分析：这里要回答对平衡树、红黑树，跳表，B树等的对比</p><p>回答：</p><ul><li>B+树是多叉树，平衡二叉树、红黑树是二叉树，在同等数据量下，平衡二叉树、红黑树高度更高，磁盘IO次数更多，性能更差，而且它们会频繁执行在平衡过程，来保证树形结构平衡</li><li>和B+树相比，跳表在极端情况下会退化为链表，平衡性差，而数据库查询需要一个可预期的查询时间，并且跳表需要更多的内存</li><li>和B+树相比，B树的数据结构存储在全部节点，对范围查询不友好，非叶子节点存储了数据，导致内存中难以放下全部非叶子节点，如果内存放不下非叶子节点，那么意味着查询非叶子节点的时候都需要磁盘IO</li></ul><p>学习：<a href=https://leeshengis.com/archives/672553>10｜数据库索引：为什么MySQL用B+树而不用B树？ | JUST DO IT</a></p><h3 id=13-为什么索引用b树而不用红黑树>1.3 为什么索引用B+树？而不用红黑树？</h3><p>分析：InnoDB引擎的数据是存储在磁盘上的，所以选择数据结构的第一优先级是考虑从磁盘查询数据的成本，如果树的高度越高，意味着磁盘I/O就越多，这样会影响查询性能</p><p>对于N个叶子节点的B+树，其搜索复杂度为<code>O(logdN)</code> ，其中d表示节点允许的最大子节点个数为d</p><p>在实际的应用中，即使数据达到了千万级别，B+树的高度依旧维持在3<del>4层，也就是说一次数据查询操作只需要做3</del>4次的磁盘I/O操作</p><p>而红黑树本质上是二叉树，二叉树的每个父节点的儿子节点只能是2个，意味着其搜索复杂度为<code>O(logN)</code> ，这已经比B+Tree高出不少，因此二叉树搜索到目标数据所经历的磁盘I/O次数要更多</p><p>回答：主要原因是随着数据量的增多，红黑树的树高会比B+树高 ，这样查询数据的时候会面临更多的磁盘I/O，查询性能没那么好。</p><p>因为红黑树本质是二叉树，而b+树是多叉树，存储相同数量的数据量下，红黑树的树高会比B+树的树高，由于InnoDB引擎的数据都是存储在磁盘上的，如果树的高度过高，意味着磁盘I/O就越多，会影响到查询性能，所以InnoDB引擎的索引选择了B+树</p><h3 id=14-为什么索引用b树而不是b树>1.4 为什么索引用B+树？而不是B树？</h3><p>分析：考察对B+树 和 B 树的理解，可以从三个角度分析</p><ul><li><p>磁盘I/O角度</p></li><li><p>范围查询角度</p></li><li><p>增删改查角度</p></li></ul><p>回答：我觉得主要有三个原因：</p><ul><li><p>B+树的磁盘读写代价更低：B+树只有叶子节点存储索引和数据，非叶子节点只存放索引，而B树所有节点都会存放索引和数据，因此存储相同数据量的情况下，B+树可以比B树更矮胖，查询叶子节点的磁盘I/O次数也少</p></li><li><p>B+树便于范围查询：MySQL经常需要使用范围查询，B+树所有叶子节点间都有链表进行连接，这种设计对范围查询查询非常有帮助，B树没有将所有叶子节点用链表串联起来的结构，只能用中序遍历来完成范围查询，这会比B+树范围查询涉及多个节点的磁盘I/O操作，一次范围查询的效率不如B+树</p></li><li><p>B+树增删改查效率更加稳定：B+树有大量冗余节点，这些冗余数据可以让B+树在插入、删除的效率都更高，比如删除根节点的时候，不会像B树那样会发生复杂的树的变化。另外，B+树把所有指向数据的指针都放在叶子节点，因此查询、插入、删除数据都需要走到最后一层，这不同于B树可能在任意一层找到数据，所以B+树更为稳定</p></li></ul><h3 id=15-为什么索引用b树而不用哈希表>1.5 为什么索引用B+树？而不用哈希表？</h3><p>分析：</p><ol><li><p>哈希表的数据是散列分布的，不具有序性，无法进行范围和排序</p></li><li><p>哈希表存在哈希冲突，哈希冲突严重，也会降低查询效率</p></li></ol><p>回答：MySQL会有会多范围和排序的场景，虽然哈希表的搜索时间复杂度是O(1)，但是由于哈希表的数据都是通过哈希函数计算后散列分布的，所以哈希表索引不支持范围和排序操作，不支持联合索引最左匹配原则，如果重复键比较多，还容易操作哈希碰撞导致效率进一步降低。而B+树可以满足这些应用</p><h3 id=16聚簇索引和非聚簇索引有什么区别>1.6聚簇索引和非聚簇索引有什么区别？</h3><p>分析：先说聚簇索引和非聚簇索引B+树叶子节点存放内容的区别，然后再引出回表查询和覆盖索引查询</p><p>回答：聚簇索引和非聚簇索引（二级索引）的最主要区别是B+树叶子节点存放的内容：</p><ul><li><p>聚簇索引的B+树叶子节点存放的是主键值+完整的记录</p></li><li><p>非聚簇索引的B+树叶子节点存放的是索引值+主键值</p></li></ul><p>如果查询条件用了二级索引，但查询的数据不是主键值，也不是二级索引值，这时在二级索引找到主键后，需要回表才能查找到数据，需要扫描两次B+树。如果查询的数据是主键值，因为在二级索引就能查询到，这时就会用到覆盖索引，不需要回表，只需要扫描一个B+树</p><h3 id=17insert操作对b树结构的改变是怎么样的>1.7insert操作对B+树结构的改变是怎么样的？</h3><p>分析：回答说出页分裂问题，以及指出主键id要是顺序递增，如果是随机值（比如uuid），就可能会频繁出现页分裂现象，会严重影响性能</p><p>如果使用非自增主键，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有的数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为页分裂。页分裂还可能造成大量的内存碎片，导致所有结构不紧凑，从而影响查询效率</p><p>回答：B+树的数据是有序的，所以：</p><ul><li><p>如果我们使用主键是顺序递增，那么每次插入新数据就会顺序插入到叶子节点最右边的节点里，如果页面满了，就会自动开辟一个新页面，将新数据插入到新页面。因为每次插入一条新记录，都是追加操作，不需要重新移动数据，因此这种插入数据的方法效率非常高</p></li><li><p>如果使用主键不是顺序递增，由于每次插入主键的索引值都是随机的，因此每次插入新数据时，就可能插入到现有数据页中间的某个位置，这时候为了保证B+树的有序性，要移动其它数据来满足新数据的插入。如果该页面满了，就发生页分裂，这时候要从一个页面复制数据到另外一个页面，目的是保证后一个数据页的所有行主键值比前一个数据页中主键值大，页分裂可能会造成大量的内存碎片，导致所有结构不紧凑，从而影响查询效率</p></li></ul><p>所以，我们在设计主键的时候，最好采用自增的方式，或者顺序递增主键值</p><h3 id=18假如一张表有两千万的数据b树的高度是多少怎么算>1.8假如一张表有两千万的数据，B+树的高度是多少？怎么算？</h3><p>分析：假设</p><ul><li><p>非叶子节点内指向其它页的数量为x</p></li><li><p>叶子节点内能容纳的数据行数为y</p></li><li><p>B+树的层高为z</p></li></ul><p>表总数等于x的z-1次方与y的乘积：</p><p><img src="https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDU1ZTMyYzM3OTExODM4ZDllYTNlYmVhYzZhZGJlZjBfUkxQbk5NajBsSmVVUmN6d3JlYXpkZm9Mc2xCejA0MTdfVG9rZW46WkRvZmJaSXJDb3Y3Nnd4cnhMaGNnVXVnbkhiXzE3MjE4NDEyMzM6MTcyMTg0NDgzM19WNA" alt></p><p>回答：具体看数据库表的字段多不多，以及字段类型，假设一行数据的大小是1kb，那么2000万的数据库，B+树的大概是三层高度</p><p><a href=https://xiaolincoding.com/mysql/index/2000w.html>MySQL 单表不要超过 2000W 行，靠谱吗？</a></p><h3 id=111-mysql有哪些索引>1.11 MySQL有哪些索引？</h3><p>分析：主键索引，唯一索引，普通索引，前缀索引，联合索引</p><ul><li><p>主键索引：主键索引是建立在主键字段上的索引，通常在创建表的时候一起创建，一张表最多只有一个主键，索引值不允许NULL值</p></li><li><p>唯一索引：唯一索引建立在UNIQUE字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但是允许NULL值</p></li><li><p>普通索引：普通索引是建立在普通字段上的索引，既不要求字段为主键，也不要求字段为UNIQUE</p></li><li><p>前缀索引：前缀索引是指对字符串类型字段的前几个字符创建的索引，而不是在整个字段上建立的索引，前缀索引可以建在字段类型为char、varchar、binary、varbinary的列上，使用前缀索引的目的是为了减少索引占用的存储空间，提高查询效率</p></li><li><p>联合索引：通过多个字段组合成一个索引，该索引被称为联合索引</p></li></ul><p>回答：MySQL有主键索引、唯一索引、前缀索引、普通索引和联合索引，InnoDB引擎要求每一张数据库表都必须有一个主键索引，比如表里的Id字段就是主键索引</p><p>然后针对查询比较频繁的字段，我们可以对这个字段建立普通索引，如果是多个字段，可以考虑建立联合索引，利用索引覆盖的特性提高查询效率</p><p>对长文本、字符串的字段，可以对这些字段的前缀部分建立索引，也就是建立前缀索引，可以减少索引的存储空间</p><h3 id=112-普通索引和唯一索引有什么区别哪个更新性能更好>1.12 普通索引和唯一索引有什么区别？哪个更新性能更好？</h3><p>分析：从InnoDB的change buffer的角度分析</p><p>回答：普通索引列的值是可以重复的，而唯一索引列的值是必须唯一的，当我们对唯一索引插入一条重复的值，会因为唯一性约束而报错</p><p>我认为普通索引的更新性能更好，因为普通索引在更新的时候，如果更新的数据也不在内存的话，可以直接把更新操作缓存在<strong>change buffer</strong>中，更新就结束了；但是，唯一索引因为需要唯一性约束，如果更新的数据页不再内存的话，需要从磁盘读取对应的数据页到内存，判断有没有冲突，这涉及到磁盘随机IO的访问</p><p>普通索引因为能使用change buffer特性，普通索引的更新比唯一索引，减少了随机磁盘访问，更新性能更好</p><h3 id=113-主键怎么设置假如你不会设置会怎样>1.13 主键怎么设置？假如你不会设置会怎样？</h3><p>分析：在创建表的时候，指定某一列为主键（PRIMARY KEY）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-SQL data-lang=SQL><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> <span style=color:#66d9ef>table_name</span> (
</span></span><span style=display:flex><span>    ID INT <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span>,
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>InnoDB在创建聚簇索引的时候，会根据不同的场景选择不同的列作为索引：</p><ul><li><p>如果有主键，默认使用主键作为聚簇索引的索引值</p></li><li><p>如果没有主键，就选择第一个唯一索引且不为NULL值的列作为聚簇索引的值</p></li><li><p>在上面都没有的情况下，InnoDB将自动生成一个隐式自增id列作为聚簇索引的索引值</p></li></ul><p>回答：</p><p>在创建表的时候，将id值设置为primary key，那么id列就是主键索引</p><p>如果没有主键，那就选择第一个不包含NULL值的唯一索引作为聚簇索引的索引键，如果这个条件页没有，那么InnoDB将自动生成以一个隐式rowid列作为聚簇索引的索引键</p><h3 id=114-为什么要建立索引>1.14 为什么要建立索引？</h3><p>分析：三个优点：</p><ul><li><p>索引大大减少了MySQL需要扫描的数据量</p></li><li><p>索引可以帮助MySQL避免外部排序和使用临时表</p></li><li><p>索引可以将随机I/O变成顺序I/O</p></li></ul><p>回答：如果没有建立索引，查询数据的话时间复杂度是O(n)，这样查询效率还是比较低，为了提高查询效率，可以建立索引</p><p>建立索引后，数据都会按照顺序存储，这时候我们可以按照类似二分查找的方式快速查找数据，B+树索引是多叉树，搜索时间复杂度是O(logdN)，提高了查询效率，除此之外，可以避免外部排序和使用临时表问题，以及将随机I/O变成顺序I/O</p><h3 id=115-我们一般选择什么样的字段来建立索引>1.15 我们一般选择什么样的字段来建立索引？</h3><p>分析：</p><p>适用索引的场景：</p><ul><li><p>字段具有唯一限制</p></li><li><p>经常用于<code>where</code> 查询条件的字段，这样可以提高整个表的查询速度，有多条件还可以创建联合索引</p></li><li><p>经常用于<code>group by</code> 和<code>order by</code> 的字段，这样查询的适合就不用再去做一次排序了，因为建立了索引之后在B+树中的记录都是排好序的</p></li></ul><p>不适合索引的场景：</p><ul><li><p><code>where</code> 条件，<code>group by</code> 和<code>order by</code> 里用不到的字段，索引的价值是快速定位，起不到定位作用的字段通常不需要创建索引，因为索引是会占用空间</p></li><li><p>字段中存在大量重复数据，不需要参加索引，例如性别字段</p></li><li><p>经常更新的字段不用创建索引，比如不要对余额字段创建索引，因为要维护B+树的有序性，那么就需要频繁的重建索引，这个过程会影响数据库的性能</p></li></ul><p>回答：对于频繁用于<code>where</code> 查询条件的字段建立索引，可以提高整张表的查询速度，如果查询条件不是一个字段，可以考虑建立联合索引，还有对于经常用于排序、分组的字段建立索引</p><p>对于一些区分度不高的字段，比如性别不建议建立索引，如果数据库中，数据的记录分布均匀，那么无论搜索的值是哪个都可能得到一半的数据，在这种情况下，MySQL的优化器发现某个值在表中出现的比例很高，它一般会忽略索引，进行全表扫描，这时候建立索引没有起到作用，而且所有还占用了存储空间</p><h3 id=116-索引越多越好吗>1.16 索引越多越好吗？</h3><p>分析：考虑索引的缺点，索引的最大好处是提高查询效率，索引也有缺点</p><ul><li><p>空间代价：需要占用物理空间，数量越大，占用空间越大；</p></li><li><p>时间代价：会降低表的增删改查的效率，每次删改索引，B+树为了维护索引有序性，都需要进行动态维护</p></li></ul><p>创建索引和维护索引要消耗时间，这种时间随着数据量的增大而增大</p><p>回答：不是的。索引虽然能提高查询效率，但是多建立一个索引，就意味着新生成一个B+树索引，需要占据存储空间，特别是在表数据非常大的时候，索引占用的空间越大</p><p>还有，索引越多数据库的写入性能会下降，因为每次对表进行增删改查的时候，都需要去维护各个B+树索引的有序性</p><h3 id=117-什么时候不用索引更好>1.17 什么时候不用索引更好？</h3><p>回答：建立了索引，虽然可以提高查询效率，但是带来了两个代价，一个是空间代价，创建索引需要多构建一个b+树，会占用磁盘空间。第二个是时间代价，每次增删改查，都需要动态维护b+树，以满足b+树的有序性</p><p>所以，在一张表经常增删改查的话，即读多写少的场景下，不建立索引会比较好，因为这时候维护的开销可能超过索引带来的性能提升</p><p>还有一点，如果表中某个列的值高度重复，那么建立了索引页没有用，优化器会选择全表扫描，这样建立的索引会占用存储空间，也会影响增删改查的效率，选择不用索引更好</p><h3 id=118-索引怎么优化>1.18 索引怎么优化？</h3><p>回答：-</p><ul><li><p>对于只需要查询几个字段数据的sql来说，我们可以对这些字段建立联合索引，这样查询方式就变成了覆盖索引，避免回表，减少了大量的I/O操作</p></li><li><p>主键值最好是递增的值，因为我们索引是按照顺序存储数据的，如果主键的值是随机的值，可能会引起页分裂的现象，页分裂会导致大量的内存碎片，这样索引结构不紧凑了，会影响查询效率</p></li><li><p>避免出现索引失效的sql语句，比如不要对索引进行计算、函数、类型转发操作，联合索引要正确使用需要遵循最左匹配原则</p></li><li><p>对于一些大字符串的索引，考虑用前缀索引只对索引列的前缀部分建立索引，节省索引的存储空间，提高查询效率</p></li></ul><h3 id=119-建立了索引查询的时候一定会用到索引吗>1.19 建立了索引，查询的时候一定会用到索引吗？</h3><p>分析：两个方向：</p><ul><li><p>索引失效的场景</p></li><li><p>优化器是基于成本考虑，即使查询条件用了索引，如果走索引的查询成本太高，也不会走索引</p></li></ul><p>回答：</p><p>不是的</p><p>了解到即使查询使用到了索引，也可能不走索引，比如</p><ul><li><p>当查询语句对索引字段进行左模糊匹配，表达式计算，函数，隐式类型转发操作，这时候查询语句就无法走索引了，查询方式变成了全表扫描，还有我们使用联合索引查询的时候，如果没有遵循最左匹配原则，也是会发生索引失效</p></li><li><p>优化器是基于成本考虑来选择查询的方式，在使用二级索引进行查询的时候，优化器会计算回表的成本和全表扫描的成本，如果回表的代价太高，优化器会选择不走索引，而是走全表扫描</p></li></ul><p><a href=https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%98%E5%AE%9D%E5%85%B8/11%20%20%E7%B4%A2%E5%BC%95%E5%87%BA%E9%94%99%EF%BC%9A%E8%AF%B7%E7%90%86%E8%A7%A3%20CBO%20%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.md>11 索引出错:请理解 CBO 的工作原理</a></p><h3 id=120-定义了一个varchar类型的日期字段并且有一个数据是20230922-如果这个日期字段上有索引那如果我查询的where条件是where-time--20230922不加单引号还会命中索引吗为什么>1.20 定义了一个varchar类型的日期字段，并且有一个数据是'20230922&rsquo;, 如果这个日期字段上有索引，那如果我查询的where条件是where time = 20230922不加单引号，还会命中索引吗？为什么？</h3><p><img src="https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=NmM1ZjQ0NzU1N2EwYmI3MjM0MDg0NzhlMThlMmFiNzdfMVFJZ1A3M3BScXZIbnR4YkxHWjU2R1FiVGdBTklubFBfVG9rZW46UmpYemJPU3Fnb1RDMFR4a1Q2bWNxejZQbnplXzE3MjE4NDEyMzM6MTcyMTg0NDgzM19WNA" alt></p><p>回答：不会命中索引，因为mysql在遇到字符串和数字时，会发生隐式类型转换，会将字符串转化为数字，这个转换的过程会涉及到函数，这个查询，日期字段是字符串，会发生隐式类型转换的时候，就会作用在日期这个索引字段上，对索引进行函数计算，发生索引失效</p><h3 id=121-mysql最新版本解决了索引失效的哪些情况了吗>1.21 MySQL最新版本解决了索引失效的哪些情况了吗？</h3><p>回答：mysql 8.0可以给字段增加函数索引，可以解决对索引使用函数的时候，索引失效的问题</p><p>还有一个索引跳跃式扫描，即使没有遵循最左匹配原则，依然可以使用联合索引</p><h3 id=122-什么是最左匹配原则>1.22 什么是最左匹配原则？</h3><p>回答：假设一个<code>(a, b, c)</code> 联合索引，它的存储顺序是先按照a排序，在a相同的情况下排b，在b相同的情况下排c，由于这个特性，在使用联合索引时，存在最左匹配原则，具体的规则是：</p><ul><li><p>mysql会从联合索引从最左的索引列开始匹配条件，然后依次从左到右顺序匹配，如果查询条件没有用到某个列，那么该列右边的索引列都无法使用走索引</p></li><li><p>当查询条件中使用某个列，但是该列的值包含范围查询，范围查询的字段可以用到联合索引，但是范围查询字段后面的字段无法用到联合索引</p></li></ul><p><a href=https://xiaolincoding.com/mysql/index/index_interview.html>https://xiaolincoding.com/mysql/index/index_interview.html</a></p><h2 id=二事务面试题>二、事务面试题</h2><h3 id=21-mysql事务有什么特性>2.1 MySQL事务有什么特性？</h3><p>分析：考察事务的ACID特性</p><ul><li><p>原子性：一个事务中的所有操作，要么全部完成，要么全部不完成</p></li><li><p>一致性：是指事务操作前后，数据满足完整性约束，数据库保持一致性状态</p></li><li><p>隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以使得多个事务并发执行时不会相互干扰</p></li><li><p>持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障不会丢失</p></li></ul><p>回答：MySQL事务由ACID四大特性，分别是原子性、一致性、隔离性、持久性</p><ul><li><p>原子性就是事务中所有操作要么全部完成，要么全部不完成，不会结束在中间某个环节，原子性是由undo log日志保证的；</p></li><li><p>一致性意思是事务执行前后，数据库的状态必须保持一致性，一致性是通过持久性+原子性+隔离性这三个共同保证；</p></li><li><p>隔离性的意思是允许多个事务并发读写数据库，可以防止多个事务并发读写同一个数据库，导致数据不一致问题发生，隔离性是由mvcc和锁保证；</p></li><li><p>持久性的意思是保证事务完成后对数据的修改是永久的，不会因为系统故障而丢失，持久性是由redo log日志来保证的；</p></li></ul><h3 id=22-事务的隔离性如何保证>2.2 事务的隔离性如何保证？</h3><p>分析：先说由MVCC和锁实现，再说为什么用MVCC和锁能实现隔离性</p><p>回答：事务的隔离性是由MVCC和锁来实现的</p><p>可重复读隔离级别下的快照读（普通select），是通过MVCC来保证事务隔离性的，</p><p>当前读（update、select &mldr; for update）是通过行级锁来保证事务隔离性的</p><h3 id=23-事务的持久性如何保证>2.3 事务的持久性如何保证？</h3><p>分析：先说由redo log实现的，再说为什么用redo log能实现持久性</p><p>回答：事务的持久性是由redo log保证的，因为MySQL通过WAL（先写日志再写数据）机制，在修改数据时，会将本次对数据页的修改以redo log的形式记录下来，这时候更新操作就完成了，Buffer pool的脏页会通过后台线程刷盘，即使在脏页还没有刷盘的时候发生了数据库重启，由于修改操作记录到redo log，之前提交的记录都不会丢失，重启后在通过redo log，恢复脏页数据，从而保证事务的持久性</p><h3 id=24-事务的原子性如何保证>2.4 事务的原子性如何保证？</h3><p>分析：先说由undo log实现的，再说为什么用undo log能实现原子性</p><p>回答：事务的原子性是通过undo log实现的，在事务还没提交前，历史数据记录在undo log中，如果事务在执行过程中，出现了错误或者用户执行了ROLLBACK语句，MySQL可以利用undo log中的历史数据，将数据恢复到事务开始之前的状态，从而保证了事务的原子性</p><h3 id=25-mysql事务和redis事务有什么区别>2.5 MySQL事务和Redis事务有什么区别？</h3><p>分析：Redis事务没有保证原子性和持久性</p><ul><li><p>原子性：Redis事务没有回滚功能，没办法实现跟Mysql一样的原子性，如果在Redsi事务执行过程中，中间有命令出错，不会停止执行和回滚，这时候事务的执行会出现半成功的状态</p></li><li><p>持久性：</p><ul><li><p>RDB模式：在一个事务执行后，而下一次的RDB快照还未执行前，如果发生了宕机，这种情况下，事务修改的数据也是不能保证持久的</p></li><li><p>AOF模式：其三种选项no、everysec和always都会存在数据丢失，所以事务的持久性属性也还是得不到保证。</p></li></ul></li></ul><p>回答：MySQL事务能够实现ACID四大特性，而Redis事务没保证原子性和持久性</p><p>Redis事务没有回滚功能，没办法实现跟MySQL事务一样的原子性，就没办法保证事务执行期间，要不全部成功，要不全部成功，Redis事务执行过程中，如果中途有命令执行出错，不会停止和回滚，而是继续执行，那么就可能出现半成功的状态。</p><p>Redis不管是AOF模式，还是RDB快照，都没办法保证数据不丢失，所以Redis事务不具有持久性</p><h3 id=26-mysql事务隔离级别有哪些分别解决哪些问题>2.6 MySQL事务隔离级别有哪些？分别解决哪些问题？</h3><p>分析：MySQL共有四个隔离级别如下：</p><ul><li><p>读未提交：指一个事务还没提交时，它做的变更就能被其他事务看到</p></li><li><p>读提交：指一个事务提交之后，它做的变更才能被其他事务看到</p></li><li><p>可重复读：指一个事务执行过程中看到的数据，一直跟着这个事务启动时看到的数据是一致的，MySQL InnoDB引擎的默认隔离级别</p></li><li><p>串行化：会对记录加上锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行</p></li></ul><p>回答：MySQL默认隔离级别是可重复读。除此之外，MySQL的事务隔离级别有读未提交，读提交，可重复读，串行化</p><p>事务并发问题存在脏读、不可重复读、幻读这三种，</p><ul><li><p>读未提交没有解决什么问题</p></li><li><p>读提交解决了脏读，但是还存在不可重复读和幻读这两个问题</p></li><li><p>可重复读解决了脏读，不可重复读的问题，不过对幻读问题上是很大程度避免了，没有完全避免</p></li><li><p>串行化解决了脏读，不可重复读，幻读，但是事务的并发性是最差的</p></li></ul><h3 id=27-脏读和幻读有什么区别>2.7 脏读和幻读有什么区别？</h3><p>分析：考察脏读和幻读的基础</p><p>回答：</p><ul><li><p>脏读是一个事务读取到了另一个未提交事务修改过的数据，如果另一个事务回滚了，刚才读到的数据就与数据库的数据不一致了</p></li><li><p>幻读，是前后两次查询的结果集的数量是不同的，比如select执行了两次，但是第二次返回了第一次没有返回的行数据</p></li></ul><h3 id=28-mysql默认的隔离级别是什么怎么实现>2.8 MySQL默认的隔离级别是什么？怎么实现？</h3><p>分析：考察可重复读的实现实现原理（MVCC和锁）</p><p>回答：MySQL默认的隔离级别是可重复读</p><p>select查询是通过MVCC实现的，在MVCC实现中，每条记录都会保持多个版本，每个版本都有一个版本号，事务在读取数据时，会根据事务开始时的版本号来读取数据，从而保证了事务的隔离性。可重复读隔离级别是在开启事务后，执行一条select语句的时候，会生成一个Read View，后续事务查询数据的时候会复用Read View，所以保证了事务期间多次读取到的数据都是一致的。</p><p>可重复读有间隙锁，针对当前读，会加间隙锁和记录锁，可以防止其他事务插入新记录，也可以防止删除和更新记录</p><h3 id=29-介绍以下mvcc>2.9 介绍以下MVCC？</h3><p>分析：从MVCC是什么？解决了什么问题？实现原理？三方面回答</p><p>回答：MVCC是多版本并发控制，是通过记录历史版本数据，解决读写并发冲突问题，避免了读数据时加锁，提高了事务的并发性能</p><p>MySQL将历史数据存储在undo log中，结构逻辑上类似链表，MySQL数据行上有两个隐藏列，一个是事务ID，另一个是指向undo log的指针</p><p>事务开启后，执行第一个select语句的时候，会创建Read View，Read View记录了当前未提交的事务列表，通过与历史数据的事务ID比较，就可以根据可见性进行判断，判断这条记录是否可见，如果可见就直接将这个数据返回给客户端，如果不可见就继续往undo log版本链查找第一个可见的版本数据</p><p>（扩展，讲可见性规则——> 2.10 MVCC如何判断行记录对某个事务是否可见？）</p><h3 id=210-mvcc如何判断行记录对某个事务是否可见>2.10 MVCC如何判断行记录对某个事务是否可见？</h3><p>分析：Read View有四个重要的字段</p><ul><li><p>m_ids:指的是在创建Read View时，数据库中活跃事务的事务id列表，注意是一个列表</p></li><li><p>min_trx_id:指的是在创建Read View的时候，当前数据库中活跃的事务中id最小的事务</p></li><li><p>max_trx_id:知道是创建Read View时当前数据库中应该给下一个事务的id值，也就是当前全局事务中最大的事务id值+1；</p></li><li><p>creator_trx_id:指的是创建该Read View的事务的事务id</p></li></ul><p>记录中的两个隐藏列</p><ul><li><p>trx_id:当前事务对记录进行改动后，会将该事务的id记录在trx_id</p></li><li><p>roll_pointer:是一个指针，指向每一个旧版本记录（undo log）</p></li></ul><p>回答：每一条记录都有两个隐藏列，一个是事务id，另一个是指向历史数据undo log的指针，然后Read View有四个字段，分别是创建Read View的事务id，活跃事务id列表，活跃事务id列表中最小的id，下一个事务id</p><ul><li><p>当记录的事务id小于活跃事务id列表中最小的id，说明该记录是在创建Read View前提交好了，所以该记录是当前事务可见的</p></li><li><p>当记录的事务id大于下一个事务的id，就说明该记录是在创建Read View后才生成的，所以该记录是当前事务是不可见的</p></li><li><p>如果记录的事务id在最小的id和下一个事务id之间，这时候就需要判断记录的事务id是否在活跃的事务id列表中：</p><ul><li><p>如果该记录的事务id在活跃事务id列表中，说明该记录的事务还没提交，所以记录是不可见的</p></li><li><p>不在活跃事务id列表中，说明该记录的事务已经提交，那么该记录是可见的</p></li></ul></li></ul><h3 id=211-读已提交和可重复读隔离级别实现-mvcc的区别>2.11 读已提交和可重复读隔离级别实现 MVCC的区别？</h3><p>分析：生成readView的时机不同</p><p>回答：读已提交和可重复读隔离级别都是由MVCC实现的，它们的区别在于创建Read View的时机不同</p><ul><li><p>读已提交隔离级别在事务开启后，每次执行select都会生成一个新的Read View，所以每次select都能看到其他事务最近提交的数据</p></li><li><p>可重复读隔离级别在事务开启后，执行第一条select是生成一个Read View，然后整个事务期间都在复用这个Read View，所以一个事务执行过程中看到的数据，一直跟事务启动的时候看到的数据是一致的</p></li></ul><h3 id=212-为什么互联网公司用读已提交隔离级别>2.12 为什么互联网公司用读已提交隔离级别？</h3><p>分析：读已提交并发性能更高，因为读已提交没有间隙锁，只有记录锁，而可重复读是会有记录锁和间隙锁，所以读已提交隔离级别发生死锁的概率比较小</p><p>回答：读已提交的并发性能更好，因为读已提交没有间隙锁，只有记录锁，发生死锁的概率比较低，然后互联网业务对于幻读和不可重复读的问题都能接受，所以为了降低死锁的概率，提高事务的并发性能，都会选择使用读已提交隔离级别</p><h3 id=213-可重复读级别是如何解决不可重复读的>2.13 可重复读级别是如何解决不可重复读的？</h3><p>分析：分两种查询来回答</p><ul><li><p>快照读，靠MVCC解决不可重复读</p></li><li><p>当前读，靠行级锁中的记录锁解决不可重复读</p></li></ul><p>回答：MySQL提供了两种查询方式，一种是快照读，就是普通select语句，另外一种是当前读，比如 select for update语句。不同的查询方式，解决不可重复读问题方式不一样</p><ul><li><p>针对快照读：是通过MVCC实现的，在可重复读的隔离级别下，第一次select查询的时候，生成Read View，在第二次执行select的时候，会复用这个ReadView，这样前后两次查询的记录是一样的，不会读到其他事务更新的操作</p></li><li><p>针对当前读：是靠行级锁中的记录锁来实现的，在可重复读隔离级别下，第一次select for update语句查询的时候，会对记录加next-key锁，这个锁包含记录锁，这个时候如果其他事务更新了加了锁的记录，都会被阻塞，这样就不会发生不可重复读</p></li></ul><h3 id=214-可重复读隔离级别是如何解决幻读的>2.14 可重复读隔离级别是如何解决幻读的？</h3><p>分析：分两种查询来回答</p><ul><li><p>快照读，靠MVCC解决幻读</p></li><li><p>当前读，靠行级锁中的间隙锁解决幻读</p></li></ul><p>回答：MySQL提供了两种查询方式，一种是快照读，就是普通select语句，另外一种是当前读，比如select for update语句。不同的查询方式，解决不可重复读问题的方式不同</p><ul><li><p>快照读，是通过MVCC来解决的，在可重复读的隔离级别下，第一次执行select语句，会生成ReadView，在第二次执行select的时候，复用该ReadView，这样前后两次查询的结果集都是一样的，不会读到其他事务新插入的记录，这样就不会发生幻读</p></li><li><p>当前读，看靠行级锁中的间隙锁来实现的，在可重复读隔离级别下，第一次select for update语句查询的时候，会对记录加next-key锁，这个锁包含间隙锁，这个时候如果其他事务往这个间隙插入新记录的化，都会被阻塞，这样就不会发生幻读</p></li></ul><h3 id=215-可重复读隔离级别解决了什么问题有没有完全解决幻读>2.15 可重复读隔离级别解决了什么问题？有没有完全解决幻读？</h3><p>分析；强调可重复读隔离级别是很大程度上解决了幻读，但是没有完全解决</p><p>回答：可重复读解决了脏读，不可重复读问题，幻读在很大程度上避免了，但是并没有完全解决幻读，在一些特殊的场景，还是会发生幻读的问题。</p><h3 id=216-可重复读为什么不能完全避免幻读什么情况下出现幻读>2.16 可重复读为什么不能完全避免幻读？什么情况下出现幻读？</h3><p>分析：可重复读隔离级别场景下：</p><p>发生幻读的场景一：事务A中存在一条更新一条不存在的记录的语句，事务B在事务A更新之前insert这条不存在的记录并提交事务，事务A执行更新，能够正常执行且查询到这个记录</p><p>发生幻读的场景二：范围查询</p><p>回答：在可重复读隔离级别下，当先快照读后当前读的场景下可能会出现幻读的问题。</p><p>比如这个场景，事务A通过快照读的方式查询了id=5的记录，此时数据库没有该记录，然后事务B向这张表新插入一条id=5的记录并提交了事务。接着，事务A对id=5的记录进行了更新操作，这个时刻，这条新纪录隐藏列中的事务id就变成了事务A的id，这时候事务A再使用select语句去查询这条记录时候就可以看到这条记录了，这里事务A前后两次查询的结果集合数不一样，于是就发生了幻读</p><p>以上发生幻读的场景是可以避免的，就是尽量再开启事务后，马上执行select &mldr; for update语句</p><h3 id=217-可重复读隔离级别mvcc完全解决了不可重复读的问题吗>2.17 可重复读隔离级别，MVCC完全解决了不可重复读的问题吗？</h3><p>分析：不可重复读，代表前后两次查询的记录的值不一样</p><p>比如表里面有 id = 1, value =1 的记录</p><ul><li><p>事务a, 先执行select，查询到 id =1的value = 1</p></li><li><p>事务b，更新id =1的value =2 ，然后提交事务</p></li><li><p>事务a，执行select for update，当前读，然后就读到 id= 1，value的记录，意味着发生了不可重复读</p></li></ul><p>回答：如果前后两次查询都是普通select，就不会产生不可重复读的问题。但是如果第一次查询是快照读，第二次查询是当前读，那么就可能会发生不可重复读</p><h2 id=三锁面试题>三、锁面试题</h2><h3 id=31-细说一下mysql数据库中锁的分类>3.1 细说一下MySQL数据库中锁的分类</h3><p>分析：全局锁，表级锁，行级锁，强调InnoDB引擎实现了行级锁</p><p>回答：根据颗粒度的不同，MySQL的锁可以分为全局锁，表级锁，行级锁。</p><p>比较了解的是表级锁和行级锁，比如对一张表结构进行修改的时候，MySQL会对该表加一个元数据锁，元数据锁是属于表级锁</p><p>行级锁目前只有InnoDB存储引擎实现了，MyISAM存储引擎是不支持行级锁，只有表锁。</p><p>InnoDB存储引擎实现的是行级锁主要有记录锁，间隙锁，临键锁，插入意向锁这些</p><h3 id=32-在线上修改表结构会发生什么>3.2 在线上修改表结构，会发生什么？</h3><p>分析：表级锁</p><p>回答：线上环境可能存在很多事务在读取这个表，如果这张表进行表结构的修改，会发生阻塞，原因是有事务对这张表进行读写操作，会发生元数据锁，而修改表结构的时候，会生成元数据写锁，这时候就发生了读写冲突，所以修改表结构的操作就会发生阻塞，并且后续事务的增删改查操作都会阻塞</p><h3 id=33-innodb存储引擎中的行级锁有哪些>3.3 InnoDB存储引擎中的行级锁有哪些？</h3><p>分析：记录锁、间隙锁、临键锁、插入意向锁</p><p>回答：InnoDB实现的行级锁有记录锁、间隙锁、临键锁和插入意向锁，在我们增删改或者锁定读语句的时候，都会对记录加行级锁</p><h3 id=34-一条update语句没有带where条件加的是什么锁>3.4 一条Update语句没有带Where条件，加的是什么锁？</h3><p>分析：InnoDB加锁是索引加锁，可重复读级别下，加锁的基本单位是next-key锁，读已提交隔离级别下，加锁的级别单位是记录锁</p><p>更新没有带where条件，会全表扫描，会对每天记录都加锁</p><p>回答：</p><ul><li><p>可重复读的情况下：更新没有带where条件，会按照全表扫描，对每一条记录都加next-key锁，相当于锁住了全表</p></li><li><p>读已提交隔离级别下，没有间隙锁，更新没有带where条件，是全表扫描，那么会对每条记录都加记录锁</p></li></ul><h3 id=35-带了where条件没有命中索引加的是什么锁>3.5 带了Where条件没有命中索引，加的是什么锁？</h3><p>同上</p><h3 id=36-两条更新语句更新同一条记录加的是什么锁>3.6 两条更新语句更新同一条记录，加的是什么锁？</h3><p>分析：在可重复读的情况下，加锁的基本单位是next-key锁，但是在一些场景下会退化为记录锁或者间隙锁</p><h3 id=37-两条更新语句更新同一个跳记录的不同字段加的是什么锁>3.7 两条更新语句更新同一个跳记录的不同字段，加的是什么锁？</h3><p>分析：InnoDB加锁是加在行记录索引，不是针对更新字段的加锁</p><h3 id=38-mysql怎么实现乐观锁>3.8 MySQL怎么实现乐观锁？</h3><p>分析：可以基于版本号实现乐观锁，修改数据的时候带上版本号（时间戳）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-SQL data-lang=SQL><span style=display:flex><span><span style=color:#66d9ef>update</span> student <span style=color:#66d9ef>set</span> name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;xiaochen&#39;</span>, <span style=color:#66d9ef>version</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span> <span style=color:#66d9ef>where</span> id <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span> <span style=color:#66d9ef>and</span> <span style=color:#66d9ef>version</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p>回答：可以在数据库表增加一个版本号字段，利用这个版本号字段实现乐观锁</p><p>具体的实现，每次更新数据的时候，带上版本号，同时将版本+1，如果版本号和表记录中的版本号一致的话，就能更新成功，不相等就更新失败，然后重新获取该记录的最新版本号，然后再尝试更新数据</p><h3 id=39-了解过mysql怎么排查死锁问题>3.9 了解过MySQL怎么排查死锁问题？</h3><p>回答：在并发事务中，当两个事务出现循环资源依赖，这两个事务都在等待别的事务释放资源，就会导致这两个事务进入无限等待的状态，这时就发生了死锁</p><h3 id=310-mysql-怎么避免死锁>3.10 MySQL 怎么避免死锁？</h3><p>回答：</p><p>在遇到线上死锁的问题，应该第一时间获取相关的死锁日志。使用<code>show engine innodb status</code> 命令获取死锁信息</p><p>然后就分析死锁日志，</p><p>通过阅读死锁日志，可以清楚知道两个事务形成了怎么样的循环等待，然后根据当前各个事务执行的sql分析出加锁类型以及顺序，逆向推断出如何形成循环等待</p><blockquote><p><a href=https://www.aneasystone.com/archives/2018/04/solving-dead-locks-four.html>解决死锁之路(终结篇) - 再见死锁 - aneasystone&rsquo;s blog</a></p><p><a href=https://www.toberoot.com/database/mysql/dba_mysql/tec/mysql_5.7_%E6%AD%BB%E9%94%81%E5%88%86%E6%9E%90.html>MySQL 5.7 排查死锁</a></p><p><a href=https://xiaolincoding.com/mysql/lock/deadlock.html>MySQL 死锁了，怎么办？</a></p></blockquote><h2 id=四日志面试题>四、日志面试题</h2><h3 id=41-redo-log和-binlog-的区别和应用场景>4.1 redo log和 binlog 的区别和应用场景</h3><p>分析：redo log和 binlog 有四个区别的地方</p><ul><li><p>适用的对象不同</p><ul><li><p>binlog是MySQL的Server层实现的日志，所有的引擎都可以使用</p></li><li><p>Redo log是InnoDB存储引擎实现的日志</p></li></ul></li><li><p>文件格式不同</p><ul><li><p>binlog有3种格式类型，分别是STATEMENT、ROW、MIXED</p><ul><li>STATEMENT：每一条修改过的SQL都会记录到binlog中，</li></ul></li><li><p>redo log是物理日志，记录的是在某个数据页做了什么修改，</p></li></ul></li><li><p>写入方式不同</p><ul><li><p>binlog是追加写，写满一个文件，就创建一个文件继续写，不会覆盖以前的日志，保存的是全量的日志</p></li><li><p>Redo log是循环写，日志空间大小是固定的，全部写满就从头开始，保存未被刷入磁盘的脏页日志</p></li></ul></li><li><p>用途不同：</p><ul><li><p>binlog用于备份恢复，主从复制</p></li><li><p>Redo log用于掉电等故障</p></li></ul></li></ul><p>回答：</p><ul><li><p>redo log是InnoDB引擎实现的日志，属于物理日志，记录了InnoDB存储引擎对数据页所做的修改操作，主要用于崩溃恢复，例如某个事物提交了，脏页数据还可能没进行刷盘，如果mysql机器断电了，脏页的数据就丢失了，mysql重启后可以通过redo log将已提交事物的数据恢复过来</p></li><li><p>binlog是Server层实现的日志，保存了所有对数据库的增删改操作，binlog有三种日志格式，日志的内存可能是sql语句，数据本身或者两者混合，主要用于数据库的备份和归档，也用于主从复制</p></li></ul><h3 id=42-redo-log和binlog在恢复数据库有什么区别>4.2 redo log和binlog在恢复数据库有什么区别？</h3><p>分析：应用区别</p><p>回答：</p><ul><li><p>binlog是追加日志，写满一个日志，就创建一个文件继续写，不会覆盖以前的日志，保存了所有对数据库的更新操作，可以用来恢复某个时刻的数据或者全量恢复数据库数据</p></li><li><p>Redo log是循环写，日志空间大小是固定的，全部写满就从头开始，保存的是InnoDB存储引擎对数据页所做的修改操作，用来恢复因中途MySQL断电丢失的脏页数据</p></li></ul><h3 id=43-redo-log是怎么实现持久化>4.3 redo log是怎么实现持久化？</h3><p>回答：事务执行过程更新的数据，并不是在事务提交的时候，就把修改的数据刷入磁盘，而是修改buffer pool中数据页，并标记为脏页，然后在后台找到合适的时机进行刷盘</p><p>如果事务提交了，脏页数据没有刷盘的时候，数据库发生宕机，就会导致事务修改的数据丢失</p><p>所以MySQL引入了redo log，redo log保存的是物理日志，主要是记录InnoDB对某个数据页的修改操作，当事务提交的时候，redo log就先刷入磁盘，因为redo log保存了数据页的修改操作，即使脏数据没有刷盘时数据库发生了宕机，重启后MySQL通过重放redo log，就能恢复未刷盘的脏页，保证了数据的持久性</p><h3 id=44-redo-log除了崩溃恢复还有什么其它作用>4.4 redo log除了崩溃恢复还有什么其它作用</h3><p>分析：</p><p>回答：</p><p>写redolog的方式是追加的形式，所以redolog写磁盘是一个顺序写的过程，而数据页是一个随机写的过程，顺序写的性能比随机写的性能高，事务在提交的时候，是先写日志在写数据的机制（WAL），相当于把mysql写入磁盘的操作从磁盘随机写变成了顺序写，所以redolog还可以提高MySQL写入磁盘的性能</p><h3 id=45-为什么需要两阶段提交>4.5 为什么需要两阶段提交</h3><p>回答：</p><p>两阶段提交是为了保证redolog和binlog逻辑一致，从而保证主从复制的时候不会出现数据不一致的问题。</p><h3 id=46-两阶段提交的过程>4.6 两阶段提交的过程？</h3><p>分析：</p><p><img src="https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=ODI1NTQ4NmMwNzAzMjEyOTRhODVjMWIwMTE4OTEyMWNfRFd4SGxlVmVheENQZ24xYVZVUEQ4QWVIVFA0bEkxek9fVG9rZW46S2xYM2J3aEJlb09VV1Z4WVNJc2Nhd0tmbjlkXzE3MjE4NDEyMzM6MTcyMTg0NDgzM19WNA" alt></p><p>回答：</p><p>两个阶段，prepare阶段和commit阶段</p><p><a href=https://xiaolincoding.com/mysql/log/how_update.html>MySQL 日志：undo log、redo log、binlog 有什么用？</a></p><h2 id=六存储引擎>六、存储引擎</h2><h3 id=61-执行一条查询sql的全过程>6.1 执行一条查询sql的全过程</h3><p>回答：Mysql执行一条查询语句的时候，会经过连接器、查询缓存、解析器、优化器、执行器和存储引擎这些模块</p><ol><li><p>首先，mysql的连接器会负责建立连接、校验用户权限，接收客户端的sql语句</p></li><li><p>第二步，mysql会在查询缓存中查找数据，如果命中直接返回数据给客户端，否则就继续往下查询，不过这个查询缓存在mysql8.0版本就删除了，原因是只要对这张表进行了写操作，这张表的查询缓存就会失效，所以在实际场景中，查询缓存的命中率不高</p></li><li><p>第三步、mysql的解析器会对sql语句进行词法分析和语法分析，构建语法树，方便后续模块读取表名，字段，语句类型</p></li><li><p>第四步，mysql的优化器会基于查询成本的考虑，判断每个索引的执行成本，从中选择查询成本最小的执行计划</p></li><li><p>第五步，mysql的执行器会根据执行计划来执行查询语句，从存储引擎读取记录，返回客户端</p></li></ol><h3 id=62-mysql存储引擎有哪些>6.2 mysql存储引擎有哪些？</h3><p>分析：mysql整体上分server层和存储引擎层</p><ul><li><p>Server层负责的部分是连接器、查询缓存、解析器、优化器、执行器</p></li><li><p>存储引擎负责数据的读取和存储，存储引擎有InnoDB、MyISAM、Memory等</p></li></ul><p>回答：mysql常见的存储引擎有InnoDB、MyISAM、Memory</p><ul><li><p>比较熟悉的是InnoDB，它是MySQL默认的存储引擎，支持事物和行级锁，具有事物提交、回滚和崩溃恢复功能</p></li><li><p>MyISAM不支持事物和行级锁，而且由于只支持表锁，锁的颗粒度大，更新性能比较差，比较适合读多写少的场景</p></li><li><p>Memory了解较少，它是将数据存储在内存中，所以数据的读写比较快，但是数据不具备持久性，比较适用于临时存储数据的场景</p></li></ul><h3 id=63-myisam和innodb存储引擎有什么区别>6.3 MyISAM和InnoDB存储引擎有什么区别</h3><p>分析：从数据存储、B+树结构、锁粒度、事务四个角度分析</p><ul><li><p>数据存储：InnoDB引擎数据存储的方式采用的是索引组织表，在索引组织表中，数据即所有，索引即数据，因此表数据和索引数据都存储在同一个文件。MyISAM引擎数据存储的方式是采用堆表，在堆表的组织结构中，索引和数据是分开存储，因此表数据和索引数据分别放在两个不同的文件中存储</p></li><li><p>B+树结构：InnoDB引擎B+树叶子节点存储<strong>索引+数据</strong>；MyISAM引擎B+树叶子节点存储<strong>索引+数据地址</strong></p></li><li><p>锁粒度：InnoDB引擎支持行级锁；而MyISAM不支持行级锁，仅支持表锁</p></li><li><p>事务：InnoDB支持事务；MyISAM不支持事务</p></li></ul><p>回答：InnoDB引擎和MyISAM引擎在数据存储上不同，InnoDB引擎将表数据和索引数据存放在同一个文件，而MyISAM引擎将表数据和索引数据分开存储；所以，InnoDB引擎和B+树索引中的叶子节点存储的是索引和数据，MyISAM引擎B+树结构中的叶子节点存储的是索引和数据地。还有就是InnoDB引擎支持行级锁，MyISAM不支持行级锁，仅支持表锁</p><h3 id=64-用count哪个存储引擎会更快>6.4 用count(*)哪个存储引擎会更快？</h3><p>分析：InnoDB引擎执行count函数的时候，通过遍历的方式来统计记录个数，而MyISAM引擎执行count函数只需要O(1)复杂度，因为每张MyISAM的数据表都有一个meta信息存储了row_count值，由表级锁保证一致性，所以直接读取row_count的值就行</p><p>而InnoDB存储引擎是支持事务的，同一时刻的多个查询，由于多版本并发控制（MVCC）的原因，InnoDB应该返回多少数据不确定，无法维护一个row_count变量</p><p>回答：如果查询语句里面没有where查询条件，MyISAM引擎会比较快，因为MyISAM引擎的每张表会用一个变量存储表的总记录个数，执行count函数，直接返回这个变量就行。而InnoDB引擎执行count函数，需要遍历的方式来统计记录个数</p><p>如果查询语句与where查询条件，MyISAM和InnoDB引擎执行count函数的时候，性能差不多</p><h3 id=65-null值是如何存储的>6.5 NULL值是如何存储的？</h3><p>分析：<a href=https://xiaolincoding.com/mysql/base/row_format.html>MySQL 一行记录是怎么存储的？</a></p><p>回答：MySQL行格式中会用NULL值列表来标记值为NULL的列，每个列对应一个二进制位，如果列的值为NULL，就会标记二进制位为1，否则为0，所以NULL值并不会存储在行格式中的真实数据部分</p><p>NULL值表最少会占用1字节空间，当表中所有列都定义为NOT NULL，行格式中就不会有NULL值列表，这样可以省1字节空间</p><h3 id=66-char和varchar有什么区别>6.6 char和varchar有什么区别？</h3><p>分析：<a href=https://www.maoyingdong.com/mysql-char-vs-varchar/>MySQL中char与varchar的区别：存储机制、性能差异</a></p><p>回答：</p><ul><li><p>Char 是固定长度的字符串类型，它在数据库中占用固定存储空间，无论实际存储的数据长度是多少，如果实际存储的字符串长度小于定义的长度，系统会自动使用空格填充。</p></li><li><p>Varchar 是可变长度的字符串类型，实际存储时只占用实际字符串长度的空间，不会进行空格填充。</p></li></ul><p>设计数据库表的时候，大多数的时候是使用varchar可变长度的字符串类型，因为char会填充空格导致浪费存储空间，导致性能下降。因为char会多存储一些空格，意味着需要从磁盘多读写数据，会消耗更多的内存，还有查找数据时需要删除空格可能消耗一些cpu性能</p><h3 id=67-假如说一个字段是varchar10但它其实只有6个字节那么他在内存中的存储空间是多少在文件中的存储空间是多少>6.7 假如说一个字段是varchar(10)，但它其实只有6个字节，那么他在内存中的存储空间是多少？在文件中的存储空间是多少？</h3><p>分析：<a href=https://www.cnblogs.com/ailiailan/p/16010369.html>MySQL中varchar(10)和varchar(100)的优缺点 - 海布里Simple - 博客园</a></p><p>varchar是可变长字符串，保存到文件的时候，只会存储实际使用的字符串大小，但是内存会按照varchar最大值来固定分配大小</p><p>回答：内存会占用10字节，文件存储空间会占用6字节，并且会额外使用1-2字节存储[可变长字符串长度]的空间</p><h3 id=68-如果硬件内存特别大mysql缓存能否替代redis>6.8 如果硬件内存特别大，mysql缓存能否替代redis？</h3><p>分析：这里的mysql缓存代表用于缓存数据页的buffer pool，所以这个问题是，如果这个buffer pool无限大，能在内存装下所有数据，是否可以替代redis，从redis的优点跟mysql没有的点思考</p><p>回答：不能替代</p><p>mysql的所有模块，比如buffer pool、日志技术、事务并发模块都是面向磁盘页设计的，因此首要目标不是减少内存访问的代价，而是I/O访问的代价，所以内存访问代价并不是最优的选择，而redis是面向内存设计的数据库</p><p>mysql在内存查询一个数据页的时候，都需要先查询页表，也就是走b+树的搜索过程，时间复杂度是O(logdN),而redis提供了多种的数据类型，比如Hash数据对象的时候，可以在O(1)时间复杂度查到数据</p><p>mysql在更新数据的时候，mysql为了保证事务的隔离性，需要加锁，而redis更新操作都是不需要加锁的，还有Mysql为了保证事务的持久性，还需要刷盘redolog日志和binlog日志，Redis可以选择不持久化数据</p><p>因此，即使buffer pool无限大，Mysql缓存的性能还是没有redis好</p><p><a href=https://www.zhihu.com/question/498033940/answer/2219122998>既然有了innodb buffer pool为什么要有redis? - 知乎</a></p><hr><blockquote><p>mysql基础篇</p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg5ODU2ODczMQ==&amp;mid=2247486128&amp;idx=1&amp;sn=afbd3ca37f4727db9d32460f98e73d5a&amp;chksm=c061cdc4f71644d228cad54d6a8395e27a46a9540f219a4f3776e5aa023608d131f9ec70b687#rd">https://mp.weixin.qq.com/s?__biz=Mzg5ODU2ODczMQ==&mid=2247486128&idx=1&sn=afbd3ca37f4727db9d32460f98e73d5a&chksm=c061cdc4f71644d228cad54d6a8395e27a46a9540f219a4f3776e5aa023608d131f9ec70b687#rd</a></p><p>mysql原理篇</p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg5ODU2ODczMQ==&amp;mid=2247487888&amp;idx=1&amp;sn=973635eeaf7d1916e62bbceda72d27bd&amp;chksm=c061d6e4f7165ff271ee4bfc71de630c6538802b1d49c747bc0eb0be9264ae7619ed0648c47c#rd">https://mp.weixin.qq.com/s?__biz=Mzg5ODU2ODczMQ==&mid=2247487888&idx=1&sn=973635eeaf7d1916e62bbceda72d27bd&chksm=c061d6e4f7165ff271ee4bfc71de630c6538802b1d49c747bc0eb0be9264ae7619ed0648c47c#rd</a></p><p>mysql性能篇</p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg5ODU2ODczMQ==&amp;mid=2247494731&amp;idx=1&amp;sn=e1bb64dd33c008cf46d5995044589228&amp;chksm=c0622b3ff715a229ef1831b468eb47b07aabd1edfb87637bf5c45408418dd37e3cf4ee9eca2e&amp;scene=178&amp;cur_album_id=2225658380164055048#rd">https://mp.weixin.qq.com/s?__biz=Mzg5ODU2ODczMQ==&mid=2247494731&idx=1&sn=e1bb64dd33c008cf46d5995044589228&chksm=c0622b3ff715a229ef1831b468eb47b07aabd1edfb87637bf5c45408418dd37e3cf4ee9eca2e&scene=178&cur_album_id=2225658380164055048#rd</a></p></blockquote><h2 id=mysql基础篇>Mysql基础篇</h2><h3 id=1mysql是什么>1.Mysql是什么？</h3><p>回答：Mysql是一种传统的RDBM数据库，也就是关系型数据库，广泛应用于OLTP场景</p><h3 id=2oltp和olap的区别>2.OLTP和OLAP的区别？</h3><p>回答：</p><ul><li><p>OLTP（联机事务处理）：是传统的关系型数据库的主要应用，用于基本的、日常的事务处理，例如银行的交易记录</p></li><li><p>OLAP（联机分析处理）：是数据仓库系统的主要应用，支持复杂的分析操作，侧重决策支持，并且提供了直观易懂的查询结果。最常见的应用是复杂的动态报表系统</p></li><li><p>总体来说：OLTP用于日常处理，OLAP用于数据分析</p></li></ul><h3 id=3数据库的三范式分别是什么>3.数据库的三范式分别是什么？</h3><p>回答：</p><ol><li><p>第一范式：字段不可分。强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项</p></li><li><p>第二范式：有主键，非主键字段依赖主键。</p></li><li><p>第三范式：非主键字段不能互相依赖，任何非主键属性不依赖于其它非主属性</p></li></ol><h3 id=4dml是什么>4.DML是什么？</h3><p>回答：DML是数据操作语言，用于检索或者修改数据，平时最常使用的增删改查就是DML</p><h3 id=5ddl是什么>5.DDL是什么？</h3><p>回答：DDL是数据定义语言，用于操作数据结构，比如创建表，删除表，更改索引等都是DDL</p><h3 id=6dcl是什么>6.DCL是什么？</h3><p>回答：DCL是数据控制语言，用于定义数据库用户的权限，比如创建用户，授权用户，删除用户等都是DCL</p><h3 id=7varchar与char的区别是什么>7.varchar与char的区别是什么？</h3><p>回答：char是一种固定长度的类型，varchar则是一种可变长度的类型。比如char(128)和varchar(128)，前者无论字符串长短，在磁盘上，都会占据固定的128字符大小，后者是可变长度，不过它的长度不超过128</p><h3 id=8既然varchar是变长那是不是设置varchar1000一定比varchar100好>8.既然varchar是变长，那是不是设置varchar(1000)一定比varchar(100)好？</h3><p>回答：不是，虽然varchar是变长，在相同长度下，磁盘占用空间一样，将值设置更大，弹性空间也一样，但是这是由代价的，在内存加载的时候，每次都是按最大空间来分配的，显然，在排序场景，或者一些临时表聚合场景，更大的空间会产生明显的不利影响</p><h3 id=9varchar是变长char是定长那能用varchar完全替代char么>9.varchar是变长，char是定长，那能用varchar完全替代char么？</h3><p>回答：不能。varchar的优点是更灵活，但是char也有它的优势</p><p>首先varchar会额外占用一个字节存储长度信息，而char则节省了一个字节；</p><p>其次，char的存储空间是一次性分配的，存储是固定连续的，而varchar的存储的长度是可变的，当varchar更改前后的数据长度不一致时，就不可避免会出现碎片问题。针对此，需要进行碎片消除作业，也是额外的成本</p><p>一般来说，长度固定的字段，还是用char比较合适，比如Hash，就很适合用char</p><h3 id=10varchar11和int11中的11有什么区别>10.varchar(11)和int(11)中的11，有什么区别？</h3><p>回答：varchar中代表能存11个字符，int中只是代表显示长度，对大多数应用没有意义，只是规定一些工具用来显示字符的个数，比如int(1)和int(20)存储和计算其实是一样的</p><h3 id=11delete和truncate的区别>11.delete和truncate的区别？</h3><p>回答：delete是删除行；truncate是整表删除。具体来说，有以下区别：</p><ol><li><p>truncate之后，会释放空间；delete之后，不会释放空间，因为delete只是在行标记删除，后续可以复用；</p></li><li><p>delete因为是DML，会产生redo log；truncate是DDL则不会</p></li><li><p>truncate的效率更高</p></li><li><p>truncate之后，id从头开始；delete不会</p></li></ol><h3 id=12mysql-有哪些存储引擎>12.Mysql 有哪些存储引擎？</h3><p>回答：首先是InnoDB引擎，它提供了ACID事务的支持，并且还提供了行级锁和外键的约束。InnoDB的设计目的就是处理大数据容量的数据库系统</p><p>还有MyIASM引擎，它是原本Mysql的默认引擎，不提供事务支持，也不支持行级锁和外键</p><p>最后是一个MEMORY引擎，它的所有数据都是在内存中，数据的处理速度快，但是安全性不高，很少使用</p><h3 id=13acid是什么>13.ACID是什么？</h3><p>回答：它是原子性、一致性、隔离性、持久性的缩写</p><ol><li><p>原子性：操作要么成功还是全失败</p></li><li><p>一致性：数据执行前后保持一致</p></li><li><p>隔离性：事务之间隔离，互不影响</p></li><li><p>持久性：数据持久化，不会丢失</p></li></ol><h3 id=14主键和外键有什么区别>14.主键和外键有什么区别？</h3><p>回答：主键是表中的一个或者多个字段，它的值用于唯一的标识表中的某一条记录</p><p>外键是说某张表b的主键，在另外一张表a中被使用，那么a中该字段可以使用的范围取决于b。外键约束主要用来维护两张表之间数据的一致性</p><h3 id=15那么一张表一定有主键吗>15.那么一张表一定有主键吗？</h3><p>回答；是的，一定有。如果主动设置，则采用设置的，否则会自动生成一个默认的行</p><h3 id=16你怎么查看有多少个sql语句正在执行>16.你怎么查看有多少个SQL语句正在执行？</h3><p>回答：使用show processlist，它是显示用户正在运行的线程的命令。但是除非是root用户，或者进行了授权的用户，都只能看见自己正在运行的线程</p></section></main><footer id=main-footer><div class=footer><a href=#>回到顶部 ↑</a><div class=footer-copyright><div>© 2025 Chen-Hang</div><div>powered by <a href=https://github.com/math-queiroz/rusty-typewriter target=_blank>Rusty Typewriter</a> theme for <a href=https://gohugo.io/ target=_blank>Hugo</a></div></div></div></footer></div><aside id=side-pane class=side-sticky><div class=side-details><span>15218 字数</span>
<span>51 - 65 阅读时间</span></div><h3>目录</h3><nav id=TableOfContents><ul><li><a href=#0-sql语法>0. SQL语法</a><ul><li><a href=#01-count主键和count非主键结果会不同吗>0.1 count主键和count非主键结果会不同吗？</a></li></ul></li><li><a href=#一索引面试题>一、索引面试题</a><ul><li><a href=#11-mysql有哪些索引>1.1 MySQL有哪些索引？</a></li><li><a href=#12-innodb引擎的索引数据结构是什么>1.2 InnoDB引擎的索引数据结构是什么？</a></li><li><a href=#130-mysql为什么使用b树>1.3.0 mysql为什么使用B+树？</a></li><li><a href=#13-为什么索引用b树而不用红黑树>1.3 为什么索引用B+树？而不用红黑树？</a></li><li><a href=#14-为什么索引用b树而不是b树>1.4 为什么索引用B+树？而不是B树？</a></li><li><a href=#15-为什么索引用b树而不用哈希表>1.5 为什么索引用B+树？而不用哈希表？</a></li><li><a href=#16聚簇索引和非聚簇索引有什么区别>1.6聚簇索引和非聚簇索引有什么区别？</a></li><li><a href=#17insert操作对b树结构的改变是怎么样的>1.7insert操作对B+树结构的改变是怎么样的？</a></li><li><a href=#18假如一张表有两千万的数据b树的高度是多少怎么算>1.8假如一张表有两千万的数据，B+树的高度是多少？怎么算？</a></li><li><a href=#111-mysql有哪些索引>1.11 MySQL有哪些索引？</a></li><li><a href=#112-普通索引和唯一索引有什么区别哪个更新性能更好>1.12 普通索引和唯一索引有什么区别？哪个更新性能更好？</a></li><li><a href=#113-主键怎么设置假如你不会设置会怎样>1.13 主键怎么设置？假如你不会设置会怎样？</a></li><li><a href=#114-为什么要建立索引>1.14 为什么要建立索引？</a></li><li><a href=#115-我们一般选择什么样的字段来建立索引>1.15 我们一般选择什么样的字段来建立索引？</a></li><li><a href=#116-索引越多越好吗>1.16 索引越多越好吗？</a></li><li><a href=#117-什么时候不用索引更好>1.17 什么时候不用索引更好？</a></li><li><a href=#118-索引怎么优化>1.18 索引怎么优化？</a></li><li><a href=#119-建立了索引查询的时候一定会用到索引吗>1.19 建立了索引，查询的时候一定会用到索引吗？</a></li><li><a href=#120-定义了一个varchar类型的日期字段并且有一个数据是20230922-如果这个日期字段上有索引那如果我查询的where条件是where-time--20230922不加单引号还会命中索引吗为什么>1.20 定义了一个varchar类型的日期字段，并且有一个数据是'20230922&rsquo;, 如果这个日期字段上有索引，那如果我查询的where条件是where time = 20230922不加单引号，还会命中索引吗？为什么？</a></li><li><a href=#121-mysql最新版本解决了索引失效的哪些情况了吗>1.21 MySQL最新版本解决了索引失效的哪些情况了吗？</a></li><li><a href=#122-什么是最左匹配原则>1.22 什么是最左匹配原则？</a></li></ul></li><li><a href=#二事务面试题>二、事务面试题</a><ul><li><a href=#21-mysql事务有什么特性>2.1 MySQL事务有什么特性？</a></li><li><a href=#22-事务的隔离性如何保证>2.2 事务的隔离性如何保证？</a></li><li><a href=#23-事务的持久性如何保证>2.3 事务的持久性如何保证？</a></li><li><a href=#24-事务的原子性如何保证>2.4 事务的原子性如何保证？</a></li><li><a href=#25-mysql事务和redis事务有什么区别>2.5 MySQL事务和Redis事务有什么区别？</a></li><li><a href=#26-mysql事务隔离级别有哪些分别解决哪些问题>2.6 MySQL事务隔离级别有哪些？分别解决哪些问题？</a></li><li><a href=#27-脏读和幻读有什么区别>2.7 脏读和幻读有什么区别？</a></li><li><a href=#28-mysql默认的隔离级别是什么怎么实现>2.8 MySQL默认的隔离级别是什么？怎么实现？</a></li><li><a href=#29-介绍以下mvcc>2.9 介绍以下MVCC？</a></li><li><a href=#210-mvcc如何判断行记录对某个事务是否可见>2.10 MVCC如何判断行记录对某个事务是否可见？</a></li><li><a href=#211-读已提交和可重复读隔离级别实现-mvcc的区别>2.11 读已提交和可重复读隔离级别实现 MVCC的区别？</a></li><li><a href=#212-为什么互联网公司用读已提交隔离级别>2.12 为什么互联网公司用读已提交隔离级别？</a></li><li><a href=#213-可重复读级别是如何解决不可重复读的>2.13 可重复读级别是如何解决不可重复读的？</a></li><li><a href=#214-可重复读隔离级别是如何解决幻读的>2.14 可重复读隔离级别是如何解决幻读的？</a></li><li><a href=#215-可重复读隔离级别解决了什么问题有没有完全解决幻读>2.15 可重复读隔离级别解决了什么问题？有没有完全解决幻读？</a></li><li><a href=#216-可重复读为什么不能完全避免幻读什么情况下出现幻读>2.16 可重复读为什么不能完全避免幻读？什么情况下出现幻读？</a></li><li><a href=#217-可重复读隔离级别mvcc完全解决了不可重复读的问题吗>2.17 可重复读隔离级别，MVCC完全解决了不可重复读的问题吗？</a></li></ul></li><li><a href=#三锁面试题>三、锁面试题</a><ul><li><a href=#31-细说一下mysql数据库中锁的分类>3.1 细说一下MySQL数据库中锁的分类</a></li><li><a href=#32-在线上修改表结构会发生什么>3.2 在线上修改表结构，会发生什么？</a></li><li><a href=#33-innodb存储引擎中的行级锁有哪些>3.3 InnoDB存储引擎中的行级锁有哪些？</a></li><li><a href=#34-一条update语句没有带where条件加的是什么锁>3.4 一条Update语句没有带Where条件，加的是什么锁？</a></li><li><a href=#35-带了where条件没有命中索引加的是什么锁>3.5 带了Where条件没有命中索引，加的是什么锁？</a></li><li><a href=#36-两条更新语句更新同一条记录加的是什么锁>3.6 两条更新语句更新同一条记录，加的是什么锁？</a></li><li><a href=#37-两条更新语句更新同一个跳记录的不同字段加的是什么锁>3.7 两条更新语句更新同一个跳记录的不同字段，加的是什么锁？</a></li><li><a href=#38-mysql怎么实现乐观锁>3.8 MySQL怎么实现乐观锁？</a></li><li><a href=#39-了解过mysql怎么排查死锁问题>3.9 了解过MySQL怎么排查死锁问题？</a></li><li><a href=#310-mysql-怎么避免死锁>3.10 MySQL 怎么避免死锁？</a></li></ul></li><li><a href=#四日志面试题>四、日志面试题</a><ul><li><a href=#41-redo-log和-binlog-的区别和应用场景>4.1 redo log和 binlog 的区别和应用场景</a></li><li><a href=#42-redo-log和binlog在恢复数据库有什么区别>4.2 redo log和binlog在恢复数据库有什么区别？</a></li><li><a href=#43-redo-log是怎么实现持久化>4.3 redo log是怎么实现持久化？</a></li><li><a href=#44-redo-log除了崩溃恢复还有什么其它作用>4.4 redo log除了崩溃恢复还有什么其它作用</a></li><li><a href=#45-为什么需要两阶段提交>4.5 为什么需要两阶段提交</a></li><li><a href=#46-两阶段提交的过程>4.6 两阶段提交的过程？</a></li></ul></li><li><a href=#六存储引擎>六、存储引擎</a><ul><li><a href=#61-执行一条查询sql的全过程>6.1 执行一条查询sql的全过程</a></li><li><a href=#62-mysql存储引擎有哪些>6.2 mysql存储引擎有哪些？</a></li><li><a href=#63-myisam和innodb存储引擎有什么区别>6.3 MyISAM和InnoDB存储引擎有什么区别</a></li><li><a href=#64-用count哪个存储引擎会更快>6.4 用count(*)哪个存储引擎会更快？</a></li><li><a href=#65-null值是如何存储的>6.5 NULL值是如何存储的？</a></li><li><a href=#66-char和varchar有什么区别>6.6 char和varchar有什么区别？</a></li><li><a href=#67-假如说一个字段是varchar10但它其实只有6个字节那么他在内存中的存储空间是多少在文件中的存储空间是多少>6.7 假如说一个字段是varchar(10)，但它其实只有6个字节，那么他在内存中的存储空间是多少？在文件中的存储空间是多少？</a></li><li><a href=#68-如果硬件内存特别大mysql缓存能否替代redis>6.8 如果硬件内存特别大，mysql缓存能否替代redis？</a></li></ul></li><li><a href=#mysql基础篇>Mysql基础篇</a><ul><li><a href=#1mysql是什么>1.Mysql是什么？</a></li><li><a href=#2oltp和olap的区别>2.OLTP和OLAP的区别？</a></li><li><a href=#3数据库的三范式分别是什么>3.数据库的三范式分别是什么？</a></li><li><a href=#4dml是什么>4.DML是什么？</a></li><li><a href=#5ddl是什么>5.DDL是什么？</a></li><li><a href=#6dcl是什么>6.DCL是什么？</a></li><li><a href=#7varchar与char的区别是什么>7.varchar与char的区别是什么？</a></li><li><a href=#8既然varchar是变长那是不是设置varchar1000一定比varchar100好>8.既然varchar是变长，那是不是设置varchar(1000)一定比varchar(100)好？</a></li><li><a href=#9varchar是变长char是定长那能用varchar完全替代char么>9.varchar是变长，char是定长，那能用varchar完全替代char么？</a></li><li><a href=#10varchar11和int11中的11有什么区别>10.varchar(11)和int(11)中的11，有什么区别？</a></li><li><a href=#11delete和truncate的区别>11.delete和truncate的区别？</a></li><li><a href=#12mysql-有哪些存储引擎>12.Mysql 有哪些存储引擎？</a></li><li><a href=#13acid是什么>13.ACID是什么？</a></li><li><a href=#14主键和外键有什么区别>14.主键和外键有什么区别？</a></li><li><a href=#15那么一张表一定有主键吗>15.那么一张表一定有主键吗？</a></li><li><a href=#16你怎么查看有多少个sql语句正在执行>16.你怎么查看有多少个SQL语句正在执行？</a></li></ul></li></ul></nav></aside></div></div></body></html>