<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>| ch.hugo</title>
<link rel=icon href=favicon.svg sizes=any type=image/svg+xml><meta property="og:url" content="https://chhz0.github.io/interviews/network/tcp/"><meta property="og:site_name" content="ch.hugo"><meta property="og:title" content="ch.hugo"><meta property="og:description" content="TCP三次握手 TCP头部有哪些字段？ tcp报文段 ： tcp头部+tcp数据部分
tcp头部：
源端口：16位 目的端口：16位 序号：32位 确认号：32位 数据偏移：4位 保留：6位 窗口：16位 校验和：16位 紧急指针：16位 选项和填充：最多为40字节 控制位： URG：紧急指针标志，为1时标识紧急指针有效，该报文应该优先传送，为0则忽略紧急指针 ACK：确认序号标志，为1时表示确认号有效。携带ACK标识的TCP报文段被称为确认报文段 RST：重置连接 SYN：表示请求建立一个连接 FIN：用于释放连接 PSH：为1表示带有push标志的数据，优先将这个报文提交给应用程序，而不是缓冲区排队 tcp头部的最长是60字节
数据部分：。。。
回答：tcp头部主要是源端口、目的端口、序列号、确认号、标记位：SYN、RST、ACK、FIN、头部长度、窗口大小，可扩展的选项等
其中序列号和确认号的大小为32位，序列号保证数据的有序性，接收方按照发送方顺序发来的数据来组装有序的数据；确认号保证数据的可靠性，当发送方已发送的数据，超过一段时间没收到确认报文，就会重传报文。
源端口和目的端口的大小是16位，源端口是发送方的端口号，目的端口是接收方使用的端口号，端口的作用是标识TCP连接是哪个进程
TCP之报文首部格式 - Jummyer - 博客园
TCP三次握手连接过程 客户端和服务端一开始都处于close状态，服务端会监听一个端口，处于listen状态
第一次握手：客户端产生随机初始化序号，放到tcp报文头部的序号字段，同时把SYN标志设置位1，标识SYN报文。接着把SYN报文发送给服务端，之后客户端处于SYN_SEND状态
服务端收到SYN报文后，服务端也生成随机初始化序号，放到TCP报文头部的序号字段中，对客户端的初始化序号+1作为确认号，放到TCP报文头部的确认应答字段中，并将SYN和ACK标志设置为1，表示SYN-ACK报文，把报文发送给客户端，之后服务端处于SYN_RECD状态
客户端收到服务端SYN-ACK报文后，客户端发送一个ACK确认报文，该报文的确认号为服务端的初始化序号+1，并将ACK标志设置为1。客户端处于ESTABLISHED状态
服务端收到ACK确认报文，服务端也处于ESTABLISHED状态
以上就是TCP三次握手的过程
4.1 TCP 三次握手与四次挥手面试题
为什么需要三次握手？两次握手不行吗？ 避免历史连接的建立，避免资源浪费
三次握手可以确认客户端和服务端是否同时具备发送和接收的能力
如果第二次握手丢包，会发送什么？ 超时重传机制，第二次SYN-ACK报文中有
第二次报文中的ACK，是第一次握手的确认报文，那么当第二次报文丢包时，会导致客户端一直没有接收到ACK而触发超时重传机制，重传SYN包，即第一次握手
第二次报文中的SYN，是服务端建立TCP连接的报文，当第二次报文丢失后，客户端没有发送ACK报文，服务端没有收到第三次握手，于是服务端会触发超时重传机制，重传SYN-ACK报文
如果第三次握手丢包，会发生什么？ 我的理解是第三次握手如果发生丢包，服务端会迟迟接收不到第三次握手的ACK包，触发超时重传机制，服务端会重新发生第二次握手的SYN-ACK包，直到最大重传次数的限制，或者收到第三次握手
TCP的半连接队列和全连接队列？ 在tcp三次握手的时候，linux内核会维护两个队列，分别是：
syn队列：半连接队列
accept队列：全连接队列
服务端收到客户端发起的SYN请求后，内核会将为握手完成的连接存储到半连接队列，等待完成三次握手后转移到全连接队列
全连接队列：服务端收到客户端的第三次握手，内核会将连接从半连接队列移除，然后创建新的完全连接，并将其添加到全连接队列，等待进程调用accept函数将连接取出
4.4 TCP 半连接队列和全连接队列
TCP四次挥手 TCP四次挥手的过程 tcp的四次挥手（断开连接）是可以客户端或者服务端断开
客户端关闭连接，此时会发生一个fin报文，之后客户端进入fin_wait_1状态，
服务端收到fin报文后，将向客户端发送ack报文，接着服务端进入close_wait状态
客户端接收到ack应答报文后，之后进入fin_wait_2状态
等待服务端处理完数据后，向客户端发送fin报文，服务端进入last_ack状态
客户端收到服务端的fin报文后，回一个ack应答报文，客户端进入time_wait状态"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="interviews"><meta name=twitter:card content="summary"><meta name=twitter:title content="ch.hugo"><meta name=twitter:description content="TCP三次握手 TCP头部有哪些字段？ tcp报文段 ： tcp头部+tcp数据部分
tcp头部：
源端口：16位 目的端口：16位 序号：32位 确认号：32位 数据偏移：4位 保留：6位 窗口：16位 校验和：16位 紧急指针：16位 选项和填充：最多为40字节 控制位： URG：紧急指针标志，为1时标识紧急指针有效，该报文应该优先传送，为0则忽略紧急指针 ACK：确认序号标志，为1时表示确认号有效。携带ACK标识的TCP报文段被称为确认报文段 RST：重置连接 SYN：表示请求建立一个连接 FIN：用于释放连接 PSH：为1表示带有push标志的数据，优先将这个报文提交给应用程序，而不是缓冲区排队 tcp头部的最长是60字节
数据部分：。。。
回答：tcp头部主要是源端口、目的端口、序列号、确认号、标记位：SYN、RST、ACK、FIN、头部长度、窗口大小，可扩展的选项等
其中序列号和确认号的大小为32位，序列号保证数据的有序性，接收方按照发送方顺序发来的数据来组装有序的数据；确认号保证数据的可靠性，当发送方已发送的数据，超过一段时间没收到确认报文，就会重传报文。
源端口和目的端口的大小是16位，源端口是发送方的端口号，目的端口是接收方使用的端口号，端口的作用是标识TCP连接是哪个进程
TCP之报文首部格式 - Jummyer - 博客园
TCP三次握手连接过程 客户端和服务端一开始都处于close状态，服务端会监听一个端口，处于listen状态
第一次握手：客户端产生随机初始化序号，放到tcp报文头部的序号字段，同时把SYN标志设置位1，标识SYN报文。接着把SYN报文发送给服务端，之后客户端处于SYN_SEND状态
服务端收到SYN报文后，服务端也生成随机初始化序号，放到TCP报文头部的序号字段中，对客户端的初始化序号+1作为确认号，放到TCP报文头部的确认应答字段中，并将SYN和ACK标志设置为1，表示SYN-ACK报文，把报文发送给客户端，之后服务端处于SYN_RECD状态
客户端收到服务端SYN-ACK报文后，客户端发送一个ACK确认报文，该报文的确认号为服务端的初始化序号+1，并将ACK标志设置为1。客户端处于ESTABLISHED状态
服务端收到ACK确认报文，服务端也处于ESTABLISHED状态
以上就是TCP三次握手的过程
4.1 TCP 三次握手与四次挥手面试题
为什么需要三次握手？两次握手不行吗？ 避免历史连接的建立，避免资源浪费
三次握手可以确认客户端和服务端是否同时具备发送和接收的能力
如果第二次握手丢包，会发送什么？ 超时重传机制，第二次SYN-ACK报文中有
第二次报文中的ACK，是第一次握手的确认报文，那么当第二次报文丢包时，会导致客户端一直没有接收到ACK而触发超时重传机制，重传SYN包，即第一次握手
第二次报文中的SYN，是服务端建立TCP连接的报文，当第二次报文丢失后，客户端没有发送ACK报文，服务端没有收到第三次握手，于是服务端会触发超时重传机制，重传SYN-ACK报文
如果第三次握手丢包，会发生什么？ 我的理解是第三次握手如果发生丢包，服务端会迟迟接收不到第三次握手的ACK包，触发超时重传机制，服务端会重新发生第二次握手的SYN-ACK包，直到最大重传次数的限制，或者收到第三次握手
TCP的半连接队列和全连接队列？ 在tcp三次握手的时候，linux内核会维护两个队列，分别是：
syn队列：半连接队列
accept队列：全连接队列
服务端收到客户端发起的SYN请求后，内核会将为握手完成的连接存储到半连接队列，等待完成三次握手后转移到全连接队列
全连接队列：服务端收到客户端的第三次握手，内核会将连接从半连接队列移除，然后创建新的完全连接，并将其添加到全连接队列，等待进程调用accept函数将连接取出
4.4 TCP 半连接队列和全连接队列
TCP四次挥手 TCP四次挥手的过程 tcp的四次挥手（断开连接）是可以客户端或者服务端断开
客户端关闭连接，此时会发生一个fin报文，之后客户端进入fin_wait_1状态，
服务端收到fin报文后，将向客户端发送ack报文，接着服务端进入close_wait状态
客户端接收到ack应答报文后，之后进入fin_wait_2状态
等待服务端处理完数据后，向客户端发送fin报文，服务端进入last_ack状态
客户端收到服务端的fin报文后，回一个ack应答报文，客户端进入time_wait状态"><link rel=stylesheet href=/css/components.min.9d886688d3ae94cecf1b057e706bf74497fcd5cea352d433c34cda3b9425a8d4.css integrity="sha256-nYhmiNOulM7PGwV+cGv3RJf81c6jUtQzw0zaO5QlqNQ=" crossorigin=anonymous><link rel=stylesheet href=/css/main.min.17813e97a146cc70fc6064666a89082f1ef2f6213c7d3fade88402a86cf8aa3c.css integrity="sha256-F4E+l6FGzHD8YGRmaokILx7y9iE8fT+t6IQCqGz4qjw=" crossorigin=anonymous><link rel=stylesheet href=/css/root.min.1677bc99f2421f7cb9fc1d00b09addcc951fd9d4c785e22b20ed55c0602786fc.css integrity="sha256-Fne8mfJCH3y5/B0AsJrdzJUf2dTHheIrIO1VwGAnhvw=" crossorigin=anonymous><link rel=stylesheet href=/css/search.min.cb1ed1dad3ee872e229e9f1fc681bdbd20d923389f1fa6aaf89f9aee93af4fbf.css integrity="sha256-yx7R2tPuhy4inp8fxoG9vSDZIzifH6aq+J+a7pOvT78=" crossorigin=anonymous><link rel=stylesheet href=/css/bundle.min.4878d16c866148ae8cfd6f4f44052d25f2548b24ab4a9bc857279dc6d06df2b5.css integrity="sha256-SHjRbIZhSK6M/W9PRAUtJfJUiySrSpvIVyedxtBt8rU=" crossorigin=anonymous><script src=/js/bundle.995e4ec99401021e081ec256bee66154ef7f4e5136809432513b2e6d014b4b1d.js integrity="sha256-mV5OyZQBAh4IHsJWvuZhVO9/TlE2gJQyUTsubQFLSx0=" crossorigin=anonymous></script><script defer src=/js/search/flexsearch.compact.64594b125f7b78bdf4fa8316955922bbebb1cd6baef3f16654bfca20309f18f8.js integrity="sha256-ZFlLEl97eL30+oMWlVkiu+uxzWuu8/FmVL/KIDCfGPg="></script><script defer src=/js/search/search.1d980f84df11f3eb7c8c5f17f541d49a0611608df179dd74fa7f06225eb56ace.js integrity="sha256-HZgPhN8R8+t8jF8X9UHUmgYRYI3xed10+n8GIl61as4="></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:opsz,wght@12..96,200..800&family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel=stylesheet></head><body class=notransition><div id=container><header id=main-header><div role=navigation aria-label=Main><div class=nav-left><a href=https://chhz0.github.io/ style=color:inherit>ch.hugo</a></div><div class=nav-right><div style=position:absolute;width:0;height:0><div id=nav-dropdown-menu class=hidden href=#><div class=nav-item><a href=/blogs/>博客</a></div><div class=nav-item><a href=/notes/>笔记</a></div><div class=nav-item><a href=/about/>关于</a></div></div></div><a id=nav-dropdown-button href=#><svg width="20" height="20" viewBox="0 0 24 24" fill="none"><path d="M4 6H20M4 12H20M4 18H20" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></a><div id=nav-menu><div class=nav-item><a href=/blogs/>博客</a></div><div class=nav-item><a href=/notes/>笔记</a></div><div class=nav-item><a href=/about/>关于</a></div></div><a id=theme-switcher href=#><svg class="light-icon" viewBox="0 0 24 24" fill="none"><path d="M12 3V4m0 16v1M4 12H3M6.31412 6.31412 5.5 5.5m12.1859.81412L18.5 5.5M6.31412 17.69 5.5 18.5001M17.6859 17.69 18.5 18.5001M21 12H20m-4 0c0 2.2091-1.7909 4-4 4-2.20914.0-4-1.7909-4-4 0-2.20914 1.79086-4 4-4 2.2091.0 4 1.79086 4 4z" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
<svg class="dark-icon" viewBox="0 0 24 24" fill="none"><path d="M3.32031 11.6835c0 4.9706 4.02944 9 8.99999 9 3.7872.0 7.028-2.3392 8.3565-5.6515C19.6402 15.4486 18.5059 15.6834 17.3203 15.6834c-4.9706.0-8.99999-4.0294-8.99999-8.99998C8.32031 5.50338 8.55165 4.36259 8.96453 3.32996 5.65605 4.66028 3.32031 7.89912 3.32031 11.6835z" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
</a>|
<a id=theme-switcher href=https://github.com/chhz0 aria-label=GitHub><svg class="light-icon" width="800" height="800" viewBox="0 0 20 20" xmlns:xlink="http://www.w3.org/1999/xlink"><title>github [#142]</title><desc>Created with Sketch.</desc><defs/><g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="Dribbble-Light-Preview" transform="translate(-140.000000, -7559.000000)" fill="#fff"><g id="icons" transform="translate(56.000000, 160.000000)"><path d="M94 7399C99.523 7399 104 7403.59 104 7409.253 104 7413.782 101.138 7417.624 97.167 7418.981 96.66 7419.082 96.48 7418.762 96.48 7418.489 96.48 7418.151 96.492 7417.047 96.492 7415.675 96.492 7414.719 96.172 7414.095 95.813 7413.777 98.04 7413.523 100.38 7412.656 100.38 7408.718 100.38 7407.598 99.992 7406.684 99.35 7405.966 99.454 7405.707 99.797 7404.664 99.252 7403.252 99.252 7403.252 98.414 7402.977 96.505 7404.303 95.706 7404.076 94.85 7403.962 94 7403.958 93.15 7403.962 92.295 7404.076 91.497 7404.303 89.586 7402.977 88.746 7403.252 88.746 7403.252 88.203 7404.664 88.546 7405.707 88.649 7405.966 88.01 7406.684 87.619 7407.598 87.619 7408.718 87.619 7412.646 89.954 7413.526 92.175 7413.785 91.889 7414.041 91.63 7414.493 91.54 7415.156 90.97 7415.418 89.522 7415.871 88.63 7414.304 88.63 7414.304 88.101 7413.319 87.097 7413.247 87.097 7413.247 86.122 7413.234 87.029 7413.87 87.029 7413.87 87.684 7414.185 88.139 7415.37 88.139 7415.37 88.726 7417.2 91.508 7416.58 91.513 7417.437 91.522 7418.245 91.522 7418.489 91.522 7418.76 91.338 7419.077 90.839 7418.982 86.865 7417.627 84 7413.783 84 7409.253 84 7403.59 88.478 7399 94 7399" id="github-[#142]"/></g></g></g></svg><svg class="dark-icon" width="800" height="800" viewBox="0 0 20 20" xmlns:xlink="http://www.w3.org/1999/xlink"><title>github [#142]</title><desc>Created with Sketch.</desc><defs/><g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="Dribbble-Light-Preview" transform="translate(-140.000000, -7559.000000)" fill="#000"><g id="icons" transform="translate(56.000000, 160.000000)"><path d="M94 7399C99.523 7399 104 7403.59 104 7409.253 104 7413.782 101.138 7417.624 97.167 7418.981 96.66 7419.082 96.48 7418.762 96.48 7418.489 96.48 7418.151 96.492 7417.047 96.492 7415.675 96.492 7414.719 96.172 7414.095 95.813 7413.777 98.04 7413.523 100.38 7412.656 100.38 7408.718 100.38 7407.598 99.992 7406.684 99.35 7405.966 99.454 7405.707 99.797 7404.664 99.252 7403.252 99.252 7403.252 98.414 7402.977 96.505 7404.303 95.706 7404.076 94.85 7403.962 94 7403.958 93.15 7403.962 92.295 7404.076 91.497 7404.303 89.586 7402.977 88.746 7403.252 88.746 7403.252 88.203 7404.664 88.546 7405.707 88.649 7405.966 88.01 7406.684 87.619 7407.598 87.619 7408.718 87.619 7412.646 89.954 7413.526 92.175 7413.785 91.889 7414.041 91.63 7414.493 91.54 7415.156 90.97 7415.418 89.522 7415.871 88.63 7414.304 88.63 7414.304 88.101 7413.319 87.097 7413.247 87.097 7413.247 86.122 7413.234 87.029 7413.87 87.029 7413.87 87.684 7414.185 88.139 7415.37 88.139 7415.37 88.726 7417.2 91.508 7416.58 91.513 7417.437 91.522 7418.245 91.522 7418.489 91.522 7418.76 91.338 7419.077 90.839 7418.982 86.865 7417.627 84 7413.783 84 7409.253 84 7403.59 88.478 7399 94 7399" id="github-[#142]"/></g></g></g></svg></a></div></div></header><div class="flex grow"><div id=main-pane><main id=main-content><div class=single-header><ol class=breadcrumbs itemscope itemtype=https://schema.org/BreadcrumbList><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://chhz0.github.io/><span itemprop=name>Home</span>
</a><meta itemprop=position content='1'></li><span>&nbsp»&nbsp</span><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://chhz0.github.io/interviews/><span itemprop=name>Interviews</span>
</a><meta itemprop=position content='2'></li><span>&nbsp»&nbsp</span></ol><h1>Network</h1><time class=dim datetime=0001-01-01T00:00:00+00:00>January 1, 1</time></div><section class=page-section><h2 id=tcp三次握手>TCP三次握手</h2><h3 id=tcp头部有哪些字段>TCP头部有哪些字段？</h3><p>tcp报文段 ： tcp头部+tcp数据部分</p><ul><li><p>tcp头部：</p><ul><li>源端口：16位</li><li>目的端口：16位</li><li>序号：32位</li><li>确认号：32位</li><li>数据偏移：4位</li><li>保留：6位</li><li>窗口：16位</li><li>校验和：16位</li><li>紧急指针：16位</li><li>选项和填充：最多为40字节</li><li>控制位：<ul><li>URG：紧急指针标志，为1时标识紧急指针有效，该报文应该优先传送，为0则忽略紧急指针</li><li>ACK：确认序号标志，为1时表示确认号有效。携带ACK标识的TCP报文段被称为确认报文段</li><li>RST：重置连接</li><li>SYN：表示请求建立一个连接</li><li>FIN：用于释放连接</li><li>PSH：为1表示带有push标志的数据，优先将这个报文提交给应用程序，而不是缓冲区排队</li></ul><blockquote><p>tcp头部的最长是60字节</p></blockquote></li></ul></li><li><p>数据部分：。。。</p></li></ul><p>回答：tcp头部主要是源端口、目的端口、序列号、确认号、标记位：SYN、RST、ACK、FIN、头部长度、窗口大小，可扩展的选项等</p><p>其中序列号和确认号的大小为32位，序列号保证数据的有序性，接收方按照发送方顺序发来的数据来组装有序的数据；确认号保证数据的可靠性，当发送方已发送的数据，超过一段时间没收到确认报文，就会重传报文。</p><p>源端口和目的端口的大小是16位，源端口是发送方的端口号，目的端口是接收方使用的端口号，端口的作用是标识TCP连接是哪个进程</p><p><a href=https://www.cnblogs.com/Jummyer/p/11026966.html>TCP之报文首部格式 - Jummyer - 博客园</a></p><h3 id=tcp三次握手连接过程>TCP三次握手连接过程</h3><ul><li><p>客户端和服务端一开始都处于close状态，服务端会监听一个端口，处于listen状态</p></li><li><p>第一次握手：客户端产生随机初始化序号，放到tcp报文头部的序号字段，同时把SYN标志设置位1，标识SYN报文。接着把SYN报文发送给服务端，之后客户端处于SYN_SEND状态</p></li><li><p>服务端收到SYN报文后，服务端也生成随机初始化序号，放到TCP报文头部的序号字段中，对客户端的初始化序号+1作为确认号，放到TCP报文头部的确认应答字段中，并将SYN和ACK标志设置为1，表示SYN-ACK报文，把报文发送给客户端，之后服务端处于SYN_RECD状态</p></li><li><p>客户端收到服务端SYN-ACK报文后，客户端发送一个ACK确认报文，该报文的确认号为服务端的初始化序号+1，并将ACK标志设置为1。客户端处于ESTABLISHED状态</p></li><li><p>服务端收到ACK确认报文，服务端也处于ESTABLISHED状态</p></li></ul><p>以上就是TCP三次握手的过程</p><p><a href=https://xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-%E5%A4%B4%E6%A0%BC%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B>4.1 TCP 三次握手与四次挥手面试题</a></p><h3 id=为什么需要三次握手两次握手不行吗>为什么需要三次握手？两次握手不行吗？</h3><ul><li><p>避免历史连接的建立，避免资源浪费</p></li><li><p>三次握手可以确认客户端和服务端是否同时具备发送和接收的能力</p></li></ul><h3 id=如果第二次握手丢包会发送什么>如果第二次握手丢包，会发送什么？</h3><p>超时重传机制，第二次SYN-ACK报文中有</p><p>第二次报文中的ACK，是第一次握手的确认报文，那么当第二次报文丢包时，会导致客户端一直没有接收到ACK而触发超时重传机制，重传SYN包，即第一次握手</p><p>第二次报文中的SYN，是服务端建立TCP连接的报文，当第二次报文丢失后，客户端没有发送ACK报文，服务端没有收到第三次握手，于是服务端会触发超时重传机制，重传SYN-ACK报文</p><h3 id=如果第三次握手丢包会发生什么>如果第三次握手丢包，会发生什么？</h3><p>我的理解是第三次握手如果发生丢包，服务端会迟迟接收不到第三次握手的ACK包，触发超时重传机制，服务端会重新发生第二次握手的SYN-ACK包，直到最大重传次数的限制，或者收到第三次握手</p><h3 id=tcp的半连接队列和全连接队列>TCP的半连接队列和全连接队列？</h3><p>在tcp三次握手的时候，linux内核会维护两个队列，分别是：</p><ul><li><p>syn队列：半连接队列</p></li><li><p>accept队列：全连接队列</p></li></ul><p>服务端收到客户端发起的SYN请求后，内核会将为握手完成的连接存储到半连接队列，等待完成三次握手后转移到全连接队列</p><p>全连接队列：服务端收到客户端的第三次握手，内核会将连接从半连接队列移除，然后创建新的完全连接，并将其添加到全连接队列，等待进程调用accept函数将连接取出</p><p><a href=https://xiaolincoding.com/network/3_tcp/tcp_queue.html>4.4 TCP 半连接队列和全连接队列</a></p><h2 id=tcp四次挥手>TCP四次挥手</h2><h3 id=tcp四次挥手的过程>TCP四次挥手的过程</h3><p>tcp的四次挥手（断开连接）是可以客户端或者服务端断开</p><p>客户端关闭连接，此时会发生一个fin报文，之后客户端进入fin_wait_1状态，</p><p>服务端收到fin报文后，将向客户端发送ack报文，接着服务端进入close_wait状态</p><p>客户端接收到ack应答报文后，之后进入fin_wait_2状态</p><p>等待服务端处理完数据后，向客户端发送fin报文，服务端进入last_ack状态</p><p>客户端收到服务端的fin报文后，回一个ack应答报文，客户端进入time_wait状态</p><p>服务端接收到ack报文后，进入close状态，至此服务端完成连接的关闭</p><p>客户端在time_wait状态经过2MSL一段时间后，自动进入close状态，至此客户端也完成连接的关闭</p><h3 id=为什么tcp需要四次挥手>为什么TCP需要四次挥手？</h3><p>TCP是全双工协议，双方都具有发送和接收的能力，那么断开连接的期间，要确保双方能发送完自己的数据</p><p>当客户端想要断开连接，发送fin报文给服务端，服务端接收到fin包后返回一个ack报文，但是此时还不会立即断开连接，因为服务端可能还有数据需要发送，需要等待数据发送完成后，由服务端主动发送fin报文给客户端，表示数据发送完成了可以断开连接。所以第二次和第三次挥手通常不会合并一起发送，而是分开发送，所以需要四次挥手</p><p>如果只有三次挥手，那么就可能出现一方还要数据没有发送完就被迫关闭连接，这就会导致数据的丢失</p><h3 id=time_wait是如何产生的>TIME_WAIT是如何产生的？</h3><p>当TCP连接的主动关闭方关闭连接时，与被动方进行了四次挥手的时候，在主动关闭方发送完第四次挥手后，也就是最后一个ack报文，主动关闭方的TCP连接回会进入time_wait状态，这个状态会维持2MSL的时间，以确保对方接收到最后一个ACK报文</p><h3 id=time_wait过多有什么危害>TIME_WAIT过多有什么危害？</h3><ul><li><p>占用系统资源，比如内存资源，线程资源等（服务端TIME_WAIT过多）</p></li><li><p>占用端口资源，端口资源是有限的（客户端TIME_WAIT过多）</p></li></ul><h2 id=tdp和udp>TDP和UDP</h2><h2 id=tcp和udp有什么区别>TCP和UDP有什么区别？</h2><p>连接、可靠性、传输方式</p><ul><li><p>TCP是面向连接的协议，在发送数据的时候需要进行三次握手；而UDP是无连接的协议，可以直接发送数据</p></li><li><p>TCP会通过超时重传、流量控制、拥塞控制保证数据的可靠性；而UDP不考虑数据的可靠性</p></li><li><p>TCP发送的数据是以字节流的形式，没有边界；而UDP是一个包一个包的发送，是有边界的</p></li></ul><p><a href=https://www.freecodecamp.org/chinese/news/tcp-vs-udp-which-is-faster/>TCP vs UDP——哪个协议更快？</a></p><h3 id=什么时候用tcp什么使用用udp>什么时候用TCP？什么使用用UDP？</h3><ul><li><p>如果关注数据的可靠性和有序性，可以选择TCP，比如FTP协议，HTTP协议都是基于TCP协议进行传输数据</p></li><li><p>如果需要数据快速传输和实时性，不在意某些数据包的丢失，可以考虑UDP，例如视频会议、直播等场景</p></li></ul><p><a href=https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%87%8D%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%8C/34%20%20UDP%20%E5%8D%8F%E8%AE%AE%EF%BC%9AUDP%20%E5%92%8C%20TCP%20%E7%9B%B8%E6%AF%94%E5%BF%AB%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F.md>learn.lianglianglee.com</a></p><h3 id=视频会议用的是udp还是tcp如果使用tcp发送丢包会怎么样>视频会议用的是UDP还是TCP？如果使用TCP发送丢包会怎么样？</h3><p>视频会议使用的是UDP，因为视频会议的实时性很重要；UDP协议的实时性比TCP协议更好，采用UDP协议传输音视频的话，如果发生了丢包，只会出现一瞬间的卡顿，丢失该时刻的视频和音频，还可以继续进行沟通；如果采用TCP协议，由于TCP的可靠传输，如果发生丢包，可能画面会卡住不动，等待丢包重传才会推进画面，这样实时性就比较差了</p><h3 id=udp怎么改造为可靠运输>UDP怎么改造为可靠运输？</h3><p>在应用层实现，添加序列号字段和确认号字段，实现超时重传机制；</p><p>开辟缓冲区，实现滑动窗口，不仅可以实现流量控制还可以控制拥塞</p><p><img src="https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=M2ZkZTE5MDA0ZmJkOGU1ZWRmNjlkZTM4MjI5YTMwMTdfQnlseFJVMm1CRzhGVU1hMG9VRmRNOGI2VGJJRGhGTExfVG9rZW46VEZFZGIwbTBwbzlpMTB4SVh3RmNOY1ljbnplXzE3MjE4NDA0NTk6MTcyMTg0NDA1OV9WNA" alt></p><h3 id=udp和tcp可以共用一个端口吗>UDP和TCP可以共用一个端口吗？</h3><p>可以，socket是根据五元组信息唯一确认的：协议类型、源ip地址、源端口、目标ip地址、目标端口，只要有一个信息不同，就认为是不同的socket，不会引起冲突，所以TCP和UDP可以使用一个端口号</p><h2 id=tcp可靠性>TCP可靠性</h2><p><a href=https://xiaolincoding.com/network/3_tcp/tcp_feature.html>4.2 TCP 重传、滑动窗口、流量控制、拥塞控制</a></p><h3 id=tcp的可靠性如何保证>TCP的可靠性如何保证？</h3><ul><li><p>建立连接：三次握手，确保双方都有接收和发生数据的能力，避免历史数据的建立</p></li><li><p>超时重传机制：如果发生方迟迟没有接收到回文，就会触发超时重传机制，重新发送报文</p></li><li><p>滑动窗口机制：tcp有流量控制机制，可以根据接收方的滑动窗口大小来发送报文，避免报文发送的数据太大，导致接收方接收不了数据导致丢包</p></li><li><p>拥塞控制：tcp有拥塞控制机制，通过慢启动、拥塞避免、拥塞发送等算法调整发送速率避免网络拥塞。当网络出现拥塞时，TCP会降低发送速率，减少网络负载，保证数据的可靠传输</p></li></ul><h3 id=tcp流量控制和拥塞控制有什么区别>TCP流量控制和拥塞控制有什么区别？</h3><ul><li><p>流量控制是端到端，保护接收方不被数据淹没</p></li><li><p>拥塞控制是网络层面的控制，保护网络不被过载</p></li></ul><p><img src="https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=NzMxZDJjOGJhYjdkNTUzOThlNTM1OWQ4ODc0ODA3MTlfeXRoR2JwdXRReXp5UkVHd28xcDdlQ3A4Tnl6NGVsUkZfVG9rZW46RVpGeWJ2dUxYb3hKeXd4UVBTV2NKTlJDblBoXzE3MjE4NDA0NTk6MTcyMTg0NDA1OV9WNA" alt></p><h3 id=滑动窗口是怎么实现的解决什么问题>滑动窗口是怎么实现的？解决什么问题？</h3><p>滑动窗口在发送方和接收方都有一个缓冲区，在发送方表示可发送的最大数据量，在接收方表示可接收的最大数据量</p><ul><li><p>发送方有了滑动窗口后，那么发送方可以不用等待接收方的确认报文，就可以继续发送下一批数据，提高传输效率</p></li><li><p>接收方有了滑动窗口后，可以实现流量控制，让发送方按照自己的接收情况来发送数据，避免对方发送数据太快，导致接收方处理不过来</p></li></ul></section></main><footer id=main-footer><div class=footer><a href=#>回到顶部 ↑</a><div class=footer-copyright><div>© 2025 Chen-Hang</div><div>powered by <a href=https://github.com/math-queiroz/rusty-typewriter target=_blank>Rusty Typewriter</a> theme for <a href=https://gohugo.io/ target=_blank>Hugo</a></div></div></div></footer></div><aside id=side-pane class=side-sticky><div class=side-details><span>2810 字数</span>
<span>10 - 12 阅读时间</span></div><h3>目录</h3><nav id=TableOfContents><ul><li><a href=#tcp三次握手>TCP三次握手</a><ul><li><a href=#tcp头部有哪些字段>TCP头部有哪些字段？</a></li><li><a href=#tcp三次握手连接过程>TCP三次握手连接过程</a></li><li><a href=#为什么需要三次握手两次握手不行吗>为什么需要三次握手？两次握手不行吗？</a></li><li><a href=#如果第二次握手丢包会发送什么>如果第二次握手丢包，会发送什么？</a></li><li><a href=#如果第三次握手丢包会发生什么>如果第三次握手丢包，会发生什么？</a></li><li><a href=#tcp的半连接队列和全连接队列>TCP的半连接队列和全连接队列？</a></li></ul></li><li><a href=#tcp四次挥手>TCP四次挥手</a><ul><li><a href=#tcp四次挥手的过程>TCP四次挥手的过程</a></li><li><a href=#为什么tcp需要四次挥手>为什么TCP需要四次挥手？</a></li><li><a href=#time_wait是如何产生的>TIME_WAIT是如何产生的？</a></li><li><a href=#time_wait过多有什么危害>TIME_WAIT过多有什么危害？</a></li></ul></li><li><a href=#tdp和udp>TDP和UDP</a></li><li><a href=#tcp和udp有什么区别>TCP和UDP有什么区别？</a><ul><li><a href=#什么时候用tcp什么使用用udp>什么时候用TCP？什么使用用UDP？</a></li><li><a href=#视频会议用的是udp还是tcp如果使用tcp发送丢包会怎么样>视频会议用的是UDP还是TCP？如果使用TCP发送丢包会怎么样？</a></li><li><a href=#udp怎么改造为可靠运输>UDP怎么改造为可靠运输？</a></li><li><a href=#udp和tcp可以共用一个端口吗>UDP和TCP可以共用一个端口吗？</a></li></ul></li><li><a href=#tcp可靠性>TCP可靠性</a><ul><li><a href=#tcp的可靠性如何保证>TCP的可靠性如何保证？</a></li><li><a href=#tcp流量控制和拥塞控制有什么区别>TCP流量控制和拥塞控制有什么区别？</a></li><li><a href=#滑动窗口是怎么实现的解决什么问题>滑动窗口是怎么实现的？解决什么问题？</a></li></ul></li></ul></nav></aside></div></div></body></html>