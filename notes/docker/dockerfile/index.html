<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Dockerfile(bate) | ch.hugo</title>
<link rel=icon href=favicon.svg sizes=any type=image/svg+xml><meta property="og:url" content="https://chhz0.github.io/notes/docker/dockerfile/"><meta property="og:site_name" content="ch.hugo"><meta property="og:title" content="Dockerfile(bate)"><meta property="og:description" content="Dockerfile 构建你自己的容器
学习自
一篇文章带你吃透 Dockerfile - 掘金 (juejin.cn) Dockerfile reference 全网最详细的Docker-Compose详细教程 - 掘金 (juejin.cn) docker compose 配置文件 .yml 全面指南 - 知乎 (zhihu.com) compose-spec/spec.md at master · compose-spec/compose-spec · GitHub 学习Dockers前期，通过Docker的官方镜像仓库拉取里面的镜像，根据这些镜像创建出容器并运行
实际上，Docker官方镜像也是通过一定的方式构建出来的，只要弄清其中的逻辑，我们也可以仿照官方镜像的构建过程，构建出自己的镜像
Dockerfile就是这样一个用于描述Docker镜像构建过程的文本文件，dockerfile可以包含多条构建指令，以及相关的描述
1.什么是容器 容器是计算机上的沙盒进程，与主机上的其它进程隔离，这种隔离利用了内核命名空间和cgroups。简而言之容器是：
是image的可运行实例
可以在本地计算机、虚拟机上运行或部署到云中
是可移植的
与其它容器隔离，并运行自己的软件，二进制文件和配置
2.什么是容器映射 当容器运行时，它使用了隔离的文件系统。这个自定义的文件系统由容器映像container image提供。因为image包含了容器的问价系统，使用image必须包含所有的运行应用程序所必须的所有东西——依赖项、配置、脚本、二进制文件等等。
沙盒进程是指在计算机系统中，为了保障安全和隔离性而采用的一种技术，将应用程序运行在一个受限制的环境中，限制它们能访问的资源和操作范围，从而避免恶意程序和授权程序对系统的破坏
3.容器是怎么运行的 当一个容器运行时，它为其文件系统使用来image的各个层。每个容器都有自己的命名空间来创建/更新/删除文件。在另一个容器中不会看到任何更改，即使它们使用相同的image
4.容器卷[container volumes] 每个容器启动时都是从容器的定义开始的。在容器中可以创建、更新和删除文件，但当容器被删除时，这些改变将回丢失，所有更变都被隔离在各个容器中
卷：提供了将容器的特定文件系统路径链路到主机的能力。如果在主机上的某个文件被挂载，那么当容器中该文件路径下的文件发送更改时，我们在主机上同样也可以看到更改。同样的，启动另一个挂载了同一个文件目录的容器，它也可以访问到相同的文件
镜像构建原理 1.Docker架构模式 docker使用了client/server的架构模式。构建镜像时，用户在dockers client输入构建命令。docker引擎以 REST API的形式，像 docker daemon发送构建请求，如何dockers daemon就根据构建请求的内容，开始镜像构建的工作，并向Client持续放回构建过程的信息。
2.镜像分层模型 docker镜像是用于创建容器的只读模板，是通过 Dockerfile中定义的指令构建而成的，构建结束后，会在原有的镜像层上生成一个新的镜像层，如下所示
在 tomcat 镜像创建一个容器后，会在tomcat镜像之上新创建一个可写的容器层，在容器中写文件时，会保存到这个容器层中
3.基础镜像与父级镜像 用于构建基础镜像的 Dockerfile 不指定父级镜像，Docker约定使用如下形式基础镜像"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="notes"><meta property="article:published_time" content="2025-07-03T22:17:17+08:00"><meta property="article:modified_time" content="2025-07-03T22:17:17+08:00"><meta property="article:tag" content="Docker"><meta name=twitter:card content="summary"><meta name=twitter:title content="Dockerfile(bate)"><meta name=twitter:description content="Dockerfile 构建你自己的容器
学习自
一篇文章带你吃透 Dockerfile - 掘金 (juejin.cn) Dockerfile reference 全网最详细的Docker-Compose详细教程 - 掘金 (juejin.cn) docker compose 配置文件 .yml 全面指南 - 知乎 (zhihu.com) compose-spec/spec.md at master · compose-spec/compose-spec · GitHub 学习Dockers前期，通过Docker的官方镜像仓库拉取里面的镜像，根据这些镜像创建出容器并运行
实际上，Docker官方镜像也是通过一定的方式构建出来的，只要弄清其中的逻辑，我们也可以仿照官方镜像的构建过程，构建出自己的镜像
Dockerfile就是这样一个用于描述Docker镜像构建过程的文本文件，dockerfile可以包含多条构建指令，以及相关的描述
1.什么是容器 容器是计算机上的沙盒进程，与主机上的其它进程隔离，这种隔离利用了内核命名空间和cgroups。简而言之容器是：
是image的可运行实例
可以在本地计算机、虚拟机上运行或部署到云中
是可移植的
与其它容器隔离，并运行自己的软件，二进制文件和配置
2.什么是容器映射 当容器运行时，它使用了隔离的文件系统。这个自定义的文件系统由容器映像container image提供。因为image包含了容器的问价系统，使用image必须包含所有的运行应用程序所必须的所有东西——依赖项、配置、脚本、二进制文件等等。
沙盒进程是指在计算机系统中，为了保障安全和隔离性而采用的一种技术，将应用程序运行在一个受限制的环境中，限制它们能访问的资源和操作范围，从而避免恶意程序和授权程序对系统的破坏
3.容器是怎么运行的 当一个容器运行时，它为其文件系统使用来image的各个层。每个容器都有自己的命名空间来创建/更新/删除文件。在另一个容器中不会看到任何更改，即使它们使用相同的image
4.容器卷[container volumes] 每个容器启动时都是从容器的定义开始的。在容器中可以创建、更新和删除文件，但当容器被删除时，这些改变将回丢失，所有更变都被隔离在各个容器中
卷：提供了将容器的特定文件系统路径链路到主机的能力。如果在主机上的某个文件被挂载，那么当容器中该文件路径下的文件发送更改时，我们在主机上同样也可以看到更改。同样的，启动另一个挂载了同一个文件目录的容器，它也可以访问到相同的文件
镜像构建原理 1.Docker架构模式 docker使用了client/server的架构模式。构建镜像时，用户在dockers client输入构建命令。docker引擎以 REST API的形式，像 docker daemon发送构建请求，如何dockers daemon就根据构建请求的内容，开始镜像构建的工作，并向Client持续放回构建过程的信息。
2.镜像分层模型 docker镜像是用于创建容器的只读模板，是通过 Dockerfile中定义的指令构建而成的，构建结束后，会在原有的镜像层上生成一个新的镜像层，如下所示
在 tomcat 镜像创建一个容器后，会在tomcat镜像之上新创建一个可写的容器层，在容器中写文件时，会保存到这个容器层中
3.基础镜像与父级镜像 用于构建基础镜像的 Dockerfile 不指定父级镜像，Docker约定使用如下形式基础镜像"><link rel=stylesheet href=/css/components.min.9d886688d3ae94cecf1b057e706bf74497fcd5cea352d433c34cda3b9425a8d4.css integrity="sha256-nYhmiNOulM7PGwV+cGv3RJf81c6jUtQzw0zaO5QlqNQ=" crossorigin=anonymous><link rel=stylesheet href=/css/main.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css integrity="sha256-47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=" crossorigin=anonymous><link rel=stylesheet href=/css/root.min.1677bc99f2421f7cb9fc1d00b09addcc951fd9d4c785e22b20ed55c0602786fc.css integrity="sha256-Fne8mfJCH3y5/B0AsJrdzJUf2dTHheIrIO1VwGAnhvw=" crossorigin=anonymous><link rel=stylesheet href=/css/search.min.cb1ed1dad3ee872e229e9f1fc681bdbd20d923389f1fa6aaf89f9aee93af4fbf.css integrity="sha256-yx7R2tPuhy4inp8fxoG9vSDZIzifH6aq+J+a7pOvT78=" crossorigin=anonymous><link rel=stylesheet href=/css/bundle.min.4878d16c866148ae8cfd6f4f44052d25f2548b24ab4a9bc857279dc6d06df2b5.css integrity="sha256-SHjRbIZhSK6M/W9PRAUtJfJUiySrSpvIVyedxtBt8rU=" crossorigin=anonymous><script src=/js/bundle.995e4ec99401021e081ec256bee66154ef7f4e5136809432513b2e6d014b4b1d.js integrity="sha256-mV5OyZQBAh4IHsJWvuZhVO9/TlE2gJQyUTsubQFLSx0=" crossorigin=anonymous></script><script defer src=/js/search/flexsearch.compact.64594b125f7b78bdf4fa8316955922bbebb1cd6baef3f16654bfca20309f18f8.js integrity="sha256-ZFlLEl97eL30+oMWlVkiu+uxzWuu8/FmVL/KIDCfGPg="></script><script defer src=/js/search/search.1d980f84df11f3eb7c8c5f17f541d49a0611608df179dd74fa7f06225eb56ace.js integrity="sha256-HZgPhN8R8+t8jF8X9UHUmgYRYI3xed10+n8GIl61as4="></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:opsz,wght@12..96,200..800&family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel=stylesheet></head><body class=notransition><div id=container><header id=main-header><div role=navigation aria-label=Main><div class=nav-left><a href=https://chhz0.github.io/ style=color:inherit>ch.hugo</a></div><div class=nav-right><div style=position:absolute;width:0;height:0><div id=nav-dropdown-menu class=hidden href=#><div class=nav-item><a href=/blogs/>博客</a></div><div class=nav-item><a aria-current=true class=ancestor href=/notes/>笔记</a></div><div class=nav-item><a href=/about/>关于</a></div></div></div><a id=nav-dropdown-button href=#><svg width="20" height="20" viewBox="0 0 24 24" fill="none"><path d="M4 6H20M4 12H20M4 18H20" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></a><div id=nav-menu><div class=nav-item><a href=/blogs/>博客</a></div><div class=nav-item><a aria-current=true class=ancestor href=/notes/>笔记</a></div><div class=nav-item><a href=/about/>关于</a></div></div><a id=theme-switcher href=#><svg class="light-icon" viewBox="0 0 24 24" fill="none"><path d="M12 3V4m0 16v1M4 12H3M6.31412 6.31412 5.5 5.5m12.1859.81412L18.5 5.5M6.31412 17.69 5.5 18.5001M17.6859 17.69 18.5 18.5001M21 12H20m-4 0c0 2.2091-1.7909 4-4 4-2.20914.0-4-1.7909-4-4 0-2.20914 1.79086-4 4-4 2.2091.0 4 1.79086 4 4z" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
<svg class="dark-icon" viewBox="0 0 24 24" fill="none"><path d="M3.32031 11.6835c0 4.9706 4.02944 9 8.99999 9 3.7872.0 7.028-2.3392 8.3565-5.6515C19.6402 15.4486 18.5059 15.6834 17.3203 15.6834c-4.9706.0-8.99999-4.0294-8.99999-8.99998C8.32031 5.50338 8.55165 4.36259 8.96453 3.32996 5.65605 4.66028 3.32031 7.89912 3.32031 11.6835z" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
</a>|
<a id=theme-switcher href=https://github.com/chhz0 aria-label=GitHub><svg class="light-icon" width="800" height="800" viewBox="0 0 20 20" xmlns:xlink="http://www.w3.org/1999/xlink"><title>github [#142]</title><desc>Created with Sketch.</desc><defs/><g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="Dribbble-Light-Preview" transform="translate(-140.000000, -7559.000000)" fill="#fff"><g id="icons" transform="translate(56.000000, 160.000000)"><path d="M94 7399C99.523 7399 104 7403.59 104 7409.253 104 7413.782 101.138 7417.624 97.167 7418.981 96.66 7419.082 96.48 7418.762 96.48 7418.489 96.48 7418.151 96.492 7417.047 96.492 7415.675 96.492 7414.719 96.172 7414.095 95.813 7413.777 98.04 7413.523 100.38 7412.656 100.38 7408.718 100.38 7407.598 99.992 7406.684 99.35 7405.966 99.454 7405.707 99.797 7404.664 99.252 7403.252 99.252 7403.252 98.414 7402.977 96.505 7404.303 95.706 7404.076 94.85 7403.962 94 7403.958 93.15 7403.962 92.295 7404.076 91.497 7404.303 89.586 7402.977 88.746 7403.252 88.746 7403.252 88.203 7404.664 88.546 7405.707 88.649 7405.966 88.01 7406.684 87.619 7407.598 87.619 7408.718 87.619 7412.646 89.954 7413.526 92.175 7413.785 91.889 7414.041 91.63 7414.493 91.54 7415.156 90.97 7415.418 89.522 7415.871 88.63 7414.304 88.63 7414.304 88.101 7413.319 87.097 7413.247 87.097 7413.247 86.122 7413.234 87.029 7413.87 87.029 7413.87 87.684 7414.185 88.139 7415.37 88.139 7415.37 88.726 7417.2 91.508 7416.58 91.513 7417.437 91.522 7418.245 91.522 7418.489 91.522 7418.76 91.338 7419.077 90.839 7418.982 86.865 7417.627 84 7413.783 84 7409.253 84 7403.59 88.478 7399 94 7399" id="github-[#142]"/></g></g></g></svg><svg class="dark-icon" width="800" height="800" viewBox="0 0 20 20" xmlns:xlink="http://www.w3.org/1999/xlink"><title>github [#142]</title><desc>Created with Sketch.</desc><defs/><g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="Dribbble-Light-Preview" transform="translate(-140.000000, -7559.000000)" fill="#000"><g id="icons" transform="translate(56.000000, 160.000000)"><path d="M94 7399C99.523 7399 104 7403.59 104 7409.253 104 7413.782 101.138 7417.624 97.167 7418.981 96.66 7419.082 96.48 7418.762 96.48 7418.489 96.48 7418.151 96.492 7417.047 96.492 7415.675 96.492 7414.719 96.172 7414.095 95.813 7413.777 98.04 7413.523 100.38 7412.656 100.38 7408.718 100.38 7407.598 99.992 7406.684 99.35 7405.966 99.454 7405.707 99.797 7404.664 99.252 7403.252 99.252 7403.252 98.414 7402.977 96.505 7404.303 95.706 7404.076 94.85 7403.962 94 7403.958 93.15 7403.962 92.295 7404.076 91.497 7404.303 89.586 7402.977 88.746 7403.252 88.746 7403.252 88.203 7404.664 88.546 7405.707 88.649 7405.966 88.01 7406.684 87.619 7407.598 87.619 7408.718 87.619 7412.646 89.954 7413.526 92.175 7413.785 91.889 7414.041 91.63 7414.493 91.54 7415.156 90.97 7415.418 89.522 7415.871 88.63 7414.304 88.63 7414.304 88.101 7413.319 87.097 7413.247 87.097 7413.247 86.122 7413.234 87.029 7413.87 87.029 7413.87 87.684 7414.185 88.139 7415.37 88.139 7415.37 88.726 7417.2 91.508 7416.58 91.513 7417.437 91.522 7418.245 91.522 7418.489 91.522 7418.76 91.338 7419.077 90.839 7418.982 86.865 7417.627 84 7413.783 84 7409.253 84 7403.59 88.478 7399 94 7399" id="github-[#142]"/></g></g></g></svg></a></div></div></header><div class="flex grow"><div id=main-pane><main id=main-content><div class=single-header><ol class=breadcrumbs itemscope itemtype=https://schema.org/BreadcrumbList><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://chhz0.github.io/><span itemprop=name>Home</span>
</a><meta itemprop=position content='1'></li><span>&nbsp»&nbsp</span><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://chhz0.github.io/notes/><span itemprop=name>Notes</span>
</a><meta itemprop=position content='2'></li><span>&nbsp»&nbsp</span><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://chhz0.github.io/notes/docker/><span itemprop=name>Docker</span>
</a><meta itemprop=position content='3'></li><span>&nbsp»&nbsp</span></ol><h1>Dockerfile(bate)</h1><time class=dim datetime=2025-07-03T22:17:17+08:00>July 3, 2025</time><div class=term-container><div class=tag><a href=https://chhz0.github.io/tags/docker/>#docker</a></div></ol></div><section class=page-section><blockquote><p>Dockerfile 构建你自己的容器</p></blockquote><p>学习自</p><ul><li><a href=https://juejin.cn/post/7179042892395053113>一篇文章带你吃透 Dockerfile - 掘金 (juejin.cn)</a></li><li><a href=https://docs.docker.com/engine/reference/builder/>Dockerfile reference</a></li><li><a href=https://juejin.cn/post/7042663735156015140>全网最详细的Docker-Compose详细教程 - 掘金 (juejin.cn)</a></li><li><a href=https://zhuanlan.zhihu.com/p/387840381>docker compose 配置文件 .yml 全面指南 - 知乎 (zhihu.com)</a></li><li><a href=https://github.com/compose-spec/compose-spec/blob/master/spec.md>compose-spec/spec.md at master · compose-spec/compose-spec · GitHub</a></li></ul><p>学习Dockers前期，通过Docker的官方镜像仓库拉取里面的镜像，根据这些镜像创建出容器并运行</p><p>实际上，Docker官方镜像也是通过一定的方式构建出来的，只要弄清其中的逻辑，我们也可以仿照官方镜像的构建过程，构建出自己的镜像</p><p><code>Dockerfile</code>就是这样一个用于描述Docker镜像构建过程的文本文件，dockerfile可以包含多条构建指令，以及相关的描述</p><h3 id=1什么是容器>1.什么是容器</h3><p>容器是计算机上的沙盒进程，与主机上的其它进程隔离，这种隔离利用了<code>内核命名空间和cgroups</code>。简而言之容器是：</p><ul><li><p>是<code>image</code>的可运行实例</p></li><li><p>可以在本地计算机、虚拟机上运行或部署到云中</p></li><li><p>是可移植的</p></li><li><p>与其它容器隔离，并运行自己的软件，二进制文件和配置</p></li></ul><h3 id=2什么是容器映射>2.什么是容器映射</h3><p>当容器运行时，它使用了隔离的文件系统。这个自定义的文件系统由容器映像<code>container image</code>提供。因为image包含了容器的问价系统，使用image必须包含所有的运行应用程序所必须的所有东西——依赖项、配置、脚本、二进制文件等等。</p><blockquote><p>沙盒进程是指在计算机系统中，为了保障安全和隔离性而采用的一种技术，将应用程序运行在一个受限制的环境中，限制它们能访问的资源和操作范围，从而避免恶意程序和授权程序对系统的破坏</p></blockquote><h3 id=3容器是怎么运行的>3.容器是怎么运行的</h3><p>当一个容器运行时，它为其文件系统使用来image的各个层。每个容器都有自己的命名空间来创建/更新/删除文件。在另一个容器中不会看到任何更改，即使它们使用相同的image</p><h3 id=4容器卷container-volumes>4.容器卷[container volumes]</h3><p>每个容器启动时都是从容器的定义开始的。在容器中可以创建、更新和删除文件，但当容器被删除时，这些改变将回丢失，所有更变都被隔离在各个容器中</p><p>卷：提供了将容器的特定文件系统路径链路到主机的能力。如果在主机上的某个文件被挂载，那么当容器中该文件路径下的文件发送更改时，我们在主机上同样也可以看到更改。同样的，启动另一个挂载了同一个文件目录的容器，它也可以访问到相同的文件</p><h2 id=镜像构建原理>镜像构建原理</h2><hr><h3 id=1docker架构模式>1.Docker架构模式</h3><p><img src="https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=ODNkMzZjNzQ1MTljOTE0ZThhNjliYjMwODFiMjQ0NTJfSVlseWZldFNjR0l6QVpDbzFMdmNhYXg1TWRZb1oxUjZfVG9rZW46RjhBeWJoWkZpb2ZZbll4WEd2dGN3RXJHbkxoXzE3MjE4NDA4ODE6MTcyMTg0NDQ4MV9WNA" alt></p><p><code>docker</code>使用了<strong>client</strong>/<strong>server</strong>的架构模式。构建镜像时，用户在<strong>dockers</strong> <strong>client</strong>输入构建命令。<strong>docker</strong>引擎以 <code>REST API</code>的形式，像 <strong>docker</strong> <strong>daemon</strong>发送构建请求，如何dockers daemon就根据构建请求的内容，开始镜像构建的工作，并向Client持续放回构建过程的信息。</p><h3 id=2镜像分层模型>2.镜像分层模型</h3><hr><p><strong>docker</strong>镜像是用于创建容器的只读模板，是通过 <strong>Dockerfile</strong>中定义的指令构建而成的，构建结束后，会在原有的镜像层上生成一个新的镜像层，如下所示</p><p><img src="https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=NmE5Yjk1OTNiMTc0MDI5YmU0NGZiNTNjZDU4NDQ5MDFfZmlPNWJYSnRaQ0RUSnJZNXpGSmN0anNFN1V6WGw4VkRfVG9rZW46RU9scmI4N0Jrb2RQVHJ4cVJFM2NwNlNtblBkXzE3MjE4NDA4ODE6MTcyMTg0NDQ4MV9WNA" alt></p><p>在 tomcat 镜像创建一个容器后，会在tomcat镜像之上新创建一个可写的容器层，在容器中写文件时，会保存到这个容器层中</p><p><img src="https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=MWU3YzUzYTM5OTE3NmZkZmEyNjhiYjZhYjljZTFiOTZfaTY2T1RORTY0UEVXWVJ0cnZ4RGxnSVE2ZGE0QWtsVlVfVG9rZW46Vk5McWI1RVV1b2h5WFV4aHBPM2NrcTNRbnVnXzE3MjE4NDA4ODE6MTcyMTg0NDQ4MV9WNA" alt></p><h3 id=3基础镜像与父级镜像>3.基础镜像与父级镜像</h3><hr><p>用于构建基础镜像的 <strong>Dockerfile</strong> 不指定父级镜像，Docker约定使用如下形式基础镜像</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> scratch</span><span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>这里的 <code>scratch</code>是一个空镜像，可以从零开始构建镜像，常用来构建最小镜像，如<code>busybox</code>，<code>debian</code>，<code>alpine</code>等镜像，省去很多linux命令，因此很小。一般，不需要自己去构建基础镜像。</p><p>构建自定义镜像时，通过<strong>FROM</strong>指定使用说明父级镜像。例如，官方的<strong>tomcat</strong>命令没有yum，vim等命令，但是我们可以将<strong>tomcat</strong>镜像作为父级镜像，然后安装想要的命令，这样在容器中就可以使用了。</p><p><img src="https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDlkNDU3NWIxM2ExYmJmNDAzMGFhZmJkM2Q5ZGI2YzJfRUEwazJiZmgzallqUHlaYlBKSlJGc1VNWVFVMVVKcUZfVG9rZW46WmlDcmJBbVZxb2FRS0t4VUNIbmNhaVMxbk5oXzE3MjE4NDA4ODE6MTcyMTg0NDQ4MV9WNA" alt></p><h3 id=4构建上下文--build-context>4.构建上下文 / build context</h3><hr><p><strong>Client</strong> 向 <strong>Docker</strong> <strong>daemon</strong> 发送的构架请求包含两部分，第一部分是 <strong>Dockerfile</strong>文件，第二部分是<strong>构建上下文</strong></p><p>构建上下文是一些文件集合，这些文件可以是指定路径下的文件，也可以是远程资源中指定路径下的文件，在构建过程中，Docker daemon 可以访问这些文件，并执行相应的操作[理解：访问配置文件]</p><ul><li>路径上下文</li></ul><p>构建命令中指定具体路径，该路径下的所有文件即为构建上下文，这些文件被打包送给Docker daemon中，然后被解压</p><p>假使一个项目的文件结构如下</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Plaintext data-lang=Plaintext><span style=display:flex><span>demo
</span></span><span style=display:flex><span>|--Dockerfile
</span></span><span style=display:flex><span>|--src
</span></span><span style=display:flex><span>|--test
</span></span><span style=display:flex><span>|--node_modules
</span></span></code></pre></div><p>在项目根目录执行下面的构建命令</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span>docker build -t img-tag .<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>构建请求的第一部分是<strong>Dockerfile</strong>，这个文件在当前目录下，文件是默认名称，因此省略，</p><p>相当于默认加上了 <strong>-f Dockerfile</strong>, 该Dockerfile内容如下</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> busybox</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>WORKDIR</span><span style=color:#e6db74> /src</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> src .<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>构建请求的第二部分是 <code>.</code>这个点代表当前，此时当前目录就是此次的构建的上下文，Docker引擎会整理该目录下的所有文件，把不被 <code>.dockerignore</code>中的规则所的文件都发送到Docker daemon中，如下所示</p><p><img src="https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWYzNWIwOTExNWEyZDE1MWViMDUzZWI1NTJlY2Y5MDBfN3VzcmhGU0U3WDlJbVZ1aDU2TngzSm1pckQ4bWNjSUFfVG9rZW46S1dTOWJHSzVrb2ZPVTN4QVMyTWN4U1E3bjhkXzE3MjE4NDA4ODE6MTcyMTg0NDQ4MV9WNA" alt></p><p>如果此时位于项目根目录的上一级目录，构建命令如下</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span>docker build -t img-tag -f ./demo/Dockerfile ./demo/<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><ul><li>URL上下文</li></ul><p>Docker 还支持利用远程仓库URL构建镜像，此时指定的远程仓库目录就充当了构建上下文</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Bash data-lang=Bash><span style=display:flex><span>docker build https://gitee.com:user/my-repo.git#master:docker
</span></span></code></pre></div><p>以上构建命令指定了一个 Gitee 项目的 master 分支，冒号（:）之前是 Git 检出的目标 URL, 冒号之后的 docker 是远程仓库根目录下的一个子目录，此时这个子目录就是构建上下文</p><p>Docker client 执行构建命令时，Docker 引擎首先会将远程仓库的 master 分支拉取到本地的一个临时目录中，然后将其中的 docker 目录下的文件作为构建上下文发送到 Docker daemon 中。拉取远程文件之后，又回到了路径上下文的步骤，如下图所示</p><p><img src="https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=YmQyZDhlNzE5MWEyNWMzYzcyNzYzZGY2ZjNhMGMyZTVfd1BUeUhQaU01dE84N1JpWTZWOGFRZldyb0p3MEhxbEhfVG9rZW46UXRpVmJLb3VOb1RFb0h4REYyUWNOdHk3bjJjXzE3MjE4NDA4ODE6MTcyMTg0NDQ4MV9WNA" alt></p><ul><li>省略上下文</li></ul><p>如果 Dockerfile 中的指令不需要对任何文件进行操作，可以省略构建上下文，此时不会向 Docker daemon 发送额外的文件，这可以提高构建速度</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span>docker build -t my-hello-world:latest -&lt;&lt;EOF<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> busybox</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> echo <span style=color:#e6db74>&#34;hello world&#34;</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>EOF<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><h3 id=5构建缓存>5.构建缓存</h3><hr><p>迭代过程中，Dockerfile对于的资源会被经常修改，因此需要频繁重新构建镜像，Docker为了提高构建速度，设计了多种优化方案，其中最重要的是<strong>构建缓存</strong></p><p>示例：说明构建缓存是如何工作的，Dockerfile如下</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span><span style=color:#75715e># syntax=docker/dockerfile:1</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> ubuntu:latest</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> apt-get update <span style=color:#f92672>&amp;&amp;</span> apt-get install -y build-essentials<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> main.c Makefile /src/<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>WORKDIR</span><span style=color:#e6db74> /src/</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> make build<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>镜像构建过中，dockerfile 中的指令会从上往下执行，每一个构建步骤的结果都会被缓存起来，例如</p><p><img src="https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=NDY5MmEyMmQzNGVlZmM3YTdiNDcyN2UwMjU5Y2Y3MmVfQ2NnRHhMc3ZXMVhPc1BMdUFVNk9SRDAwZnJLTjR0RmZfVG9rZW46RkxWTWJXSnl4b0huWk54RlVENWNCaTVTbmlYXzE3MjE4NDA4ODE6MTcyMTg0NDQ4MV9WNA" alt></p><p>此时再次构建，会直接使用缓存中的结果(Using cache)</p><p>这里假设修改了main.c 中的代码，再次构建时，从 <code>COPY main Makefile /src/</code>这条指令开始，后续构建缓存都会失效，如下图所示</p><p><img src="https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=ODY5NjUwYTUwMmUxZWIyYzRmY2I3YTg5ZjdlMGZmZjdfMG5vQ0pvOEZlV3N3NGRTVW9VQUs5WFJRSVpOa1dMS09fVG9rZW46VU5EYWJETE01b1BXRVd4Q2lHVmNveEcwbjZnXzE3MjE4NDA4ODE6MTcyMTg0NDQ4MV9WNA" alt></p><p>如果不想使用构建缓存，执行构建命令时，可以传入 <code>--no-cahe</code></p><h3 id=6镜像构建过程>6.镜像构建过程</h3><p>Docker Client 执行构建命令后，会经过以下步骤构建出最终镜像</p><ol><li><p>确定构建上下文，如果构建上下文中有 .dockerignore 文件，解析该文件的匹配规则，将构建上下文中被匹配的文件资源排除</p></li><li><p>将 Dockerfile 和构建上下文发送给 Docker daemon</p></li><li><p>Docker daemon 收到构建请求。以下的步骤都由 Docker daemon 完成，省略主语</p></li><li><p>逐条校验 Dockerfile 中的指令是否合法，如果不合法，立即结束构建。这一步可以确定一共有多少个构建步骤，便于后续分步构建时显示当前步骤，如 <strong>Step 1/2</strong></p></li><li><p>逐条执行 Dockerfile 中的指令，每条指令都新创建一层。会生成临时 container 用于执行命令，该步骤结束后删除临时容器</p></li><li><p>生成最终镜像</p></li></ol><h2 id=dockerignore>.dockerignore</h2><hr><p>这个文件需要遵循一定的语法规则</p><ol><li><p>以 # 开头的行是备注，不会被解析为匹配规则</p></li><li><p>支持 ? 通配符，匹配单个字符</p></li><li><p>支持 * 通配符，匹配多个字符，只能匹配单级目录</p></li><li><p>支持 ** 通配符，可匹配多级目录</p></li><li><p>支持 ! 匹配符，声明某些文件资源不需要被排除</p></li><li><p>可以用 .dockerignore 排除 Dockerfile 和 .dockerignore 文件。Docker Client 仍然会将这两个文件发送到 Docker daemon，因为 Docker 底层需要。但 ADD 和 COPY 指令就无法操作这两个文件了</p></li></ol><p>示例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Plaintext data-lang=Plaintext><span style=display:flex><span># this is a .dockerignore demo
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>*/demo*
</span></span><span style=display:flex><span>*/*/demo*
</span></span><span style=display:flex><span>demo?
</span></span><span style=display:flex><span>**/mydemo*
</span></span></code></pre></div><h2 id=dockerfile>Dockerfile</h2><hr><p><strong>Dockerfile</strong>时一个用于描述Docekr镜像构建过程的文本文件，包含多条构建指令，以及相关的描述</p><p>Dockerfile的构建指令需要遵循如下的语法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span><span style=color:#75715e># Comment</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>INSTRUCTION arguments<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>以 <code>#</code>开头的行绝大部分是注释，还有一小部分是解析器指令</p><p>构建指令分两个部分，第一部分是指令，第二部分是指令参数。</p><h4 id=1解析器指令--parse-directive>1.解析器指令 / parse directive</h4><p>解析器指令是以 <code>#</code>开始，用来提示解释器对 Dockerfile进行特殊处理，构建过程中它不会增加镜像层，也不会出现在构建过程</p><p>解析器指令是可选的</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span><span style=color:#75715e># directive=value</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># 解析器指令需要在空行，注释，构建指令之前</span><span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p><strong>注意事项</strong></p><ul><li><p>同一解析器指令不能重复</p></li><li><p>不区分大小写，按照惯例，推荐小写</p></li><li><p>空行、注释、构建指令之后，Docker 不再查找解析器指令，都当成注释</p></li><li><p>按照惯例，解析器指令位于 Dockerfile 的第一行，在后面添加空行</p></li><li><p>行内的空格被忽略，不支持跨行</p></li></ul><p>Docker 目前支持两种解析器指令</p><ol><li><p>syntax</p></li><li><p>escape</p></li></ol><p><strong>syntax</strong> 解析器指令，只有使用 <strong>BuildKit</strong> 作为构建器时才生效</p><p><strong>escape</strong> 解析器指令，用于指定在 Dockerfile 中使用转义字符</p><p>在 Dockerfile 中，escape 默认为 \</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span><span style=color:#75715e># escape=\</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>复制代码<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>但 Windows 系统中的 \ 是路径分隔符，推荐将 escape 替换为 `，这和 PowerShell 是一致的</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span><span style=color:#75715e># escape=`</span><span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><h4 id=2常见指令解析>2.常见指令解析</h4><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>序号</td><td>指令名</td><td>功能描述</td></tr><tr><td>1</td><td>FROM</td><td>指定基础镜像或者父级镜像</td></tr><tr><td>2</td><td>LABEL</td><td>为镜像添加元数据</td></tr><tr><td>3</td><td>ENV</td><td>设置环境变量</td></tr><tr><td>4</td><td>WORKDIR</td><td>指定后续指令的工作目录，类似于Linux中的cd命令</td></tr><tr><td>5</td><td>USER</td><td>指定当前构建阶段以及容器运行时的默认用户，以及可选的用户组</td></tr><tr><td>6</td><td>VOLUME</td><td>创建具有指定名称的挂载数据卷，用于数据持久化</td></tr><tr><td>7</td><td>ADD</td><td>将构建上下文中指定目录下的文件复制到镜像文件按系统的指定位置</td></tr><tr><td>8</td><td>COPY</td><td>功能与语法与ADD类似，但是不会自动解压文件，也不能访问网络资源</td></tr><tr><td>9</td><td>EXPOSE</td><td>约定容器运行时监听的端口，通常用于容器与外界之间的通信</td></tr><tr><td>10</td><td>RUN</td><td>用于构建镜像过程中执行目录</td></tr><tr><td>11</td><td>CMD</td><td>构建镜像成功后，所创建的容器启动时执行的命令，常与ENTRYPOINT结合使用</td></tr><tr><td>12</td><td>ENTRYPOINT</td><td>用于配置容器以可执行的方式运行，常与CMD结合使用</td></tr></tbody></table><p><strong>FROM</strong></p><p>指定基础镜像或父级镜像</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span>FORM <span style=color:#f92672>[</span>--platform<span style=color:#f92672>=</span>&lt;platform&gt;<span style=color:#f92672>]</span> &lt;image&gt; <span style=color:#f92672>[</span>AS &lt;name&gt;<span style=color:#f92672>]</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>FORM <span style=color:#f92672>[</span>--platform<span style=color:#f92672>=</span>&lt;platform&gt;<span style=color:#f92672>]</span> &lt;image&gt;<span style=color:#f92672>[</span>:&lt;tag&gt;<span style=color:#f92672>]</span> <span style=color:#f92672>[</span>AS &lt;name&gt;<span style=color:#f92672>]</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>FORM <span style=color:#f92672>[</span>--platform<span style=color:#f92672>=</span>&lt;platform&gt;<span style=color:#f92672>]</span> &lt;image&gt;<span style=color:#f92672>[</span>@&lt;digest&gt;<span style=color:#f92672>]</span> <span style=color:#f92672>[</span>AS &lt;name&gt;<span style=color:#f92672>]</span><span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><ol><li><p><code>tag</code>或<code>digest</code>是可选项，默认为<strong>latest</strong>版本为基础镜像</p></li><li><p>如果不以任何镜像为基础，使用：<code>FORM scratch</code>.<strong>scratch</strong>是一个空镜像，用于构建最小镜像</p></li></ol><p><strong>LABEL</strong></p><p>为镜像添加元数据</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span><span style=color:#66d9ef>LABEL</span> &lt;key&gt;<span style=color:#f92672>=</span>&lt;value&gt; &lt;key&gt;<span style=color:#f92672>=</span>&lt;value&gt; &lt;key&gt;<span style=color:#f92672>=</span>&lt;value&gt;...<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>示例:<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>LABEL</span> auth<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;ch&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>          version<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;1.0.0&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>          decription<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Dockerfile&#34;</span><span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><ol><li><p>使用<code>LABEL</code>定义键值对结构的元数据，一个<strong>LABEL</strong>可指定多个元数据</p></li><li><p>定义元数据值时，尽量使用双引号</p></li><li><p>当前镜像可以继承继承镜像或者父级镜像中的元数据时，可以覆盖</p></li><li><p>可使用以下命令查看元数据</p></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span>docker image inspect -f<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;{{json .ContainerConfig.Labels}}&#39;</span> my-image<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p><strong>ENV</strong></p><p>设置环境变量</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span><span style=color:#66d9ef>ENV</span> &lt;key&gt;<span style=color:#f92672>=</span>&lt;value&gt;...<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ENV</span> &lt;key&gt; &lt;value&gt;<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><ol><li><p>当前镜像可以继承基础镜像或者父级镜像中的环境变量，也可以覆盖</p></li><li><p>使用<code>ENV</code>指定定义的环境变量，最终会持久化到容器中</p></li><li><p>运行容器时，可以通过<code>--env =</code>或者<code>-e =</code>覆盖镜像定义中的环境变量</p></li><li><p>对只使用在镜像构建过程中的变量，推荐使用<code>ARG</code>，或者内环境变量，这样不会被持久化到最终的镜像中</p></li></ol><blockquote><p>内环境变量示例：<code>RUN TEMP="no persisit"</code></p></blockquote><ol><li>查看最终镜像中的环境变量</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span>docker image inspect -f<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;{{json .ContainerConfig.Env}}&#39;</span> my-image<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p><strong>WORKDIR</strong></p><p>指定后续指令的工作目录，类似<strong>linux</strong>中的cd命令</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span><span style=color:#66d9ef>WORKDIR</span><span style=color:#e6db74> /path/to/workdir</span><span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>使用Dockerfile中设置的环境变量</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span><span style=color:#66d9ef>ENV</span> DIR_PATH<span style=color:#f92672>=</span>/demo<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>WORKDIR</span><span style=color:#e6db74> $DIR_PATH/$DIR_NAME</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> pwd<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>构建镜像时，pwd 的输出结果是 /demo，因为 $DIR_NAME 未显示指定，直接忽略</p><ol><li><p>默认的工作目录是<code>/</code></p></li><li><p>可以使用Dockerfile中显示指定的环境变量，包括父级镜像中的环境变量</p></li><li><p>父级镜像可能设置工作目录，最佳实践是显示设置当前镜像的工作目录</p></li></ol><p><strong>USER</strong></p><p>指定当前构建阶段以及容器运行时的默认用户，以及可选的用户组</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span><span style=color:#66d9ef>USER</span><span style=color:#e6db74> &lt;user&gt;[:&lt;group&gt;]</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>USER</span><span style=color:#e6db74> &lt;user&gt;[:&lt;GID&gt;]</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>USER</span><span style=color:#e6db74> &lt;UID&gt;[:&lt;group&gt;]</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>USER</span><span style=color:#e6db74> &lt;UID&gt;[:&lt;GID&gt;]</span><span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><ol><li><p>使用USER指定用户后，Dockerfile中构建镜像的<code>RUN</code>,<code>CMD</code>,<code>ENTRYPOINT</code>指令都会使用该用户，同时这个用户也是容器运行时的默认用户</p></li><li><p>不指定用户组，使用默认用户组<strong>root</strong></p></li><li><p>运行容器时，可以使用<code>-u</code>参数覆盖Dockerfile中默认的用户</p></li></ol><p><strong>VOLUME</strong></p><p>创建具有指定名称的挂载数据卷，用于数据持久化</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span><span style=color:#66d9ef>VOLUME</span> [<span style=color:#e6db74>&#34;volume1&#34;</span>,<span style=color:#e6db74>&#34;volume2&#34;</span>,<span style=color:#960050;background-color:#1e0010>...</span>]<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>VOLUME</span><span style=color:#e6db74> volume1 volume2 ...</span><span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>数据卷的特征以及作用：</p><ul><li><p>数据持久化，避免容器重启后丢失重要数据</p></li><li><p>修改数据卷时不会对容器产生影响，防止容器不断膨胀</p></li><li><p>有利于多个容器共享数据</p></li></ul><p><strong>ADD</strong></p><p>将构建上下文中指定目录下的文件**(src)<strong>复制到镜像文件系统的指定位置</strong>(dest)**</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span><span style=color:#66d9ef>ADD</span> <span style=color:#f92672>[</span>--chown<span style=color:#f92672>=</span>&lt;user&gt;:&lt;group&gt;<span style=color:#f92672>][</span>--checksum<span style=color:#f92672>=</span>&lt;checksum&gt;<span style=color:#f92672>]</span>&lt;src&gt;... &lt;dest&gt;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ADD</span> <span style=color:#f92672>[</span>--chown<span style=color:#f92672>=</span>&lt;user&gt;:&lt;group&gt;<span style=color:#f92672>][</span><span style=color:#e6db74>&#34;&lt;src&gt;&#34;</span>, ...<span style=color:#e6db74>&#34;&lt;dest&gt;&#34;</span><span style=color:#f92672>]</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ADD</span> &lt;git ref&gt; &lt;dir&gt;<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><ol><li><p>如果<code>ADD</code>指令对应的src资源有变更，Dockerfile中这条指令后的<strong>构建缓存</strong>都会失效</p></li><li><p>Dockerfile中<code>--chown</code>特性只有在linux下才有效，windows是无效的</p></li><li><p>src支持通配符</p></li><li><p>dest必须是文件夹，用以存放文件</p></li><li><p>如果src是<strong>压缩资源</strong>，将会被解压为一个文件</p></li><li><p>如果 src 是远程 URL, 并且 dest 不以 / 结尾，Docker 从 URL 下载文件，存到 dest 中</p></li><li><p>如果 src 是远程 URL，URL 中含有非空路径，并且 dest 以 / 结尾，Docker 会推断文件名，根据 URL 中的路径，在目标位置创建相同路径，将下载的文件放入其中</p></li><li><p>dest 可以是镜像文件系统下的绝对路径，或者是 WORKDIR 下的相对路径</p></li><li><p>如果 dest 不是以 / 结尾，Docker 会把它当成普通文件，src 中的内容会被写入这个文件中</p></li><li><p>如果目标位置下的某些目录不存在，会自动创建</p></li><li><p>ADD 添加网络资源时不支持身份认证，可以使用 RUN wget 或者 RUN curl 实现这个功能</p></li></ol><p><strong>COPY</strong></p><p>功能与<strong>ADD</strong>类似，但是不会自动解压文件，也不能访问网络资源</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span><span style=color:#66d9ef>COPY</span> <span style=color:#f92672>[</span>--chown<span style=color:#f92672>=</span>&lt;user&gt;:&lt;group&gt;<span style=color:#f92672>]</span> &lt;src&gt;... &lt;dest&gt;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> <span style=color:#f92672>[</span>--chown<span style=color:#f92672>=</span>&lt;user&gt;:&lt;group&gt;<span style=color:#f92672>]</span> <span style=color:#f92672>[</span><span style=color:#e6db74>&#34;&lt;src&gt;&#34;</span>,... <span style=color:#e6db74>&#34;&lt;dest&gt;&#34;</span><span style=color:#f92672>]</span><span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p><strong>EXPOSE</strong></p><p>约定容器运行时监听的端口，通常用于容器与外界之间的通信</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span><span style=color:#66d9ef>EXPOSE</span><span style=color:#e6db74> &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]</span><span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><ol><li><p>支持 TCP 或者 UDP 协议，如果不显式指定协议，默认使用 TCP 协议</p></li><li><p>需要同时以 TCP 和 UDP 协议的方式暴露同一个端口时，需要分别指定</p></li><li><p>EXPOSE 并不会真正将端口发布到宿主机，而是作为一种约定，让镜像使用者在运行容器时，用 <strong>-p</strong> 分别发布约定端口，或者 <strong>-P</strong> 发布所有约定端口</p></li><li><p>如果没有暴露端口，运行容器是也可以通过 <strong>-p</strong> 的方式映射端口</p></li></ol><p><strong>RUN</strong></p><p>用于构建镜像过程中执行命令，有两种执行方式</p><p>第一种，以<strong>shell</strong>方式运行</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Bash data-lang=Bash><span style=display:flex><span>RUN &lt;command&gt;
</span></span><span style=display:flex><span>RUN echo <span style=color:#e6db74>&#34;Hello Dockerfile&#34;</span>
</span></span></code></pre></div><p>第二种，以<strong>exec</strong>的方式运行</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Bash data-lang=Bash><span style=display:flex><span>RUN <span style=color:#f92672>[</span><span style=color:#e6db74>&#34;executable&#34;</span>,<span style=color:#e6db74>&#34;param1&#34;</span>,<span style=color:#e6db74>&#34;param2&#34;</span>...<span style=color:#f92672>]</span>
</span></span></code></pre></div><p><strong>CMD</strong></p><p>构建镜像成功后，所创建的容器启动时执行的命令</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span><span style=color:#66d9ef>CMD</span> command param1 param2 <span style=color:#75715e>#shell</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>CMD</span> [<span style=color:#e6db74>&#34;executable&#34;</span>,<span style=color:#e6db74>&#34;param1&#34;</span>,<span style=color:#e6db74>&#34;param2&#34;</span>] <span style=color:#75715e>#exec</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>CMD</span> [<span style=color:#e6db74>&#34;param1&#34;</span>,<span style=color:#e6db74>&#34;param2&#34;</span>] <span style=color:#75715e>#作为ENTRYPOINT的默认参数，是exec方式的特殊形式</span><span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><ol><li><p>Docker种只有一条<code>CMD</code>指令生效，在多条CMD指令存在的情况下，只有最后一条生效</p></li><li><p>虽然Dockerfile中只有一条CMD生效，但每一条CMD指令会新增一个镜像层，所有推荐只定义一条CMD指令，使用<code>&&</code>连接多个指令</p></li><li><p>exec方式是通过JSON数组的方式进行解析的，因此需要双引号</p></li><li><p>与RUN指令不同，RUN指令是在构建指令的过程中执行，CMD命令是在容器启动时执行</p></li><li><p><code>docker run</code>后的命令行参数会覆盖CMD中的命令</p></li></ol><p><strong>ENTRYPOINT</strong></p><p>用于配置容器以可执行的方式运行。有两种形式</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span><span style=color:#66d9ef>ENTRYPOINT</span> [<span style=color:#e6db74>&#34;executable&#34;</span>,<span style=color:#e6db74>&#34;param1&#34;</span>,<span style=color:#e6db74>&#34;param2&#34;</span>] <span style=color:#75715e>#推荐</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ENTRYPOINT</span> command param1 param2<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><ol><li><p>Dockerfile中只有最后一条<code>ENTRYPOINT</code>指令生效</p></li><li><p>运行容器时，docker run &ndash;entrypoint 覆盖该指令</p></li><li><p>shell 形式的 ENTRYPOINT 会使 CMD 命令 和 docker run</p></li></ol><p><img src="https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=YjBiYWU0ZTYwYWYyODYxMTIyMzkzZWMzMDY5ZjQ3YWJfZ1NYeEd4akFJUGl3UGQzM3ozaDdTZG5hQTFSWFZXZ2lfVG9rZW46VGdWYmJMQlUxbzF3T3V4QVh0ZGNDdzVGbmtjXzE3MjE4NDA4ODE6MTcyMTg0NDQ4MV9WNA" alt></p><ol><li><p>中的命令行参数失效。它有一个缺点，ENTRYPOINT 命令将作为 /bin/sh -c 的子命令，不会传递信号。比如，停止容器时，容器内接收不到 SIGTERM 信号，这并不是预期的效果，可以在命令前添加 exec 来解决，如 ENTRYPOINT exec top -b</p></li><li><p>指定 ENTRYPOINT 后，CMD 的内容将作为默认参数传给 ENTRYPOINT 指令，形如</p></li><li><p>如果 CMD 是在基础镜像中定义的，当前镜像定义的 ENTRYPOINT 会将 CMD 的值重置为空值，这种情况下，需要重新定义 CMD</p></li></ol><h1 id=docker-compose>Docker-Compose</h1><p>docker-compose通过一个声明式的配置文件描述整个应用，从而使用一条命令即可完成部署</p><p>docker-compose同使用<strong>YAML</strong>文件来定义多级服务，在使用时默认使用文件名<code>docker-compose.yml</code>，也可以在docker compose运行时使用<code>-f</code>参数来指定具体文件</p><p><strong>compose</strong>的优点</p><ul><li><p>在单主机上建立多个隔离环境，Compose使用项目名称将环境彼此隔离，可以在多个不同的上下文中使用此项目名称</p></li><li><p>创建容器时保留卷数据</p></li><li><p>仅重新创建以更改的容器，当服务没有更改时，Compose会使用现有的容器</p></li><li><p>变量在环境之间组合重复使用</p></li></ul><p><strong>多个配置文件</strong></p><p>可以为用一个项目配置多个compose文件，使用多个compose文件能够针对不同的环境或者不同的工作流自定义compose应用程序</p><p>默认情况下，compose读取两个文件，<code>docker-compose.yml</code>和一个可选<code>docker-compose.override.yml</code>文件</p><p>如果在两个文件中都定义了服务，compose会使用override进行合并配置</p><p>当配置文件的名称非默认情况时，可以使用<code>-f</code>指定Compose文件</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Bash data-lang=Bash><span style=display:flex><span>docker-compose -f docker-compose.yml -f docker-compose.prod.yml up -d
</span></span></code></pre></div><p><strong>yaml</strong>文件级</p><p>Docker compose的YAML文件包含有4个一级key:<code>version</code>,<code>services</code>,<code>networks</code>,<code>volumes</code></p><ul><li><p><code>version</code>:指定版本信息，通常位于文件的第一行。其定义了Compose文件格式的版本。</p></li><li><p><code>services</code>:用于定义不用的应用服务。Docker Compose会将每个服务部署在各种的容器中。</p></li><li><p><code>networks</code>:用于指引Docker创建新的网络。默认情况下，Docker Compose会创建bridge网络，这个是一个单主机网络，只能实现同一主机上容器的连接。可以使用driver属性指定不同的网络类型</p></li><li><p><code>volumes</code>用于指引Docker来创建新的卷</p></li></ul><h2 id=docker-composeyml的具体配置><strong>docker-compose.yml</strong>的具体配置：</h2><h2 id=1build>1.build</h2><p>指定构建镜像的dockerfile的上下文路径，或者详细配置文件</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-YAML data-lang=YAML><span style=display:flex><span><span style=color:#f92672>version</span>: <span style=color:#e6db74>&#34;3.9&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>services</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>webapp</span>:
</span></span><span style=display:flex><span>                <span style=color:#f92672>build</span>: <span style=color:#ae81ff>./dir</span>
</span></span></code></pre></div><p>或者更详细的写法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-YAML data-lang=YAML><span style=display:flex><span><span style=color:#f92672>version</span>: <span style=color:#e6db74>&#34;3.9&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>services</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>webapp</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>build</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>context</span>: <span style=color:#ae81ff>./dir</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>dockerfile</span>: <span style=color:#ae81ff>Dockerfile-alternate</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>args</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>buildno</span>: <span style=color:#ae81ff>1</span>
</span></span></code></pre></div><ul><li><p><strong>context</strong> 上下文路径，可以是文件路径，也可以是到链接到 git 仓库的 url。当是相对路径时，它被解释为相对于 Compose 文件的位置。</p></li><li><p><strong>dockerfile</strong> 指定构建镜像的 Dockerfile 文件名</p></li><li><p><strong>args</strong> 构建参数，只能在构建过程中访问的环境变量</p></li><li><p><strong>cache_from</strong> 缓存解析镜像列表</p></li><li><p><strong>labels</strong> 设置构建镜像的元数据</p></li><li><p><strong>network</strong> 设置网络容器连接，<code>none</code> 表示在构建期间禁用网络</p></li><li><p><strong>shm_size</strong> 设置<code>/dev/shm</code>此构建容器的分区大小</p></li><li><p><strong>target</strong> 多阶段构建，可以指定构建哪一层</p></li></ul><h2 id=2network>2.network</h2><p>&mldr;累了，下次再写</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-YAML data-lang=YAML><span style=display:flex><span><span style=color:#f92672>version</span>: <span style=color:#e6db74>&#39;3.9&#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>services</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>mysql</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>build</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>context</span>: <span style=color:#ae81ff>./mysql</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>environment</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>MYSQL_ROOT_PASSWORD</span>: <span style=color:#ae81ff>admin</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>restart</span>: <span style=color:#ae81ff>always</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>container_name</span>: <span style=color:#ae81ff>mysql</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>/data/edu-bom/mysql/test:/var/lib/mysql</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>mysql/mysql:5.7</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>3306</span>:<span style=color:#ae81ff>3306</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>networks</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>net</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>eureka</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>build</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>context</span>: <span style=color:#ae81ff>./edu-eureka-boot</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>restart</span>: <span style=color:#ae81ff>always</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>8761</span>:<span style=color:#ae81ff>8761</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>container_name</span>: <span style=color:#ae81ff>edu-eureka-boot</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>hostname</span>: <span style=color:#ae81ff>edu-eureka-boot</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>edu/edu-eureka-boot:1.0</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>depends_on</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>mysql</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>networks</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>net</span>:
</span></span><span style=display:flex><span><span style=color:#f92672>networks</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>net</span>:
</span></span><span style=display:flex><span><span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>vol</span>:
</span></span></code></pre></div><p><strong>docker compose常用命令</strong></p><ul><li><p>构建并启动服务——<code>docker-compose up -d</code></p></li><li><p>停止运行并删除服务——<code>docker-compose down</code></p></li><li><p>列出所有运行容器——<code>docker-compose ps</code></p></li><li><p>查看服务日志——<code>docker-compose logs</code></p></li><li><p>构建或重建——<code>docker-compose build</code></p></li><li><p>启动服务——<code>docker-compose start</code></p></li><li><p>停止运行中的服务——<code>docker-compose stop</code></p></li><li><p>重启服务——<code>docker-compose restart</code></p></li></ul></section></main><footer id=main-footer><div class=footer><a href=#>回到顶部 ↑</a><div class=footer-copyright><div>© 2025 Chen-Hang</div><div>powered by <a href=https://github.com/math-queiroz/rusty-typewriter target=_blank>Rusty Typewriter</a> theme for <a href=https://gohugo.io/ target=_blank>Hugo</a></div></div></div></footer></div><aside id=side-pane class=side-sticky><div class=side-details><span>5492 字数</span>
<span>23 - 29 阅读时间</span><div class=side-details-taxonomy><small>categories:
<span class=details-taxonomy><a href=https://chhz0.github.io/categories/note>Note</a></span></small></div></div><h3>目录</h3><nav id=TableOfContents><ul><li><ul><li><a href=#1什么是容器>1.什么是容器</a></li><li><a href=#2什么是容器映射>2.什么是容器映射</a></li><li><a href=#3容器是怎么运行的>3.容器是怎么运行的</a></li><li><a href=#4容器卷container-volumes>4.容器卷[container volumes]</a></li></ul></li><li><a href=#镜像构建原理>镜像构建原理</a><ul><li><a href=#1docker架构模式>1.Docker架构模式</a></li><li><a href=#2镜像分层模型>2.镜像分层模型</a></li><li><a href=#3基础镜像与父级镜像>3.基础镜像与父级镜像</a></li><li><a href=#4构建上下文--build-context>4.构建上下文 / build context</a></li><li><a href=#5构建缓存>5.构建缓存</a></li><li><a href=#6镜像构建过程>6.镜像构建过程</a></li></ul></li><li><a href=#dockerignore>.dockerignore</a></li><li><a href=#dockerfile>Dockerfile</a><ul><li></li></ul></li></ul><ul><li><a href=#docker-composeyml的具体配置><strong>docker-compose.yml</strong>的具体配置：</a></li><li><a href=#1build>1.build</a></li><li><a href=#2network>2.network</a></li></ul></nav><h3>相关</h3><ul><li><a href=/notes/docker/docker/>Docker(bate)</a></li></ul></aside></div></div></body></html>