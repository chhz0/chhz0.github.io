<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Docker(bate) | ch.hugo</title>
<link rel=icon href=favicon.svg sizes=any type=image/svg+xml><meta property="og:url" content="https://chhz0.github.io/notes/docker/docker/"><meta property="og:site_name" content="ch.hugo"><meta property="og:title" content="Docker(bate)"><meta property="og:description" content="Docker 一文
https://yeasy.gitbook.io/docker_practice/
一、基本概念 镜像(Image) 容器(Container) 仓库(Repository) 理解以上三个概念，就能理解docker的生命周期
1.镜像 Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件，以及一些运行时所需的配置参数。镜像不包含任何动态数据，其内容在插件之后也不会被改变
分层存储，镜像采用了分层存储的架构，由一组文件系统组成的（多层文件系统联合组成）。在构建镜像时，会一层一层构建，后一层依赖于上一层，后一层上的任何改变都只会发生在本层，不会干涉到上一层。因此构建镜像的时候，需要对每层需要添加的东西尽量加最少最有必要的东西，减少额外的东西
分层存储的特征还使得镜像的复用，定制更为容易
2.容器 容器是镜像运行时的实体，可以被创建、启动、停止、删除暂停等
镜像(Image)和容器(container)的关系，就像是面向对象程序设计中的类 和实例 一样
容器的实质是进程，运行于属于自己的独立的命名空间。因此容器可以拥有自己的root 文件系统，网络配置、进程空间等，运行在一个隔离的环境。这样的隔离特性，使得容器封装的应用比直接在宿主运行更加安全
容器也是分层存储，是以镜像为基础层，在其上创建一个当前容器的存储层，这个层是为容器运行时进行读写而准备的，称为容器存储层
容器存储层的生命周期跟容器一样，当容器消亡时，容器存储层也随之消亡，因此任何保存于容器存储层的信息都会随着容器的删除而丢失
Dokcer最佳实践的要求，容器不应该向其存储层写入任何数据，容器存储层保存无状态化，所有的文件写入操作，都应该使用数据卷、或者绑定宿主目录
数据卷独立于容器，使用容器卷，容器的删除或者重写运行之后，数据都不会丢失
3.仓库 Docker Register：提供一个集中的存储、分发镜像的服务
一个Docker Register可以包含多个**仓库（Repository）;每个仓库可以包含多个标签（Tag）,**每个标签对应一个镜像
可以通过<Repository Name>:<Tag Name> 的格式来指定具体的软件是那个版本的镜像
仓库名以两段路径形式出现，比如jwilder/nginx-proxy 前者是Docker Registry多用户环境下的用户名，后者是对应的软件名
Docker Registry 公开服务 Docker Registry公开服务是开放给用户使用、允许用户管理镜像的Registry服务。
最常见的是Docker Registry公开服务是官方的hub.docker.com，也是默认的Registry
也可以使用国内的镜像网站
私有Docker Registry 用户可以在本地搭建私有的Docker Registry。Docker提供了Docker Registry镜像，可以直接使用搭建私有Registry服务
二、镜像 1.获取镜像 从Docker镜像仓库获取镜像的命令是 docker pull
docker pull [选项] [Docker Registry 地址[:端口号]/] 仓库名[:标签] 具体选项可以从docker pull --help 命令查看，
Docker镜像仓库地址：地址格式一般为 <域名/IP>[:端口号]。默认地址是 Docker Hub"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="notes"><meta property="article:published_time" content="2025-07-03T22:17:11+08:00"><meta property="article:modified_time" content="2025-07-03T22:17:11+08:00"><meta property="article:tag" content="Docker"><meta name=twitter:card content="summary"><meta name=twitter:title content="Docker(bate)"><meta name=twitter:description content="Docker 一文
https://yeasy.gitbook.io/docker_practice/
一、基本概念 镜像(Image) 容器(Container) 仓库(Repository) 理解以上三个概念，就能理解docker的生命周期
1.镜像 Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件，以及一些运行时所需的配置参数。镜像不包含任何动态数据，其内容在插件之后也不会被改变
分层存储，镜像采用了分层存储的架构，由一组文件系统组成的（多层文件系统联合组成）。在构建镜像时，会一层一层构建，后一层依赖于上一层，后一层上的任何改变都只会发生在本层，不会干涉到上一层。因此构建镜像的时候，需要对每层需要添加的东西尽量加最少最有必要的东西，减少额外的东西
分层存储的特征还使得镜像的复用，定制更为容易
2.容器 容器是镜像运行时的实体，可以被创建、启动、停止、删除暂停等
镜像(Image)和容器(container)的关系，就像是面向对象程序设计中的类 和实例 一样
容器的实质是进程，运行于属于自己的独立的命名空间。因此容器可以拥有自己的root 文件系统，网络配置、进程空间等，运行在一个隔离的环境。这样的隔离特性，使得容器封装的应用比直接在宿主运行更加安全
容器也是分层存储，是以镜像为基础层，在其上创建一个当前容器的存储层，这个层是为容器运行时进行读写而准备的，称为容器存储层
容器存储层的生命周期跟容器一样，当容器消亡时，容器存储层也随之消亡，因此任何保存于容器存储层的信息都会随着容器的删除而丢失
Dokcer最佳实践的要求，容器不应该向其存储层写入任何数据，容器存储层保存无状态化，所有的文件写入操作，都应该使用数据卷、或者绑定宿主目录
数据卷独立于容器，使用容器卷，容器的删除或者重写运行之后，数据都不会丢失
3.仓库 Docker Register：提供一个集中的存储、分发镜像的服务
一个Docker Register可以包含多个**仓库（Repository）;每个仓库可以包含多个标签（Tag）,**每个标签对应一个镜像
可以通过<Repository Name>:<Tag Name> 的格式来指定具体的软件是那个版本的镜像
仓库名以两段路径形式出现，比如jwilder/nginx-proxy 前者是Docker Registry多用户环境下的用户名，后者是对应的软件名
Docker Registry 公开服务 Docker Registry公开服务是开放给用户使用、允许用户管理镜像的Registry服务。
最常见的是Docker Registry公开服务是官方的hub.docker.com，也是默认的Registry
也可以使用国内的镜像网站
私有Docker Registry 用户可以在本地搭建私有的Docker Registry。Docker提供了Docker Registry镜像，可以直接使用搭建私有Registry服务
二、镜像 1.获取镜像 从Docker镜像仓库获取镜像的命令是 docker pull
docker pull [选项] [Docker Registry 地址[:端口号]/] 仓库名[:标签] 具体选项可以从docker pull --help 命令查看，
Docker镜像仓库地址：地址格式一般为 <域名/IP>[:端口号]。默认地址是 Docker Hub"><link rel=stylesheet href=/css/components.min.9d886688d3ae94cecf1b057e706bf74497fcd5cea352d433c34cda3b9425a8d4.css integrity="sha256-nYhmiNOulM7PGwV+cGv3RJf81c6jUtQzw0zaO5QlqNQ=" crossorigin=anonymous><link rel=stylesheet href=/css/main.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css integrity="sha256-47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=" crossorigin=anonymous><link rel=stylesheet href=/css/root.min.1677bc99f2421f7cb9fc1d00b09addcc951fd9d4c785e22b20ed55c0602786fc.css integrity="sha256-Fne8mfJCH3y5/B0AsJrdzJUf2dTHheIrIO1VwGAnhvw=" crossorigin=anonymous><link rel=stylesheet href=/css/search.min.cb1ed1dad3ee872e229e9f1fc681bdbd20d923389f1fa6aaf89f9aee93af4fbf.css integrity="sha256-yx7R2tPuhy4inp8fxoG9vSDZIzifH6aq+J+a7pOvT78=" crossorigin=anonymous><link rel=stylesheet href=/css/bundle.min.4878d16c866148ae8cfd6f4f44052d25f2548b24ab4a9bc857279dc6d06df2b5.css integrity="sha256-SHjRbIZhSK6M/W9PRAUtJfJUiySrSpvIVyedxtBt8rU=" crossorigin=anonymous><script src=/js/bundle.995e4ec99401021e081ec256bee66154ef7f4e5136809432513b2e6d014b4b1d.js integrity="sha256-mV5OyZQBAh4IHsJWvuZhVO9/TlE2gJQyUTsubQFLSx0=" crossorigin=anonymous></script><script defer src=/js/search/flexsearch.compact.64594b125f7b78bdf4fa8316955922bbebb1cd6baef3f16654bfca20309f18f8.js integrity="sha256-ZFlLEl97eL30+oMWlVkiu+uxzWuu8/FmVL/KIDCfGPg="></script><script defer src=/js/search/search.1d980f84df11f3eb7c8c5f17f541d49a0611608df179dd74fa7f06225eb56ace.js integrity="sha256-HZgPhN8R8+t8jF8X9UHUmgYRYI3xed10+n8GIl61as4="></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:opsz,wght@12..96,200..800&family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel=stylesheet></head><body class=notransition><div id=container><header id=main-header><div role=navigation aria-label=Main><div class=nav-left><a href=https://chhz0.github.io/ style=color:inherit>ch.hugo</a></div><div class=nav-right><div style=position:absolute;width:0;height:0><div id=nav-dropdown-menu class=hidden href=#><div class=nav-item><a href=/blogs/>博客</a></div><div class=nav-item><a aria-current=true class=ancestor href=/notes/>笔记</a></div><div class=nav-item><a href=/about/>关于</a></div></div></div><a id=nav-dropdown-button href=#><svg width="20" height="20" viewBox="0 0 24 24" fill="none"><path d="M4 6H20M4 12H20M4 18H20" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></a><div id=nav-menu><div class=nav-item><a href=/blogs/>博客</a></div><div class=nav-item><a aria-current=true class=ancestor href=/notes/>笔记</a></div><div class=nav-item><a href=/about/>关于</a></div></div><a id=theme-switcher href=#><svg class="light-icon" viewBox="0 0 24 24" fill="none"><path d="M12 3V4m0 16v1M4 12H3M6.31412 6.31412 5.5 5.5m12.1859.81412L18.5 5.5M6.31412 17.69 5.5 18.5001M17.6859 17.69 18.5 18.5001M21 12H20m-4 0c0 2.2091-1.7909 4-4 4-2.20914.0-4-1.7909-4-4 0-2.20914 1.79086-4 4-4 2.2091.0 4 1.79086 4 4z" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
<svg class="dark-icon" viewBox="0 0 24 24" fill="none"><path d="M3.32031 11.6835c0 4.9706 4.02944 9 8.99999 9 3.7872.0 7.028-2.3392 8.3565-5.6515C19.6402 15.4486 18.5059 15.6834 17.3203 15.6834c-4.9706.0-8.99999-4.0294-8.99999-8.99998C8.32031 5.50338 8.55165 4.36259 8.96453 3.32996 5.65605 4.66028 3.32031 7.89912 3.32031 11.6835z" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
</a>|
<a id=theme-switcher href=https://github.com/chhz0 aria-label=GitHub><svg class="light-icon" width="800" height="800" viewBox="0 0 20 20" xmlns:xlink="http://www.w3.org/1999/xlink"><title>github [#142]</title><desc>Created with Sketch.</desc><defs/><g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="Dribbble-Light-Preview" transform="translate(-140.000000, -7559.000000)" fill="#fff"><g id="icons" transform="translate(56.000000, 160.000000)"><path d="M94 7399C99.523 7399 104 7403.59 104 7409.253 104 7413.782 101.138 7417.624 97.167 7418.981 96.66 7419.082 96.48 7418.762 96.48 7418.489 96.48 7418.151 96.492 7417.047 96.492 7415.675 96.492 7414.719 96.172 7414.095 95.813 7413.777 98.04 7413.523 100.38 7412.656 100.38 7408.718 100.38 7407.598 99.992 7406.684 99.35 7405.966 99.454 7405.707 99.797 7404.664 99.252 7403.252 99.252 7403.252 98.414 7402.977 96.505 7404.303 95.706 7404.076 94.85 7403.962 94 7403.958 93.15 7403.962 92.295 7404.076 91.497 7404.303 89.586 7402.977 88.746 7403.252 88.746 7403.252 88.203 7404.664 88.546 7405.707 88.649 7405.966 88.01 7406.684 87.619 7407.598 87.619 7408.718 87.619 7412.646 89.954 7413.526 92.175 7413.785 91.889 7414.041 91.63 7414.493 91.54 7415.156 90.97 7415.418 89.522 7415.871 88.63 7414.304 88.63 7414.304 88.101 7413.319 87.097 7413.247 87.097 7413.247 86.122 7413.234 87.029 7413.87 87.029 7413.87 87.684 7414.185 88.139 7415.37 88.139 7415.37 88.726 7417.2 91.508 7416.58 91.513 7417.437 91.522 7418.245 91.522 7418.489 91.522 7418.76 91.338 7419.077 90.839 7418.982 86.865 7417.627 84 7413.783 84 7409.253 84 7403.59 88.478 7399 94 7399" id="github-[#142]"/></g></g></g></svg><svg class="dark-icon" width="800" height="800" viewBox="0 0 20 20" xmlns:xlink="http://www.w3.org/1999/xlink"><title>github [#142]</title><desc>Created with Sketch.</desc><defs/><g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="Dribbble-Light-Preview" transform="translate(-140.000000, -7559.000000)" fill="#000"><g id="icons" transform="translate(56.000000, 160.000000)"><path d="M94 7399C99.523 7399 104 7403.59 104 7409.253 104 7413.782 101.138 7417.624 97.167 7418.981 96.66 7419.082 96.48 7418.762 96.48 7418.489 96.48 7418.151 96.492 7417.047 96.492 7415.675 96.492 7414.719 96.172 7414.095 95.813 7413.777 98.04 7413.523 100.38 7412.656 100.38 7408.718 100.38 7407.598 99.992 7406.684 99.35 7405.966 99.454 7405.707 99.797 7404.664 99.252 7403.252 99.252 7403.252 98.414 7402.977 96.505 7404.303 95.706 7404.076 94.85 7403.962 94 7403.958 93.15 7403.962 92.295 7404.076 91.497 7404.303 89.586 7402.977 88.746 7403.252 88.746 7403.252 88.203 7404.664 88.546 7405.707 88.649 7405.966 88.01 7406.684 87.619 7407.598 87.619 7408.718 87.619 7412.646 89.954 7413.526 92.175 7413.785 91.889 7414.041 91.63 7414.493 91.54 7415.156 90.97 7415.418 89.522 7415.871 88.63 7414.304 88.63 7414.304 88.101 7413.319 87.097 7413.247 87.097 7413.247 86.122 7413.234 87.029 7413.87 87.029 7413.87 87.684 7414.185 88.139 7415.37 88.139 7415.37 88.726 7417.2 91.508 7416.58 91.513 7417.437 91.522 7418.245 91.522 7418.489 91.522 7418.76 91.338 7419.077 90.839 7418.982 86.865 7417.627 84 7413.783 84 7409.253 84 7403.59 88.478 7399 94 7399" id="github-[#142]"/></g></g></g></svg></a></div></div></header><div class="flex grow"><div id=main-pane><main id=main-content><div class=single-header><ol class=breadcrumbs itemscope itemtype=https://schema.org/BreadcrumbList><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://chhz0.github.io/><span itemprop=name>Home</span>
</a><meta itemprop=position content='1'></li><span>&nbsp»&nbsp</span><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://chhz0.github.io/notes/><span itemprop=name>Notes</span>
</a><meta itemprop=position content='2'></li><span>&nbsp»&nbsp</span><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://chhz0.github.io/notes/docker/><span itemprop=name>Docker</span>
</a><meta itemprop=position content='3'></li><span>&nbsp»&nbsp</span></ol><h1>Docker(bate)</h1><time class=dim datetime=2025-07-03T22:17:11+08:00>July 3, 2025</time><div class=term-container><div class=tag><a href=https://chhz0.github.io/tags/docker/>#docker</a></div></ol></div><section class=page-section><blockquote><p>Docker 一文</p></blockquote><blockquote><p><a href=https://yeasy.gitbook.io/docker_practice/>https://yeasy.gitbook.io/docker_practice/</a></p></blockquote><h2 id=一基本概念>一、基本概念</h2><ul><li>镜像(<code>Image</code>)</li><li>容器(<code>Container</code>)</li><li>仓库(<code>Repository</code>)</li></ul><p>理解以上三个概念，就能理解docker的生命周期</p><h3 id=1镜像>1.镜像</h3><p><strong>Docker镜像</strong>是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件，以及一些运行时所需的配置参数。镜像不包含任何动态数据，其内容在插件之后也不会被改变</p><p><strong>分层存储</strong>，镜像采用了分层存储的架构，由一组文件系统组成的（多层文件系统联合组成）。在构建镜像时，会一层一层构建，后一层依赖于上一层，后一层上的任何改变都只会发生在本层，不会干涉到上一层。因此构建镜像的时候，需要对每层需要添加的东西尽量加最少最有必要的东西，减少额外的东西</p><p>分层存储的特征还使得<strong>镜像的复用，定制</strong>更为容易</p><h3 id=2容器>2.容器</h3><p>容器是镜像运行时的实体，可以被创建、启动、停止、删除暂停等</p><blockquote><p>镜像(Image)和容器(container)的关系，就像是面向对象程序设计中的<code>类</code> 和<code>实例</code> 一样</p></blockquote><p>容器的实质是进程，运行于属于自己的独立的命名空间。因此容器可以拥有自己的<code>root</code> 文件系统，网络配置、进程空间等，运行在一个隔离的环境。这样的隔离特性，使得容器封装的应用比直接在宿主运行更加安全</p><p>容器也是分层存储，是<strong>以镜像为基础层</strong>，在其上创建一个当前容器的存储层，这个层是为容器运行时进行读写而准备的，称为<strong>容器存储层</strong></p><p>容器存储层的生命周期跟容器一样，当容器消亡时，容器存储层也随之消亡，因此任何保存于容器存储层的信息都会随着容器的删除而丢失</p><blockquote><p>Dokcer最佳实践的要求，容器不应该向其存储层写入任何数据，容器存储层保存无状态化，所有的文件写入操作，都应该使用数据卷、或者绑定宿主目录</p><p>数据卷独立于容器，使用容器卷，容器的删除或者重写运行之后，数据都不会丢失</p></blockquote><h3 id=3仓库>3.仓库</h3><p>Docker Register：提供一个集中的存储、分发镜像的服务</p><p>一个<strong>Docker Register</strong>可以包含多个**仓库（<strong><strong>Repository</strong></strong>）;<strong>每个仓库可以包含多个</strong>标签（Tag）,**每个标签对应一个镜像</p><p>可以通过<code>&lt;Repository Name>:&lt;Tag Name></code> 的格式来指定具体的软件是那个版本的镜像</p><p>仓库名以两段路径形式出现，比如<code>jwilder/nginx-proxy</code> 前者是Docker Registry多用户环境下的用户名，后者是对应的软件名</p><h3 id=docker-registry-公开服务>Docker Registry 公开服务</h3><p>Docker Registry公开服务是开放给用户使用、允许用户管理镜像的Registry服务。</p><p>最常见的是Docker Registry公开服务是官方的<a href=https://hub.docker.com/>hub.docker.com</a>，也是默认的Registry</p><p>也可以使用国内的镜像网站</p><h3 id=私有docker-registry>私有Docker Registry</h3><p>用户可以在本地搭建私有的Docker Registry。Docker提供了Docker Registry镜像，可以直接使用搭建私有Registry服务</p><h2 id=二镜像>二、镜像</h2><h3 id=1获取镜像>1.获取镜像</h3><p>从Docker镜像仓库获取镜像的命令是 <code>docker pull</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span>docker pull <span style=color:#f92672>[</span>选项<span style=color:#f92672>]</span> <span style=color:#f92672>[</span>Docker Registry 地址<span style=color:#f92672>[</span>:端口号<span style=color:#f92672>]</span>/<span style=color:#f92672>]</span> 仓库名<span style=color:#f92672>[</span>:标签<span style=color:#f92672>]</span><span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>具体选项可以从<code>docker pull --help</code> 命令查看，</p><ul><li><p>Docker镜像仓库地址：地址格式一般为 <code>&lt;域名/IP>[:端口号]</code>。默认地址是 Docker Hub</p></li><li><p>仓库名：仓库名是两段式，即<code>&lt;用户名>/&lt;软件名></code>.对于Docker Hub，如果不给出用户名，默认为 <code>library</code>，也就是官方镜像</p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Bash data-lang=Bash><span style=display:flex><span>$ docker pull ubuntu:18.04
</span></span></code></pre></div><p>上面命令没有给出Docker镜像仓库地址，默认从<code>Docker Hub</code>获取镜像。而镜像名称是<code>ubuntun:18.04</code>,因此会获取官方镜像 <code>library/ubuntun</code>仓库中标签为<code>18.04</code>的镜像</p><h3 id=2运行>2.运行</h3><p>有了镜像后，我们就能够以这个镜像为基础启动并运行一个容器。以上面的<code>ubuntu:18.04</code>为例，如果我们打算启动<code>ubuntu>>bash</code>并且进行交互式操作的话，可以执行下面命令</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Bash data-lang=Bash><span style=display:flex><span>$ docker run -it --rm <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>        ubuntu:18.04 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>        bash
</span></span></code></pre></div><p><code>docker run</code>就是运行容器的命令</p><ul><li><code>-it</code>：是两个参数，一个是<code>-i</code>：交互式操作、一个是<code>-t</code>：终端。这里打算进入<code>bash</code>执行命令并查看返回结果，</li><li><code>--rm</code>：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 <code>docker rm</code>。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 <code>--rm</code> 可以避免浪费空间。</li><li><code>ubuntu:18.04</code>：这是指用 <code>ubuntu:18.04</code> 镜像为基础来启动容器。</li><li><code>bash</code>：放在镜像名后的是 <strong>命令</strong>，这里我们希望有个交互式 Shell，因此用的是 <code>bash</code>。
通过 <code>exit</code> 退出了这个容器。</li></ul><h3 id=列出镜像>列出镜像</h3><p>使用<code>docker image ls</code>命令，可以列出已经下载下来的镜像</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Bash data-lang=Bash><span style=display:flex><span>$ docker image ls
</span></span><span style=display:flex><span>Emulate Docker CLI using podman. Create /etc/containers/nodocker to quiet msg.
</span></span><span style=display:flex><span>REPOSITORY                TAG         IMAGE ID      CREATED      SIZE
</span></span><span style=display:flex><span>docker.io/library/ubuntu  18.04       e28a50f651f9  <span style=color:#ae81ff>3</span> weeks ago  65.5 MB
</span></span></code></pre></div><p>列表包含了<code>仓库名</code>、<code>标签</code>、<code>镜像ID</code>、<code>创建时间</code>、<code>所占用的空间</code></p><p><strong>镜像 ID</strong> 则是镜像的唯一标识，一个镜像可以对应多个 <strong>标签</strong>。</p><h4 id=1镜像体积>1.镜像体积</h4><p><code>docker image ls</code> 列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 <code>Docker</code> 使用 <code>Union FS</code>，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。</p><p>可以使用 <code>docker system df</code>命令来查看镜像、容器、数据卷所占用的空间</p><h4 id=2虚悬镜像>2.虚悬镜像</h4><p>一个特殊的镜像，这个镜像既没有仓库名，也没有标签，均为 <code>&lt;none></code>。：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Bash data-lang=Bash><span style=display:flex><span>&lt;none&gt;               &lt;none&gt;              00285df0df87        <span style=color:#ae81ff>5</span> days ago          <span style=color:#ae81ff>342</span> MB
</span></span></code></pre></div><p>这个镜像原本是有镜像名和标签的，原来为 <code>mongo:3.2</code>，随着官方镜像维护，发布了新版本后，重新 <code>docker pull mongo:3.2</code> 时，<code>mongo:3.2</code> 这个镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消，从而成为了 <code>&lt;none></code>。除了 <code>docker pull</code> 可能导致这种情况，<code>docker build</code> 也同样可以导致这种现象。由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 <code>&lt;none></code> 的镜像。这类无标签镜像也被称为 <strong>虚悬镜像(dangling image)</strong> ，可以用下面的命令专门显示这类镜像：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Bash data-lang=Bash><span style=display:flex><span>$ docker image ls -f dangling<span style=color:#f92672>=</span>true
</span></span><span style=display:flex><span>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
</span></span><span style=display:flex><span>&lt;none&gt;              &lt;none&gt;              00285df0df87        <span style=color:#ae81ff>5</span> days ago          <span style=color:#ae81ff>342</span> MB
</span></span></code></pre></div><p>一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Bash data-lang=Bash><span style=display:flex><span>$ docker image prune
</span></span></code></pre></div><h4 id=3中间层镜像>3.中间层镜像</h4><p>为了加速镜像构建、重复利用资源，Docker会利用<strong>中间层镜像</strong>。使用在使用一段时间过后，可能会看到一些依赖的中间层镜像。默认的 <code>docker image ls</code>列表中只会显示顶层镜像，如果希望<strong>显示</strong>包括<strong>中间层镜像所在内的所有镜像</strong>的话，需要加<code>-a</code>参数</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Bash data-lang=Bash><span style=display:flex><span>$ docker image ls -a
</span></span></code></pre></div><h4 id=4列出部分镜像>4.列出部分镜像</h4><p>不加任何参数的情况下，<code>docker image ls</code> 会列出所有顶层镜像，但是有时候我们只希望列出部分镜像。<code>docker image ls</code> 有好几个参数可以帮助做到这个事情。</p><p>根据仓库名列出镜像</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Bash data-lang=Bash><span style=display:flex><span>$ docker image ls ubuntu
</span></span><span style=display:flex><span>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
</span></span><span style=display:flex><span>ubuntu              18.04               f753707788c5        <span style=color:#ae81ff>4</span> weeks ago         <span style=color:#ae81ff>127</span> MB
</span></span><span style=display:flex><span>ubuntu              latest              f753707788c5        <span style=color:#ae81ff>4</span> weeks ago         <span style=color:#ae81ff>127</span> MB
</span></span></code></pre></div><p>列出特定的某个镜像，也就是说指定仓库名和标签</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Bash data-lang=Bash><span style=display:flex><span>$ docker image ls ubuntu:18.04
</span></span><span style=display:flex><span>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
</span></span><span style=display:flex><span>ubuntu              18.04               f753707788c5        <span style=color:#ae81ff>4</span> weeks ago         <span style=color:#ae81ff>127</span> MB
</span></span></code></pre></div><p>除此以外，<code>docker image ls</code> 还支持强大的过滤器参数 <code>--filter</code>，或者简写 <code>-f</code>。之前我们已经看到了使用过滤器来列出虚悬镜像的用法，它还有更多的用法。比如，我们希望看到在 <code>mongo:3.2</code> 之后建立的镜像，可以用下面的命令：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Bash data-lang=Bash><span style=display:flex><span>$ docker image ls -f since<span style=color:#f92672>=</span>mongo:3.2
</span></span><span style=display:flex><span>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
</span></span><span style=display:flex><span>redis               latest              5f515359c7f8        <span style=color:#ae81ff>5</span> days ago          <span style=color:#ae81ff>183</span> MB
</span></span><span style=display:flex><span>nginx               latest              05a60462f8ba        <span style=color:#ae81ff>5</span> days ago          <span style=color:#ae81ff>181</span> MB
</span></span></code></pre></div><p>想查看某个位置之前的镜像也可以，只需要把 <code>since</code> 换成 <code>before</code> 即可。</p><p>此外，如果镜像构建时，定义了 <code>LABEL</code>，还可以通过 <code>LABEL</code> 来过滤。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Bash data-lang=Bash><span style=display:flex><span>$ docker image ls -f label<span style=color:#f92672>=</span>com.example.version<span style=color:#f92672>=</span>0.1
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><h4 id=5以特定格式显示>5.以特定格式显示</h4><p>默认情况下，<code>docker image ls</code> 会输出一个完整的表格，但是我们并非所有时候都会需要这些内容。比如，刚才删除虚悬镜像的时候，我们需要利用 <code>docker image ls</code> 把所有的虚悬镜像的 ID 列出来，然后才可以交给 <code>docker image rm</code> 命令作为参数来删除指定的这些镜像，这个时候就用到了 <code>-q</code> 参数。</p></section></main><footer id=main-footer><div class=footer><a href=#>回到顶部 ↑</a><div class=footer-copyright><div>© 2025 Chen-Hang</div><div>powered by <a href=https://github.com/math-queiroz/rusty-typewriter target=_blank>Rusty Typewriter</a> theme for <a href=https://gohugo.io/ target=_blank>Hugo</a></div></div></div></footer></div><aside id=side-pane class=side-sticky><div class=side-details><span>2841 字数</span>
<span>8 - 11 阅读时间</span><div class=side-details-taxonomy><small>categories:
<span class=details-taxonomy><a href=https://chhz0.github.io/categories/note>Note</a></span></small></div></div><h3>目录</h3><nav id=TableOfContents><ul><li><a href=#一基本概念>一、基本概念</a><ul><li><a href=#1镜像>1.镜像</a></li><li><a href=#2容器>2.容器</a></li><li><a href=#3仓库>3.仓库</a></li><li><a href=#docker-registry-公开服务>Docker Registry 公开服务</a></li><li><a href=#私有docker-registry>私有Docker Registry</a></li></ul></li><li><a href=#二镜像>二、镜像</a><ul><li><a href=#1获取镜像>1.获取镜像</a></li><li><a href=#2运行>2.运行</a></li><li><a href=#列出镜像>列出镜像</a></li></ul></li></ul></nav></aside></div></div></body></html>