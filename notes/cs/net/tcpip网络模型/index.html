<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>| ch.hugo</title>
<link rel=icon href=favicon.svg sizes=any type=image/svg+xml><meta property="og:url" content="https://chhz0.github.io/notes/cs/net/tcpip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"><meta property="og:site_name" content="ch.hugo"><meta property="og:title" content="ch.hugo"><meta property="og:description" content="2.1 TCP/IP网络模型 2.1 TCP/IP 网络模型有哪几层？
前言：为什么要有TCP/IP网络模型？
答：为了提供一套 通用的 网络协议
因为在一台设备上的进程间通信有很多方式，比如管道、消息队列、共享内存、信号等方式，而对于不同的设备上的进程间通信，就需要网络通信，而设备是多样性的，需要兼容多种多样的设备，就需要一套 通用的网络协议
这个网络协议是分层的，每一层都有各自的作用和责任
TCP/IP网络模型分为4层：应用层–>传输层–>网络层–>网络接口层(由上到下)
接下来根据 [TCP/IP 网络模型 ]分别对每一层进行介绍：
应用层（最上层） 最上层的，也是我们能直接接触到的就是应用层(Application Layer)，我们使用的应用软件都是在应用层实现的，当两台不同的设备的应用需要通信的时候，应用就把应用数据传给下一层，也就是传输层。
应用层接收数据后把数据传入传输层
所以，应用层只需要专注于为用户提供应用功能，比如HTTP、FTP、Telnet、DNS、SMTP等
应用层不用关心数据是如何传输
应用层是工作在操作系统的用户态，传输层****及其一下则工作在内核态
传输层 应用层的数据包会传输到传输层，传输层(Transport Layer) 是为应用层提供网络支持
在传输层会有两个传输协议，分别为TCP和UDP
TCP的全称是“传输控制协议”(Transmission Control Protocol)，大部分应用使用的正是TCP传输层协议，比如HTTP应用层协议。
TCP有很多特征：流量控制、超时重传、拥塞控制等，这些保证了数据包能可靠地传输给对方
UDP相对来说比较协议，简单到只负责发送数据包，不保证数据包是否能抵达对方，但是实时性相对更好，传输效率也高。
UDP也可以实现可靠传输，把TCP的特性在应用层上实现就行，（不过要实现一个商用的可靠UDP传输协议也不简单）
应用需要传输的数据可能会非常大，如果直接传输就不好控制，因此当传输层的数据包大小超过MSS（TCP最大报文段长度），就要将数据包分块，这样即使在传输过程中一个分块缺失或者损坏了，只需要重新发送这一分开，而不用重新发送整个数据包。
在TCP协议中，每一个分块称为一个TCP段(TCP Segment)
当设备作为接收方时，传输层则要负责把数据包传给应用层，但是一台设备上可能会有很多应用在接收或者传输数据，因此需要一个编号将应用区分开来，这个编号就是端口
比如 80 端口通常是 Web 服务器用的，22 端口通常是远程登录服务器用的。而对于浏览器（客户端）中的每个标签栏都是一个独立的进程，操作系统会为这些进程分配临时的端口号。
由于传输层的报文中会携带端口号，因此接收方可以识别出该报文是发送给哪个应用。
传输层并不负责将数据从一个设备传输到另一个设备
网络层 在实际场景中，一个设备的数据要传输给另一个设备，就需要在各种各样的路径和节点进行选择，其中的网络环节是错综复杂的。而传输层的设计理念是简单、高效、专注，如果传输层还负责这一块功能就有点违背设计原则
我们不希望传输层协议处理太多的事情，只需要服务好应用即可，让其作为应用间数据传输的媒介，帮助实现应用到应用的通信，而实际的传输功能就交给下一层，也就是网络层(Internet Layer)
个人理解：应用层把大量的数据发送给传输层，传输层将这些大量的数据进行打包，分段，确定好目的应用，然后由网络层进行传输。
网络层最常用的是IP协议(Internet Protocol)，IP协议会将传输层的报文作为数据部分，再加上IP包头组装成IP报文，如果IP报文大小超过了MTU(以太网中一般为1500字节)就会再次进行分片，得到一个继续发送网络的IP报文
网络层负责将数据从一个设备传输到另一个设备，但是世界上那么多设备，如何找到对方呢，因此，网络层需要有区分设备的编号
一般用IP地址给设备进行编号，对于IPv4协议，IP地址共32位，分成了四段（比如127.0.0.1，分成四段，每段8位）。但是寻址起来特别麻烦，不能一个一个去匹配。
因此，需要将IP地址分成两种意义：
一个是网络号，负责标识该IP地址是属于那个[ 子网 ]的"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="notes"><meta name=twitter:card content="summary"><meta name=twitter:title content="ch.hugo"><meta name=twitter:description content="2.1 TCP/IP网络模型 2.1 TCP/IP 网络模型有哪几层？
前言：为什么要有TCP/IP网络模型？
答：为了提供一套 通用的 网络协议
因为在一台设备上的进程间通信有很多方式，比如管道、消息队列、共享内存、信号等方式，而对于不同的设备上的进程间通信，就需要网络通信，而设备是多样性的，需要兼容多种多样的设备，就需要一套 通用的网络协议
这个网络协议是分层的，每一层都有各自的作用和责任
TCP/IP网络模型分为4层：应用层–>传输层–>网络层–>网络接口层(由上到下)
接下来根据 [TCP/IP 网络模型 ]分别对每一层进行介绍：
应用层（最上层） 最上层的，也是我们能直接接触到的就是应用层(Application Layer)，我们使用的应用软件都是在应用层实现的，当两台不同的设备的应用需要通信的时候，应用就把应用数据传给下一层，也就是传输层。
应用层接收数据后把数据传入传输层
所以，应用层只需要专注于为用户提供应用功能，比如HTTP、FTP、Telnet、DNS、SMTP等
应用层不用关心数据是如何传输
应用层是工作在操作系统的用户态，传输层****及其一下则工作在内核态
传输层 应用层的数据包会传输到传输层，传输层(Transport Layer) 是为应用层提供网络支持
在传输层会有两个传输协议，分别为TCP和UDP
TCP的全称是“传输控制协议”(Transmission Control Protocol)，大部分应用使用的正是TCP传输层协议，比如HTTP应用层协议。
TCP有很多特征：流量控制、超时重传、拥塞控制等，这些保证了数据包能可靠地传输给对方
UDP相对来说比较协议，简单到只负责发送数据包，不保证数据包是否能抵达对方，但是实时性相对更好，传输效率也高。
UDP也可以实现可靠传输，把TCP的特性在应用层上实现就行，（不过要实现一个商用的可靠UDP传输协议也不简单）
应用需要传输的数据可能会非常大，如果直接传输就不好控制，因此当传输层的数据包大小超过MSS（TCP最大报文段长度），就要将数据包分块，这样即使在传输过程中一个分块缺失或者损坏了，只需要重新发送这一分开，而不用重新发送整个数据包。
在TCP协议中，每一个分块称为一个TCP段(TCP Segment)
当设备作为接收方时，传输层则要负责把数据包传给应用层，但是一台设备上可能会有很多应用在接收或者传输数据，因此需要一个编号将应用区分开来，这个编号就是端口
比如 80 端口通常是 Web 服务器用的，22 端口通常是远程登录服务器用的。而对于浏览器（客户端）中的每个标签栏都是一个独立的进程，操作系统会为这些进程分配临时的端口号。
由于传输层的报文中会携带端口号，因此接收方可以识别出该报文是发送给哪个应用。
传输层并不负责将数据从一个设备传输到另一个设备
网络层 在实际场景中，一个设备的数据要传输给另一个设备，就需要在各种各样的路径和节点进行选择，其中的网络环节是错综复杂的。而传输层的设计理念是简单、高效、专注，如果传输层还负责这一块功能就有点违背设计原则
我们不希望传输层协议处理太多的事情，只需要服务好应用即可，让其作为应用间数据传输的媒介，帮助实现应用到应用的通信，而实际的传输功能就交给下一层，也就是网络层(Internet Layer)
个人理解：应用层把大量的数据发送给传输层，传输层将这些大量的数据进行打包，分段，确定好目的应用，然后由网络层进行传输。
网络层最常用的是IP协议(Internet Protocol)，IP协议会将传输层的报文作为数据部分，再加上IP包头组装成IP报文，如果IP报文大小超过了MTU(以太网中一般为1500字节)就会再次进行分片，得到一个继续发送网络的IP报文
网络层负责将数据从一个设备传输到另一个设备，但是世界上那么多设备，如何找到对方呢，因此，网络层需要有区分设备的编号
一般用IP地址给设备进行编号，对于IPv4协议，IP地址共32位，分成了四段（比如127.0.0.1，分成四段，每段8位）。但是寻址起来特别麻烦，不能一个一个去匹配。
因此，需要将IP地址分成两种意义：
一个是网络号，负责标识该IP地址是属于那个[ 子网 ]的"><link rel=stylesheet href=/css/components.min.9d886688d3ae94cecf1b057e706bf74497fcd5cea352d433c34cda3b9425a8d4.css integrity="sha256-nYhmiNOulM7PGwV+cGv3RJf81c6jUtQzw0zaO5QlqNQ=" crossorigin=anonymous><link rel=stylesheet href=/css/main.min.17813e97a146cc70fc6064666a89082f1ef2f6213c7d3fade88402a86cf8aa3c.css integrity="sha256-F4E+l6FGzHD8YGRmaokILx7y9iE8fT+t6IQCqGz4qjw=" crossorigin=anonymous><link rel=stylesheet href=/css/root.min.1677bc99f2421f7cb9fc1d00b09addcc951fd9d4c785e22b20ed55c0602786fc.css integrity="sha256-Fne8mfJCH3y5/B0AsJrdzJUf2dTHheIrIO1VwGAnhvw=" crossorigin=anonymous><link rel=stylesheet href=/css/search.min.cb1ed1dad3ee872e229e9f1fc681bdbd20d923389f1fa6aaf89f9aee93af4fbf.css integrity="sha256-yx7R2tPuhy4inp8fxoG9vSDZIzifH6aq+J+a7pOvT78=" crossorigin=anonymous><link rel=stylesheet href=/css/bundle.min.4878d16c866148ae8cfd6f4f44052d25f2548b24ab4a9bc857279dc6d06df2b5.css integrity="sha256-SHjRbIZhSK6M/W9PRAUtJfJUiySrSpvIVyedxtBt8rU=" crossorigin=anonymous><script src=/js/bundle.995e4ec99401021e081ec256bee66154ef7f4e5136809432513b2e6d014b4b1d.js integrity="sha256-mV5OyZQBAh4IHsJWvuZhVO9/TlE2gJQyUTsubQFLSx0=" crossorigin=anonymous></script><script defer src=/js/search/flexsearch.compact.64594b125f7b78bdf4fa8316955922bbebb1cd6baef3f16654bfca20309f18f8.js integrity="sha256-ZFlLEl97eL30+oMWlVkiu+uxzWuu8/FmVL/KIDCfGPg="></script><script defer src=/js/search/search.1d980f84df11f3eb7c8c5f17f541d49a0611608df179dd74fa7f06225eb56ace.js integrity="sha256-HZgPhN8R8+t8jF8X9UHUmgYRYI3xed10+n8GIl61as4="></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:opsz,wght@12..96,200..800&family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel=stylesheet></head><body class=notransition><div id=container><header id=main-header><div role=navigation aria-label=Main><div class=nav-left><a href=https://chhz0.github.io/ style=color:inherit>ch.hugo</a></div><div class=nav-right><div style=position:absolute;width:0;height:0><div id=nav-dropdown-menu class=hidden href=#><div class=nav-item><a href=/blogs/>博客</a></div><div class=nav-item><a aria-current=true class=ancestor href=/notes/>笔记</a></div><div class=nav-item><a href=/about/>关于</a></div></div></div><a id=nav-dropdown-button href=#><svg width="20" height="20" viewBox="0 0 24 24" fill="none"><path d="M4 6H20M4 12H20M4 18H20" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></a><div id=nav-menu><div class=nav-item><a href=/blogs/>博客</a></div><div class=nav-item><a aria-current=true class=ancestor href=/notes/>笔记</a></div><div class=nav-item><a href=/about/>关于</a></div></div><a id=theme-switcher href=#><svg class="light-icon" viewBox="0 0 24 24" fill="none"><path d="M12 3V4m0 16v1M4 12H3M6.31412 6.31412 5.5 5.5m12.1859.81412L18.5 5.5M6.31412 17.69 5.5 18.5001M17.6859 17.69 18.5 18.5001M21 12H20m-4 0c0 2.2091-1.7909 4-4 4-2.20914.0-4-1.7909-4-4 0-2.20914 1.79086-4 4-4 2.2091.0 4 1.79086 4 4z" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
<svg class="dark-icon" viewBox="0 0 24 24" fill="none"><path d="M3.32031 11.6835c0 4.9706 4.02944 9 8.99999 9 3.7872.0 7.028-2.3392 8.3565-5.6515C19.6402 15.4486 18.5059 15.6834 17.3203 15.6834c-4.9706.0-8.99999-4.0294-8.99999-8.99998C8.32031 5.50338 8.55165 4.36259 8.96453 3.32996 5.65605 4.66028 3.32031 7.89912 3.32031 11.6835z" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
</a>|
<a id=theme-switcher href=https://github.com/chhz0 aria-label=GitHub><svg class="light-icon" width="800" height="800" viewBox="0 0 20 20" xmlns:xlink="http://www.w3.org/1999/xlink"><title>github [#142]</title><desc>Created with Sketch.</desc><defs/><g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="Dribbble-Light-Preview" transform="translate(-140.000000, -7559.000000)" fill="#fff"><g id="icons" transform="translate(56.000000, 160.000000)"><path d="M94 7399C99.523 7399 104 7403.59 104 7409.253 104 7413.782 101.138 7417.624 97.167 7418.981 96.66 7419.082 96.48 7418.762 96.48 7418.489 96.48 7418.151 96.492 7417.047 96.492 7415.675 96.492 7414.719 96.172 7414.095 95.813 7413.777 98.04 7413.523 100.38 7412.656 100.38 7408.718 100.38 7407.598 99.992 7406.684 99.35 7405.966 99.454 7405.707 99.797 7404.664 99.252 7403.252 99.252 7403.252 98.414 7402.977 96.505 7404.303 95.706 7404.076 94.85 7403.962 94 7403.958 93.15 7403.962 92.295 7404.076 91.497 7404.303 89.586 7402.977 88.746 7403.252 88.746 7403.252 88.203 7404.664 88.546 7405.707 88.649 7405.966 88.01 7406.684 87.619 7407.598 87.619 7408.718 87.619 7412.646 89.954 7413.526 92.175 7413.785 91.889 7414.041 91.63 7414.493 91.54 7415.156 90.97 7415.418 89.522 7415.871 88.63 7414.304 88.63 7414.304 88.101 7413.319 87.097 7413.247 87.097 7413.247 86.122 7413.234 87.029 7413.87 87.029 7413.87 87.684 7414.185 88.139 7415.37 88.139 7415.37 88.726 7417.2 91.508 7416.58 91.513 7417.437 91.522 7418.245 91.522 7418.489 91.522 7418.76 91.338 7419.077 90.839 7418.982 86.865 7417.627 84 7413.783 84 7409.253 84 7403.59 88.478 7399 94 7399" id="github-[#142]"/></g></g></g></svg><svg class="dark-icon" width="800" height="800" viewBox="0 0 20 20" xmlns:xlink="http://www.w3.org/1999/xlink"><title>github [#142]</title><desc>Created with Sketch.</desc><defs/><g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="Dribbble-Light-Preview" transform="translate(-140.000000, -7559.000000)" fill="#000"><g id="icons" transform="translate(56.000000, 160.000000)"><path d="M94 7399C99.523 7399 104 7403.59 104 7409.253 104 7413.782 101.138 7417.624 97.167 7418.981 96.66 7419.082 96.48 7418.762 96.48 7418.489 96.48 7418.151 96.492 7417.047 96.492 7415.675 96.492 7414.719 96.172 7414.095 95.813 7413.777 98.04 7413.523 100.38 7412.656 100.38 7408.718 100.38 7407.598 99.992 7406.684 99.35 7405.966 99.454 7405.707 99.797 7404.664 99.252 7403.252 99.252 7403.252 98.414 7402.977 96.505 7404.303 95.706 7404.076 94.85 7403.962 94 7403.958 93.15 7403.962 92.295 7404.076 91.497 7404.303 89.586 7402.977 88.746 7403.252 88.746 7403.252 88.203 7404.664 88.546 7405.707 88.649 7405.966 88.01 7406.684 87.619 7407.598 87.619 7408.718 87.619 7412.646 89.954 7413.526 92.175 7413.785 91.889 7414.041 91.63 7414.493 91.54 7415.156 90.97 7415.418 89.522 7415.871 88.63 7414.304 88.63 7414.304 88.101 7413.319 87.097 7413.247 87.097 7413.247 86.122 7413.234 87.029 7413.87 87.029 7413.87 87.684 7414.185 88.139 7415.37 88.139 7415.37 88.726 7417.2 91.508 7416.58 91.513 7417.437 91.522 7418.245 91.522 7418.489 91.522 7418.76 91.338 7419.077 90.839 7418.982 86.865 7417.627 84 7413.783 84 7409.253 84 7403.59 88.478 7399 94 7399" id="github-[#142]"/></g></g></g></svg></a></div></div></header><div class="flex grow"><div id=main-pane><main id=main-content><div class=single-header><ol class=breadcrumbs itemscope itemtype=https://schema.org/BreadcrumbList><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://chhz0.github.io/><span itemprop=name>Home</span>
</a><meta itemprop=position content='1'></li><span>&nbsp»&nbsp</span><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://chhz0.github.io/notes/><span itemprop=name>Notes</span>
</a><meta itemprop=position content='2'></li><span>&nbsp»&nbsp</span><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://chhz0.github.io/notes/cs/><span itemprop=name>CS</span>
</a><meta itemprop=position content='3'></li><span>&nbsp»&nbsp</span><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://chhz0.github.io/notes/cs/net/><span itemprop=name>Network</span>
</a><meta itemprop=position content='4'></li><span>&nbsp»&nbsp</span></ol><h1>Net</h1><time class=dim datetime=0001-01-01T00:00:00+00:00>January 1, 1</time></div><section class=page-section><h2 id=21-tcpip网络模型>2.1 TCP/IP网络模型</h2><blockquote><p><a href=https://xiaolincoding.com/network/1_base/tcp_ip_model.html>2.1 TCP/IP 网络模型有哪几层？</a></p></blockquote><p>前言：为什么要有TCP/IP网络模型？</p><blockquote><p>答：为了提供一套 <strong>通用的</strong> 网络协议</p></blockquote><p>因为在一台设备上的进程间通信有很多方式，比如管道、消息队列、共享内存、信号等方式，而对于不同的设备上的进程间通信，就需要网络通信，而设备是多样性的，需要兼容多种多样的设备，就需要一套 <code>通用的网络协议</code></p><p>这个网络协议是分层的，每一层都有各自的作用和责任</p><p>TCP/IP网络模型分为4层：应用层&ndash;>传输层&ndash;>网络层&ndash;>网络接口层(由上到下)</p><p>接下来根据 [TCP/IP 网络模型 ]分别对每一层进行介绍：</p><h3 id=应用层最上层><strong>应用层（最上层）</strong></h3><p>最上层的，也是我们能直接接触到的就是<strong>应用层</strong>(Application Layer)，我们使用的应用软件都是在应用层实现的，当两台不同的设备的应用需要通信的时候，应用就把应用数据传给下一层，也就是<strong>传输层</strong>。</p><blockquote><p><strong>应用层</strong>接收数据后把数据传入<strong>传输层</strong></p></blockquote><p>所以，<strong>应用层</strong>只需要专注于为用户提供应用功能，比如HTTP、FTP、Telnet、DNS、SMTP等</p><p>应用层不用关心数据是如何传输</p><blockquote><p><strong>应用层</strong>是工作在操作系统的用户态，<strong>传输层****及其一下</strong>则工作在内核态</p></blockquote><h3 id=传输层><strong>传输层</strong></h3><p><strong>应用层</strong>的数据包会传输到传输层，<strong>传输层</strong>(Transport Layer) 是为应用层提供网络支持</p><p><img src="https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=OTM5NGVmNjMyYmZhOTE2Y2JiZTlhZjRkMzJhMGU4NTVfM3F5dVFqUnppQzA2cXFoQ2F6c1RwdVlpa3QzR0U2N3lfVG9rZW46RTgwT2JPenk5b1VQaW14Y1pFY2NkYTBmbmtoXzE3MjE4Mzk4OTE6MTcyMTg0MzQ5MV9WNA" alt></p><p>在<strong>传输层</strong>会有两个传输协议，分别为<code>TCP</code>和<code>UDP</code></p><p><strong>TCP</strong>的全称是“传输控制协议”(Transmission Control Protocol)，大部分应用使用的正是TCP传输层协议，比如HTTP应用层协议。</p><blockquote><p><strong>TCP</strong>有很多特征：流量控制、超时重传、拥塞控制等，这些保证了数据包能可靠地传输给对方</p></blockquote><p><strong>UDP</strong>相对来说比较协议，简单到<strong>只负责发送数据包</strong>，不保证数据包是否能抵达对方，但是实时性相对更好，传输效率也高。</p><blockquote><p><strong>UDP</strong>也可以实现可靠传输，把<strong>TCP</strong>的特性在应用层上实现就行，（不过要实现一个商用的可靠UDP传输协议也不简单）</p></blockquote><p>应用需要传输的数据可能会非常大，如果直接传输就不好控制，因此当传输层的数据包大小超过<strong>MSS</strong>（TCP最大报文段长度），就要将数据包分块，这样即使在传输过程中一个分块缺失或者损坏了，只需要重新发送这一分开，而不用重新发送整个数据包。</p><p>在TCP协议中，每一个分块称为一个<strong>TCP段</strong>(TCP Segment)</p><p><img src="https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=OTE4YjBkOWU1ZTVlYmViZDkxNDQ1NTFmYWZkMTQzMTFfNllQajladEFQVERJUDFNWUZHNWxZRGVaWFZoanVZeE9fVG9rZW46VG5ZM2JrUzVGb1ZrN1N4UkF5b2NMdW5KbmZrXzE3MjE4Mzk4OTE6MTcyMTg0MzQ5MV9WNA" alt></p><p>当设备作为接收方时，传输层则要负责把数据包传给应用层，但是一台设备上可能会有很多应用在接收或者传输数据，因此需要一个编号将应用区分开来，这个编号就是<strong>端口</strong></p><p>比如 80 端口通常是 Web 服务器用的，22 端口通常是远程登录服务器用的。而对于浏览器（客户端）中的每个标签栏都是一个独立的进程，操作系统会为这些进程分配临时的端口号。</p><p>由于传输层的报文中会携带端口号，因此接收方可以识别出该报文是发送给哪个应用。</p><blockquote><p><strong>传输层</strong>并不负责将数据从一个设备传输到另一个设备</p></blockquote><h3 id=网络层><strong>网络层</strong></h3><p>在实际场景中，一个设备的数据要传输给另一个设备，就需要在各种各样的路径和节点进行选择，其中的网络环节是错综复杂的。而<strong>传输层</strong>的设计理念是简单、高效、专注，如果传输层还负责这一块功能就有点违背设计原则</p><p>我们不希望传输层协议处理太多的事情，只需要服务好应用即可，让其作为应用间数据传输的媒介，帮助实现应用到应用的通信，而实际的传输功能就交给下一层，也就是<strong>网络层</strong>(Internet Layer)</p><p><img src="https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=NDBiZTU5ZmFlMmQyNGNiYzdkMTA1M2YxNmZmNmMwYjhfeUhWM2IyVzAxbWdwdHZud0N3eWtsbVdDbHZoMGNiR1RfVG9rZW46RmIxTWJ2TEF6b1RaZU94S29SRmNIazNRbnJFXzE3MjE4Mzk4OTE6MTcyMTg0MzQ5MV9WNA" alt></p><blockquote><p>个人理解：应用层把大量的数据发送给传输层，传输层将这些大量的数据进行打包，分段，确定好目的应用，然后由网络层进行传输。</p></blockquote><p><strong>网络层</strong>最常用的是<strong>IP协议</strong>(Internet Protocol)，IP协议会将传输层的报文作为数据部分，再加上IP包头组装成<strong>IP报文</strong>，如果IP报文大小超过了<strong>MTU</strong>(以太网中一般为1500字节)就会<strong>再次进行分片</strong>，得到一个继续发送网络的IP报文</p><p><img src="https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=YjBhODFlM2VmZWRiYWI5MTYyOTdjY2Q3NTlmNGQ4OTNfMWhGUGlQbmszY2FmYnhmYlhUU1dHTGw3VmxEU0JXV3pfVG9rZW46WnFoWmJwM09Ub2F6VDV4ek5FMGN6dnY3bmpmXzE3MjE4Mzk4OTE6MTcyMTg0MzQ5MV9WNA" alt></p><p><strong>网络层</strong>负责将数据从一个设备传输到另一个设备，但是世界上那么多设备，如何找到对方呢，因此，网络层需要有区分设备的编号</p><p>一般用<strong>IP地址</strong>给设备进行编号，对于IPv4协议，IP地址共32位，分成了四段（比如127.0.0.1，分成四段，每段8位）。但是寻址起来特别麻烦，不能一个一个去匹配。</p><p>因此，需要将IP地址分成两种意义：</p><ul><li><p>一个是<strong>网络号</strong>，负责标识该IP地址是属于那个[ 子网 ]的</p></li><li><p>一个是<strong>主机号</strong>，负责标识同一[ 子网 ]下的不同主机</p></li></ul><p>怎么区分<strong>网络号</strong>和<strong>主机号</strong>呢？这需要配合<strong>子网掩码</strong>才能算出IP地址的网络号和主机号</p><p>举个例子，比如 10.100.122.0/24，后面的<code>/24</code>表示就是 <code>255.255.255.0</code> 子网掩码，255.255.255.0 二进制是「11111111-11111111-11111111-00000000」，大家数数一共多少个1？不用数了，是 24 个1，为了简化子网掩码的表示，用/24代替255.255.255.0。</p><p>知道了子网掩码，该怎么计算出网络地址和主机地址呢？</p><p>将 10.100.122.2 和 255.255.255.0 进行<strong>按位与运算</strong>，就可以得到网络号，如下图：</p><p><img src="https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=NmFkYzI1NDliODNjOGZlZjEzOTRlYmNkYmEwMzk3M2JfYjhnUlBYS0RSc0pKSVpxS2NNaXd4R2lsbk5qbHlFS1VfVG9rZW46Q0R3MGJLR0Q3b2FNZkl4cEpDOWN4MnFxbnVkXzE3MjE4Mzk4OTE6MTcyMTg0MzQ5MV9WNA" alt></p><p>将 255.255.255.0 取反后与IP地址进行进行<strong>按位与运算</strong>，就可以得到主机号</p><blockquote><p>~255.255.255.0 = 0.0.0.255</p></blockquote><p>除了寻找能力，IP协议还有另一个重要的能力是<strong>路由</strong>。实际场景中，两台设备并不是用一条网线连接，而是通过很多网关、路由器、交换机等众多网络设备连接起来的。那么就会形成很多条网络的路径，因此当数据包到达一个网络节点，就需要通过路由算法决定下一步哪条路径</p><p>路由器寻找工作中，就需要目标地址的子网，找到后进而把数据包发送到对应的网络内</p><p><img src="https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=YjA3ODg5YWQ4YWEzZjg3ODM2NzA5N2UyYWRlNzMwYzZfRUhKWDlsZDZ3ejFzNmVyWDhHSHNSZjh5UGZVaWF4NHlfVG9rZW46VnBRR2JGSHUzb3hSOG14MFdCOGMzVXNWbnJmXzE3MjE4Mzk4OTE6MTcyMTg0MzQ5MV9WNA" alt></p><p>所以，<strong>IP 协议的寻址作用是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据「下一个目的地」选择路径。寻址更像在导航，路由更像在操作方向盘</strong></p><h3 id=网络接口层><strong>网络接口层</strong></h3><p>生成IP头部后，接下来就是<strong>网络接口层</strong>(Link Layer)在IP头部的前面加上MAC头部，并封装成<strong>数据帧</strong>(Data frame)发送到网络上</p><p><img src="https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=NDFiNjc0MzVkOTVjOWE3NjdiNDBjN2M2NWMxM2Y0MThfNlNmUVdmamxjcUJOZVlWTnBDeHRVMHAwZzBleTh1ZktfVG9rZW46U2xDQmI2UG13b2Rrc3V4blQ1SWMyMGh3bjhjXzE3MjE4Mzk4OTE6MTcyMTg0MzQ5MV9WNA" alt></p><p>IP 头部中的接收方 IP 地址表示网络包的目的地，通过这个地址我们就可以判断要将包发到哪里，但在以太网的世界中，这个思路是行不通的。</p><p>什么是以太网呢？电脑上的以太网接口，Wi-Fi接口，以太网交换机、路由器上的千兆，万兆以太网口，还有网线，它们都是以太网的组成部分。以太网就是一种在「局域网」内，把附近的设备连接起来，使它们之间可以进行通讯的技术。</p><p>以太网在判断网络包目的地时和 IP 的方式不同，因此必须采用相匹配的方式才能在以太网中将包发往目的地，而 MAC 头部就是干这个用的，所以，在以太网进行通讯要用到 MAC 地址。</p><p>MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息，我们可以通过 ARP 协议获取对方的 MAC 地址。</p><p>所以说，网络接口层主要为网络层提供「链路级别」传输的服务，负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标识网络上的设备。</p><h3 id=总结><strong>总结</strong></h3><p><img src="https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGFmOWVkN2IzMzU1NGY1NzYzYjdhNDBlYWMyY2ZlY2VfWkE2ZUtnNXhFS29Na3ZLbFl1ODZFZ3VvbGdybnhsbmVfVG9rZW46SW9xaGJ3N3Fzb0xyR0l4Tkc0Y2NRSXBDbjc2XzE3MjE4Mzk4OTE6MTcyMTg0MzQ5MV9WNA" alt></p><p>综上所述，TCP/IP 网络通常是由上到下分成 4 层，分别是<strong>应用层，传输层，网络层和网络接口层</strong>。</p><p><img src="https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=MTY3YmM5ZjZmMDc3ZDc4NGQ3MGRmMWY3YTEzNjE1NmFfV0VLN0d3WmQxakNMYzZFWkRuQ3d1VXA4bTNudFJaSWdfVG9rZW46SDZ6dGJpcUVXbzBmdEh4S0RJcGNMaGZFbk5kXzE3MjE4Mzk4OTE6MTcyMTg0MzQ5MV9WNA" alt></p><p>网络接口层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。</p></section></main><footer id=main-footer><div class=footer><a href=#>回到顶部 ↑</a><div class=footer-copyright><div>© 2025 Chen-Hang</div><div>powered by <a href=https://github.com/math-queiroz/rusty-typewriter target=_blank>Rusty Typewriter</a> theme for <a href=https://gohugo.io/ target=_blank>Hugo</a></div></div></div></footer></div><aside id=side-pane class=side-sticky><div class=side-details><span>2243 字数</span>
<span>9 - 12 阅读时间</span></div><h3>目录</h3><nav id=TableOfContents><ul><li><a href=#21-tcpip网络模型>2.1 TCP/IP网络模型</a><ul><li><a href=#应用层最上层><strong>应用层（最上层）</strong></a></li><li><a href=#传输层><strong>传输层</strong></a></li><li><a href=#网络层><strong>网络层</strong></a></li><li><a href=#网络接口层><strong>网络接口层</strong></a></li><li><a href=#总结><strong>总结</strong></a></li></ul></li></ul></nav></aside></div></div></body></html>