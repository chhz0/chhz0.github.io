<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Mysql Log(bate) | ch.hugo</title>
<link rel=icon href=favicon.svg sizes=any type=image/svg+xml><meta property="og:url" content="https://chhz0.github.io/notes/database/mysql/mysql-log/"><meta property="og:site_name" content="ch.hugo"><meta property="og:title" content="Mysql Log(bate)"><meta property="og:description" content="MySQL 日志 - undo log | redo log | bin log
先理解执行一条sql语句，在mysql内部会发生什么？
以执行一条update 语句为例：
客户端会先通过连接器建立连接，连接器会判断用户身份
这里是一条update语句，所以不需要经过查询缓存（注意，当表上有更新语句，会把整个查询缓存清空，所以在Mysql8.0这个功能就被移除了）
解析器会通过词法分析识别出关键字，构建出语法树，接着做语法分析，判断输入的语句是否符合MySQL语法
预处理器会判断表和字段是否存在
优化器确定执行计划（使用索引或者全表查询）
执行器负责具体执行，找到这一行然后更新
不过，更新语句的流程会涉及到undo log**，redo log，binlog**三种日志：
undo log（回滚日志）：是InnoDB存储引擎生成的日志，实现了事务中的原子性，主要用于事务回滚和MVCC
redo log（重做日志）：是InnoDB存储引擎生成的日志，实现了事务中的持久性，主要用于掉电等故障恢复
bing log（归档日志）：是Server层生成的日志，主要用于数据备份和主从复制
1.为什么需要undo log？ 在执行一条“增删改”语句的时候，MySQL会隐式开启事务，执行完后自动提交事务
MySQL中执行一条语句后是否自动提交事务，是由autocommit 参数来决定的，默认是开启的
当事务执行过程中，都记录下回滚时需要的信息到一个日志中，那么在事务执行过程中发生MySQL崩溃后，可以通过这个日志回滚到事务之前的数据
实现这一机制就是 undo log**（回滚日志），它保证了事务的ACID特性中的原子性**
每当InnoDB引擎对每种操作进行回滚时，进行相反操作就行：
插入 - 删除
删除 - 插入
更新 - 更新为旧值
一条记录每次进行操作产生的undo log格式都有一个roll_pointer和一个trx_id事务id：
trx_id：记录该记录是被哪些事务修改的
roll_pointer：指针可以将这些undo log串成一个链表，这个链表被称为版本链
另外，undo log可以跟Read View一起实现MVCC（多版本并发控制）：
对于 读提交 和 可重复读 隔离级别的事务来说，它们的快照读（普通select语句）是通过Read View + undo log来实现的，区别在于创建Read View的时机不同
读提交：是在每一个select都会生成一个新的Read View，也意味着事务期间的多次读取同一数据，前后两次读的数据可能会出现不一致（不可重复读）"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="notes"><meta property="article:published_time" content="2025-07-03T23:16:14+08:00"><meta property="article:modified_time" content="2025-07-03T23:16:14+08:00"><meta property="article:tag" content="MySQL"><meta name=twitter:card content="summary"><meta name=twitter:title content="Mysql Log(bate)"><meta name=twitter:description content="MySQL 日志 - undo log | redo log | bin log
先理解执行一条sql语句，在mysql内部会发生什么？
以执行一条update 语句为例：
客户端会先通过连接器建立连接，连接器会判断用户身份
这里是一条update语句，所以不需要经过查询缓存（注意，当表上有更新语句，会把整个查询缓存清空，所以在Mysql8.0这个功能就被移除了）
解析器会通过词法分析识别出关键字，构建出语法树，接着做语法分析，判断输入的语句是否符合MySQL语法
预处理器会判断表和字段是否存在
优化器确定执行计划（使用索引或者全表查询）
执行器负责具体执行，找到这一行然后更新
不过，更新语句的流程会涉及到undo log**，redo log，binlog**三种日志：
undo log（回滚日志）：是InnoDB存储引擎生成的日志，实现了事务中的原子性，主要用于事务回滚和MVCC
redo log（重做日志）：是InnoDB存储引擎生成的日志，实现了事务中的持久性，主要用于掉电等故障恢复
bing log（归档日志）：是Server层生成的日志，主要用于数据备份和主从复制
1.为什么需要undo log？ 在执行一条“增删改”语句的时候，MySQL会隐式开启事务，执行完后自动提交事务
MySQL中执行一条语句后是否自动提交事务，是由autocommit 参数来决定的，默认是开启的
当事务执行过程中，都记录下回滚时需要的信息到一个日志中，那么在事务执行过程中发生MySQL崩溃后，可以通过这个日志回滚到事务之前的数据
实现这一机制就是 undo log**（回滚日志），它保证了事务的ACID特性中的原子性**
每当InnoDB引擎对每种操作进行回滚时，进行相反操作就行：
插入 - 删除
删除 - 插入
更新 - 更新为旧值
一条记录每次进行操作产生的undo log格式都有一个roll_pointer和一个trx_id事务id：
trx_id：记录该记录是被哪些事务修改的
roll_pointer：指针可以将这些undo log串成一个链表，这个链表被称为版本链
另外，undo log可以跟Read View一起实现MVCC（多版本并发控制）：
对于 读提交 和 可重复读 隔离级别的事务来说，它们的快照读（普通select语句）是通过Read View + undo log来实现的，区别在于创建Read View的时机不同
读提交：是在每一个select都会生成一个新的Read View，也意味着事务期间的多次读取同一数据，前后两次读的数据可能会出现不一致（不可重复读）"><link rel=stylesheet href=/css/components.min.9d886688d3ae94cecf1b057e706bf74497fcd5cea352d433c34cda3b9425a8d4.css integrity="sha256-nYhmiNOulM7PGwV+cGv3RJf81c6jUtQzw0zaO5QlqNQ=" crossorigin=anonymous><link rel=stylesheet href=/css/main.min.17813e97a146cc70fc6064666a89082f1ef2f6213c7d3fade88402a86cf8aa3c.css integrity="sha256-F4E+l6FGzHD8YGRmaokILx7y9iE8fT+t6IQCqGz4qjw=" crossorigin=anonymous><link rel=stylesheet href=/css/root.min.1677bc99f2421f7cb9fc1d00b09addcc951fd9d4c785e22b20ed55c0602786fc.css integrity="sha256-Fne8mfJCH3y5/B0AsJrdzJUf2dTHheIrIO1VwGAnhvw=" crossorigin=anonymous><link rel=stylesheet href=/css/search.min.cb1ed1dad3ee872e229e9f1fc681bdbd20d923389f1fa6aaf89f9aee93af4fbf.css integrity="sha256-yx7R2tPuhy4inp8fxoG9vSDZIzifH6aq+J+a7pOvT78=" crossorigin=anonymous><link rel=stylesheet href=/css/bundle.min.4878d16c866148ae8cfd6f4f44052d25f2548b24ab4a9bc857279dc6d06df2b5.css integrity="sha256-SHjRbIZhSK6M/W9PRAUtJfJUiySrSpvIVyedxtBt8rU=" crossorigin=anonymous><script src=/js/bundle.995e4ec99401021e081ec256bee66154ef7f4e5136809432513b2e6d014b4b1d.js integrity="sha256-mV5OyZQBAh4IHsJWvuZhVO9/TlE2gJQyUTsubQFLSx0=" crossorigin=anonymous></script><script defer src=/js/search/flexsearch.compact.64594b125f7b78bdf4fa8316955922bbebb1cd6baef3f16654bfca20309f18f8.js integrity="sha256-ZFlLEl97eL30+oMWlVkiu+uxzWuu8/FmVL/KIDCfGPg="></script><script defer src=/js/search/search.1d980f84df11f3eb7c8c5f17f541d49a0611608df179dd74fa7f06225eb56ace.js integrity="sha256-HZgPhN8R8+t8jF8X9UHUmgYRYI3xed10+n8GIl61as4="></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:opsz,wght@12..96,200..800&family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel=stylesheet></head><body class=notransition><div id=container><header id=main-header><div role=navigation aria-label=Main><div class=nav-left><a href=https://chhz0.github.io/ style=color:inherit>ch.hugo</a></div><div class=nav-right><div style=position:absolute;width:0;height:0><div id=nav-dropdown-menu class=hidden href=#><div class=nav-item><a href=/blogs/>博客</a></div><div class=nav-item><a aria-current=true class=ancestor href=/notes/>笔记</a></div><div class=nav-item><a href=/about/>关于</a></div></div></div><a id=nav-dropdown-button href=#><svg width="20" height="20" viewBox="0 0 24 24" fill="none"><path d="M4 6H20M4 12H20M4 18H20" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></a><div id=nav-menu><div class=nav-item><a href=/blogs/>博客</a></div><div class=nav-item><a aria-current=true class=ancestor href=/notes/>笔记</a></div><div class=nav-item><a href=/about/>关于</a></div></div><a id=theme-switcher href=#><svg class="light-icon" viewBox="0 0 24 24" fill="none"><path d="M12 3V4m0 16v1M4 12H3M6.31412 6.31412 5.5 5.5m12.1859.81412L18.5 5.5M6.31412 17.69 5.5 18.5001M17.6859 17.69 18.5 18.5001M21 12H20m-4 0c0 2.2091-1.7909 4-4 4-2.20914.0-4-1.7909-4-4 0-2.20914 1.79086-4 4-4 2.2091.0 4 1.79086 4 4z" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
<svg class="dark-icon" viewBox="0 0 24 24" fill="none"><path d="M3.32031 11.6835c0 4.9706 4.02944 9 8.99999 9 3.7872.0 7.028-2.3392 8.3565-5.6515C19.6402 15.4486 18.5059 15.6834 17.3203 15.6834c-4.9706.0-8.99999-4.0294-8.99999-8.99998C8.32031 5.50338 8.55165 4.36259 8.96453 3.32996 5.65605 4.66028 3.32031 7.89912 3.32031 11.6835z" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
</a>|
<a id=theme-switcher href=https://github.com/chhz0 aria-label=GitHub><svg class="light-icon" width="800" height="800" viewBox="0 0 20 20" xmlns:xlink="http://www.w3.org/1999/xlink"><title>github [#142]</title><desc>Created with Sketch.</desc><defs/><g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="Dribbble-Light-Preview" transform="translate(-140.000000, -7559.000000)" fill="#fff"><g id="icons" transform="translate(56.000000, 160.000000)"><path d="M94 7399C99.523 7399 104 7403.59 104 7409.253 104 7413.782 101.138 7417.624 97.167 7418.981 96.66 7419.082 96.48 7418.762 96.48 7418.489 96.48 7418.151 96.492 7417.047 96.492 7415.675 96.492 7414.719 96.172 7414.095 95.813 7413.777 98.04 7413.523 100.38 7412.656 100.38 7408.718 100.38 7407.598 99.992 7406.684 99.35 7405.966 99.454 7405.707 99.797 7404.664 99.252 7403.252 99.252 7403.252 98.414 7402.977 96.505 7404.303 95.706 7404.076 94.85 7403.962 94 7403.958 93.15 7403.962 92.295 7404.076 91.497 7404.303 89.586 7402.977 88.746 7403.252 88.746 7403.252 88.203 7404.664 88.546 7405.707 88.649 7405.966 88.01 7406.684 87.619 7407.598 87.619 7408.718 87.619 7412.646 89.954 7413.526 92.175 7413.785 91.889 7414.041 91.63 7414.493 91.54 7415.156 90.97 7415.418 89.522 7415.871 88.63 7414.304 88.63 7414.304 88.101 7413.319 87.097 7413.247 87.097 7413.247 86.122 7413.234 87.029 7413.87 87.029 7413.87 87.684 7414.185 88.139 7415.37 88.139 7415.37 88.726 7417.2 91.508 7416.58 91.513 7417.437 91.522 7418.245 91.522 7418.489 91.522 7418.76 91.338 7419.077 90.839 7418.982 86.865 7417.627 84 7413.783 84 7409.253 84 7403.59 88.478 7399 94 7399" id="github-[#142]"/></g></g></g></svg><svg class="dark-icon" width="800" height="800" viewBox="0 0 20 20" xmlns:xlink="http://www.w3.org/1999/xlink"><title>github [#142]</title><desc>Created with Sketch.</desc><defs/><g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="Dribbble-Light-Preview" transform="translate(-140.000000, -7559.000000)" fill="#000"><g id="icons" transform="translate(56.000000, 160.000000)"><path d="M94 7399C99.523 7399 104 7403.59 104 7409.253 104 7413.782 101.138 7417.624 97.167 7418.981 96.66 7419.082 96.48 7418.762 96.48 7418.489 96.48 7418.151 96.492 7417.047 96.492 7415.675 96.492 7414.719 96.172 7414.095 95.813 7413.777 98.04 7413.523 100.38 7412.656 100.38 7408.718 100.38 7407.598 99.992 7406.684 99.35 7405.966 99.454 7405.707 99.797 7404.664 99.252 7403.252 99.252 7403.252 98.414 7402.977 96.505 7404.303 95.706 7404.076 94.85 7403.962 94 7403.958 93.15 7403.962 92.295 7404.076 91.497 7404.303 89.586 7402.977 88.746 7403.252 88.746 7403.252 88.203 7404.664 88.546 7405.707 88.649 7405.966 88.01 7406.684 87.619 7407.598 87.619 7408.718 87.619 7412.646 89.954 7413.526 92.175 7413.785 91.889 7414.041 91.63 7414.493 91.54 7415.156 90.97 7415.418 89.522 7415.871 88.63 7414.304 88.63 7414.304 88.101 7413.319 87.097 7413.247 87.097 7413.247 86.122 7413.234 87.029 7413.87 87.029 7413.87 87.684 7414.185 88.139 7415.37 88.139 7415.37 88.726 7417.2 91.508 7416.58 91.513 7417.437 91.522 7418.245 91.522 7418.489 91.522 7418.76 91.338 7419.077 90.839 7418.982 86.865 7417.627 84 7413.783 84 7409.253 84 7403.59 88.478 7399 94 7399" id="github-[#142]"/></g></g></g></svg></a></div></div></header><div class="flex grow"><div id=main-pane><main id=main-content><div class=single-header><ol class=breadcrumbs itemscope itemtype=https://schema.org/BreadcrumbList><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://chhz0.github.io/><span itemprop=name>Home</span>
</a><meta itemprop=position content='1'></li><span>&nbsp»&nbsp</span><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://chhz0.github.io/notes/><span itemprop=name>Notes</span>
</a><meta itemprop=position content='2'></li><span>&nbsp»&nbsp</span><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://chhz0.github.io/notes/database/><span itemprop=name>Database</span>
</a><meta itemprop=position content='3'></li><span>&nbsp»&nbsp</span><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://chhz0.github.io/notes/database/mysql/><span itemprop=name>MySQL</span>
</a><meta itemprop=position content='4'></li><span>&nbsp»&nbsp</span></ol><h1>Mysql Log(bate)</h1><time class=dim datetime=2025-07-03T23:16:14+08:00>July 3, 2025</time><div class=term-container><div class=tag><a href=https://chhz0.github.io/tags/mysql/>#MySQL</a></div></ol></div><section class=page-section><blockquote><p>MySQL 日志 - undo log | redo log | bin log</p></blockquote><p>先理解执行一条sql语句，在mysql内部会发生什么？</p><p>以执行一条<code>update</code> 语句为例：</p><ul><li><p>客户端会先通过连接器建立连接，连接器会判断用户身份</p></li><li><p>这里是一条update语句，所以不需要经过查询缓存（注意，当表上有更新语句，会把整个查询缓存清空，所以在Mysql8.0这个功能就被移除了）</p></li><li><p>解析器会通过词法分析识别出关键字，构建出语法树，接着做语法分析，判断输入的语句是否符合MySQL语法</p></li><li><p>预处理器会判断表和字段是否存在</p></li><li><p>优化器确定执行计划（使用索引或者全表查询）</p></li><li><p>执行器负责具体执行，找到这一行然后更新</p></li></ul><p>不过，更新语句的流程会涉及到<strong>undo</strong> <strong>log</strong>**，redo log，binlog**三种日志：</p><ul><li><p>undo log（回滚日志）：是InnoDB存储引擎生成的日志，实现了事务中的<strong>原子性</strong>，主要用于事务回滚和MVCC</p></li><li><p>redo log（重做日志）：是InnoDB存储引擎生成的日志，实现了事务中的<strong>持久性</strong>，主要用于掉电等故障恢复</p></li><li><p>bing log（归档日志）：是Server层生成的日志，主要用于数据备份和主从复制</p></li></ul><h2 id=1为什么需要undo-log>1.为什么需要undo log？</h2><p>在执行一条“增删改”语句的时候，MySQL会隐式开启事务，执行完后自动提交事务</p><blockquote><p>MySQL中执行一条语句后是否自动提交事务，是由<code>autocommit</code> 参数来决定的，默认是开启的</p></blockquote><p>当事务执行过程中，都记录下回滚时需要的信息到一个日志中，那么在事务执行过程中发生MySQL崩溃后，可以通过这个日志回滚到事务之前的数据</p><p>实现这一机制就是 <strong>undo</strong> <strong>log</strong>**（回滚日志），它保证了事务的<strong><strong>ACID</strong></strong>特性中的原子性**</p><p>每当InnoDB引擎对每种操作进行回滚时，进行相反操作就行：</p><ul><li><p>插入 - 删除</p></li><li><p>删除 - 插入</p></li><li><p>更新 - 更新为旧值</p></li></ul><p>一条记录每次进行操作产生的undo log格式都有一个roll_pointer和一个trx_id事务id：</p><ul><li><p>trx_id：记录该记录是被哪些事务修改的</p></li><li><p>roll_pointer：指针可以将这些undo log串成一个链表，这个链表被称为版本链</p></li></ul><p><img src="https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=N2UyNDE0NmNmNDU2N2UyY2Q5NDJkYzZiNzAwMzY3OTRfUjh5Zmw4d3VoWFI5VGZnaFR2a0NsVWk0bVdPTEM2WW5fVG9rZW46V3FmemIzbkhQb1BkRjB4UGFLbWNwR2RpbkRLXzE3MjE4NDExMjk6MTcyMTg0NDcyOV9WNA" alt></p><p>另外，undo log可以跟Read View一起实现MVCC（多版本并发控制）：</p><p>对于 <strong>读提交</strong> 和 <strong>可重复读</strong> 隔离级别的事务来说，它们的快照读（普通select语句）是通过Read View + undo log来实现的，区别在于创建Read View的时机不同</p><ul><li><p>读提交：是在每一个select都会生成一个新的Read View，也意味着事务期间的多次读取同一数据，前后两次读的数据可能会出现不一致（不可重复读）</p></li><li><p>可重复读：是在启动事务时生成一个Read View，然后整个事务期间都在用这个Read View，这样保证了事务期间读到的数据都是事务启动时的记录</p></li></ul><p>这两个隔离级别实现是通过事务的Read View里的字段和记录两个隐藏列trx_id和roll_pointer的对比</p><p><a href=https://xiaolincoding.com/mysql/transaction/mvcc.html#%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B>事务隔离级别是怎么实现的？</a></p><p>因此，undo log两大作用：</p><ul><li><p>实现事务回滚，保障事务的原子性</p></li><li><p>实现MVCC（多版本并发控制）关键因素之一</p></li></ul><blockquote><p>Undo log是如何刷盘？</p><p>Undo log和数据页的刷盘策略是一样的，都需要通过redo log保证持久化</p><p>Buffer pool中有undo 页，对undo页的修改都会被记录到redo log。redo log每秒刷盘，提交事务时也会刷盘，数据页和undo 页都是靠这个机制保证持久化</p></blockquote><h2 id=2为什么需要buffer-pool>2.为什么需要Buffer Pool？</h2><p>MySQL的数据都是存储在磁盘中的，那么我们更新一条记录，得先从磁盘读取该记录，然后在内存中修改记录，修改完之后并不会直接写回磁盘，而是缓存起来，这样下次查询语句命中这条记录，就不需要从磁盘读取数据</p><p>为此，InnoDB存储引擎设计了一个**缓冲池****Buffer Pool，**来提高数据库的读写性能</p><p>暂时无法在飞书文档外展示此内容</p><p>有了Buffer Pool后：</p><ul><li><p>当读取数据时，如果数据存在于Buffer Pool中，客户端会直接读取Buffer Pool中的数据，否则再去磁盘中读取</p></li><li><p>当修改数据时，如果数据存在Buffer Pool中，那么直接修改Buffer Pool中数据所在的页，然后将页设置为<strong>脏页****（<strong>该页上的数据和磁盘上的不一样</strong>）</strong>，为了减少磁盘I/O，不会立即将脏页写入磁盘，后续由后台线程选择以一个合适的时机将脏页写入到磁盘</p></li></ul><h3 id=buffer-pool缓冲了什么>Buffer Pool缓冲了什么？</h3><p>InnoDB会把存储的数据划分为若干个页，以页为磁盘和内存交互的基本单位，一个页的默认大小为<strong>16K</strong></p><p>Buffer Pool同样按 页 来划分</p><p>在MySQL启动的时候，<strong>InnoDB会为Buffer Pool申请一片连续的<strong><strong>内存</strong></strong>空间，然后按照默认的</strong>**<code>16k</code>** <strong>的大小划分一个个的页，Buffer Pool中的页叫做缓冲页</strong>。</p><p>Buffer Pool除了缓存索引页和数据页，还包括Undo页，插入缓存，自适应哈希索引，锁信息等</p><blockquote><p>Undo 页是记录什么？</p></blockquote><p>开启事务后，InnoDB层更新记录前，首先要记录相应的undo log，如果是更新操作，需要把被更新的列的旧值记下来，也就是生成一个undo log，undo log会写入到undo页面</p><blockquote><p>查询一条记录，就只需要缓存一条记录吗？</p></blockquote><p>不是，当查询一条记录的时候，InnoDB会将整个页的数据加载到Buffer Pool中，将页加载到Buffer Pool后，再通过页里的页目录去定位到某条具体的记录 <a href=https://mp.weixin.qq.com/s/A5gNVXMNE-iIlY3oofXtLw>换一个角度看B+树</a></p><h2 id=3为什么需要-redo-log>3.为什么需要 redo log？</h2><p>Buffer Pool是提高了读写效率，但是Buffer Pool是基于内存的，而内存总是不可靠，出现断电重启时内存里没来得及落盘的脏页数据就会丢失</p><p>为了防止断电导致数据丢失，当一条记录需要更新，InnoDB就会先更新内存（同时标记为脏读页），然后将本次对这个页的修改以redo log的形式记录下来，这时候才算更新完成</p><p>后续，InnoDB引擎会在适合的适合，由后台线程将Buffer Pool的脏页刷新到磁盘里，这个就是<strong>WAL****（Write-Ahead-Logging）技术</strong></p><p>WAL技术指的是，MySQL的写操作并不是立刻写到磁盘上面，而是先写日志，然后在合适的时间再写到磁盘上。</p><h3 id=什么是redo-log>什么是redo log？</h3><p>redo log是物理日志，记录了某个数据页做了什么修改，每当执行一个事务就会产生这样的一条或者多条物理日志</p><p>在事务提交的时候，只要先将redo log持久化到磁盘即可，可以不需要等待到将缓存在Buffer Pool里的脏页数据持久化到磁盘</p><p>当系统崩溃时，虽然脏页数据没有持久化，但是redo log语句持久化了，接着Mysql重启后，可以根据redo log的内容，将所有数据恢复到最新的状态</p><h3 id=被修改undo页面需要记录对应redo-log吗>被修改undo页面，需要记录对应redo log吗？</h3><p>需要的。</p><p>开启事务后，InnoDB层要更新记录前，首先要记录相应的undo log，如果是更新操作，需要把被更新的列的旧值记下来，也就是生成一条undo log，undo log会写入Buffer Pool中的Undo页面</p><p>不过，在内存修改该undo页面后，需要记录对应的redo log</p><h3 id=redo-log和undo-log区别在哪里>redo log和undo log区别在哪里？</h3><p>这两种日志都是InnoDB引擎下的日志，它们的区别在于：</p><ul><li><p>redo log记录了事务完成后的数据状态，记录的是更新<strong>之后</strong>的值；</p></li><li><p>undo log记录了事务开始前的数据状态，记录的是更新<strong>之前</strong>的值；</p></li></ul><p>当事务提交之前发生崩溃，重启后会通过undo log回滚事务，事务提交之后发生崩溃，重启后会通过redo log恢复事务</p><p>暂时无法在飞书文档外展示此内容</p><p>有了redo log，再通过WAL技术，InnoDB可以保证即使数据库发生异常重启后，之前已提交的记录都不会丢失，这个能力就是 <strong>crash-safe（崩溃恢复）</strong></p><p><strong>redo</strong> <strong>log****保证了事务四大特性中的持久性</strong></p><h3 id=redo-log要写磁盘数据也要写磁盘为什么要多次一举>redo log要写磁盘，数据也要写磁盘，为什么要多次一举？</h3><p>写入redo log的方式是由了追加操作，所以磁盘操作是<strong>顺序写</strong>，而写入数据需要先找到写入位置，然后才写到磁盘，所以磁盘操作是<strong>随机写</strong></p><p>磁盘的顺序写比随机写要高效得多，因此redo log写入磁盘的开销更小</p><blockquote><p>可以说，这是WAL技术的另外一个优点：<strong>MySQL****的写操作从磁盘的随机写变成了顺序写</strong></p></blockquote><p>至此，针对为什么需要redo log这个问题我们有两个答案：</p><ul><li><p>实现事务的持久性，让MySQL有crash-safe能力</p></li><li><p>将写操作从随机写到顺序写，提高MySQL写入磁盘的性能</p></li></ul><h3 id=产生的redo-log是直接写入磁盘的吗>产生的redo log是直接写入磁盘的吗</h3><p>不是，redo log也有自己的缓存——redo log buffer，每当产生redo log时，会先写入到redo log buffer，后续再持久化到磁盘：</p><p><img src="https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=NWZkOGM0MWMyMWYxMjhkZWI5NTY0NzllOGRhNjIwMmRfZk9LZ1FlN0FwR2I3d1lGMVQ1dHNsdTBqTUpUOGp0ZE5fVG9rZW46WGdITGJ4U3RNb1NtQXp4NkRrR2NwMGJJbk9HXzE3MjE4NDExMjk6MTcyMTg0NDcyOV9WNA" alt></p><p>Redo log buffer默认的大小是16MB，可以通过<code>innodb_log_Buffer_size</code> 参数动态的调整大小，增大它的大小可以让MySQL处理大事务时不必写入磁盘，进而提高IO性能</p><h3 id=redo-log什么时候刷盘>redo log什么时候刷盘？</h3><p>缓存在redo log buffer里的redo log还是在内存中，它会在以下的时机刷新到磁盘</p><ol><li><p>MySQL正常关闭时</p></li><li><p>当redo log buffer中记录的写入量大于redo log buffer内存空间一半时，就会触发落盘</p></li><li><p>InnoDB的后台线程每隔1s，将redo log buffer持久到磁盘</p></li><li><p>每次事务提交时都将缓存在redo log buffer里的redo log直接持久化到磁盘（这个策略可以通过<code>innodb_flush_log_at_trx_commit</code> 参数控制）</p></li></ol><h4 id=innodb_flush_log_at_trx_commit-参数控制的时候什么><code>innodb_flush_log_at_trx_commit</code> 参数控制的时候什么？</h4><ol><li><p>设置<strong>参数为0</strong>时，表示每次事务提交时，还是将redo log留在redo log buffer，该模式下事务提交时不主动触发写入到磁盘的操作</p></li><li><p>设置<strong>参数为1</strong>时，表示每次事务提交时，都将缓存在redo log buffer里的redo log直接持久化到磁盘，这样可以保证MySQL异常重启之后的数据不会丢失</p></li><li><p>设置<strong>参数为2</strong>时，表示每次事务提交时，都只是缓存在redo log buffer里的redo log写到redo log文件，注意写入到 redo log文件并不意味着写入到了磁盘，而是写入到了Page Cache，就行写入到了操作系统的文件缓存</p></li></ol><h4 id=innodb_flush_log_at_trx_commit-为0和2时什么时候才将redo-log写入磁盘><code>innodb_flush_log_at_trx_commit</code> 为0和2时，什么时候才将redo log写入磁盘？</h4><p>InnoDB的后台线程每隔1s：</p><ul><li><p>针对参数0：会把缓存在redo log buffer中的redo log，通过write()写到操作系统的Page cache，然后调用<code>fsync()</code> 持久化到磁盘。所以参数为0的策略，MySQL进程崩溃会导致上一秒所有事务数据的丢失</p></li><li><p>正对参数2：调用<code>fsync()</code> ，将缓存在操作系统中Page Cache里的redo log持久化到磁盘，所以参数为2的策略，较取值为0情况下更安全，因为MySQL进程的崩溃并不会丢失数据，只有在操作系统崩溃或者系统断电的情况下，上一秒所有的事务数据才可能丢失</p></li></ul><h4 id=innodb_flush_log_at_trx_commit-三个参数的应用场景是什么><code>innodb_flush_log_at_trx_commit</code> 三个参数的应用场景是什么？</h4><h3 id=redo-log-文件写满了怎么办>redo log 文件写满了怎么办？</h3><p>默认情况下，innoDB存储引擎有一个重做日志文件组（redo log Group），重做日志文件组由2个redo log文件组成，这两个redo 日志的文件名叫：<code>ib_logfile0</code> 和<code>ib_logfile1</code></p><p>在重做日志组中，每个redo log file的大小都是固定且一致的</p><p>重做日志组是以<strong>循环写</strong>的方式工作，从头开始写，写到末尾就回到开头，相当于一个环形</p><p>InnoDB存储引擎会先写ib_logfile0文件，当ib_logfile0文件被写满的时候，会切换至ib_logfile1文件，1写满时会被切换到0文件</p><p><img src="https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjdjMzNlNWY1NWM3ODY5M2E4YjcyMGNmZTAzMjE5YjNfSWVEbHpwZGNLMjA5NDBVTjd6YTQxbVd1QUw1UHRKSWVfVG9rZW46Tk5oQmJjNU5mb3F0RUd4djR3SWMwaGZQbmZkXzE3MjE4NDExMjk6MTcyMTg0NDcyOV9WNA" alt></p><p>redo log是为了防止Buffer Pool中的脏页丢失而设计的，那么随着系统运行，Buffer Pool的脏页刷新到了磁盘，那么redo log对应的记录也就没有了</p><p>redo log是循环写的方式，相当于一个环形，InnoDB用Write pos表示redo log当前记录写到的位置，用checkpoint表示当前要擦除的位置</p><ul><li><p>write pos和check point的移动都是顺时针方向</p></li><li><p>write pos ~ check point之间的部分（红色），用来记录新的更新记录</p></li><li><p>check point ~ write pos 之间的部分（蓝色），待落盘的脏数据页记录</p></li></ul><p>如果write pos追上checkpoint，就意味着redo log文件满了，这时MySQL不能再执行新的更新操作，也就是MySQL会发生阻塞（因此针对并发量大的系统，适当增大redo log文件的大小非常重要），此时会停下来将Buffer Pool中的脏页刷新到磁盘中，然后标记redo log哪些记录可以被擦除，接着对旧的redo log记录进行擦除，等擦除完旧记录腾出空间，checkpoint就会往后移动，MySQL恢复正常运行，继续执行新的更新操作</p><h2 id=4为什么需要binlog>4.为什么需要binlog？</h2><p>前面的undo log和redo log都是InnoDB存储引擎生成的日志</p><p>MySQL在完成一条更新操作后，Server层还会生成一条binlog，等之后事务提交的时候，会将事务执行过程中产生的所有binlog统一写入binlog文件</p><p><strong>binlog文件记录了所有数据库表结构变更和表数据修改的日志，不会记录查询类的操作</strong></p><blockquote><p>为什么有了binlog，还要redo log？</p><p>因为最开始MySQL只有MyISAM引擎，没有InnoDB引擎，但是MyISAM没有crash-safe的能力，binlog日志只能用于归档</p><p>而InnoDB是另外一个公司以插件的形式引入MySQL的，既然只依靠binlog是没有crash-safe能力的，所以InnoDB使用redo log来实现crash-safe能力</p></blockquote><h3 id=redolog-和-binlog有什么区别>redolog 和 binlog有什么区别？</h3><p>Redolog 和 binlog有四个区别：</p><ol><li><p>适用对象不同：</p><ol><li><p>binlog 是MySQL的Server层实现的日志，所有的引擎都可以使用</p></li><li><p>redolog 是InnoDB存储引擎实现的日志</p></li></ol></li><li><p>文件格式不同：</p><ol><li><p>binlog有3种格式类型，分别是STATEMENT、ROW、MIXED区别如下：</p><ol><li><p>STATEMENT：每一条修改数据的SQL都会记录到binlog中（相当于记录了逻辑操作，所以针对这种格式，binlog可以称为逻辑日志）</p></li><li><p>ROW：</p></li><li><p>MIXED：</p></li></ol></li><li><p>redolog是物理日志，记录的是在某个数据页做了什么修改。</p></li></ol></li><li><p>写入方式不同：</p><ol><li><p>binlog是追加写，写满一个文件，就创建一个新文件继续写，不会覆盖以前的日志，保存的是全量的日志</p></li><li><p>redolog是循环写，日志空间大小是固定的，全部写满从头开始，保存未被刷入磁盘的脏页日志</p></li></ol></li><li><p>用途不同：</p><ol><li><p>binlog用于备份恢复，主从复制</p></li><li><p>redolog用于掉电等故障恢复</p></li></ol></li></ol><blockquote><p>不小心整个数据库的数据删除了，能用redo log文件恢复数据吗？</p></blockquote><p>不可以使用redo log文件恢复，只能使用binlog文件恢复</p><p>因为redo log文件是循环写，是会边写边擦日志的，只记录未被刷入磁盘的数据的物理日志，已经刷入磁盘的数据都会被从redolog文件里擦除</p><p>binlog文件保存的是全量的日志，也就是保存了所有数据变更的情况，理论上只要记录在binlog上的数据，都可以恢复</p><h3 id=主从复制是怎么实现的>主从复制是怎么实现的？</h3><p>MySQL的主从复制依赖于binlog，记录MySQL上的所有变化以二进制形式保存在磁盘上，复制的过程就是将binlog中的数据从主库传输到从库上</p><p>这个过程一般是<strong>异步的</strong></p><p><img src="https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=MDY1NzhiNGE0NTI2OTVmZWRhMzAyNTBhMzA5MDk2MjZfNzR1V3ZUR1JJdEUyZVd0WGFJSDVvQjJ2aFJadnhjWmlfVG9rZW46UWFwTGJoaldrb1NSV0Z4SFp0bWNIZkU3bkNnXzE3MjE4NDExMjk6MTcyMTg0NDcyOV9WNA" alt></p><p>MySQL集群的主从复制过程大致三阶段：</p><ul><li><p>写入binlog：主库写binlog日志，提交事务，并更新本地存储数据</p></li><li><p>同步binlog：把binlog复制到所有从库上，每个从库把binlog写到暂存日志中</p></li><li><p>回放binlog：回放binlog，并更新存储引擎中的数据</p></li></ul><p>具体详细过程如下：</p><ul><li><p>MySQL 主库在收到客户端提交事务的请求之后，会先写入 binlog，再提交事务，更新存储引擎中的数据，事务提交完成后，返回给客户端“操作成功”的响应。</p></li><li><p>从库会创建一个专门的 I/O 线程，连接主库的 log dump 线程，来接收主库的 binlog 日志，再把 binlog 信息写入 relay log 的中继日志里，再返回给主库“复制成功”的响应。</p></li><li><p>从库会创建一个用于回放 binlog 的线程，去读 relay log 中继日志，然后回放 binlog 更新存储引擎中的数据，最终实现主从的数据一致性。</p></li></ul><p><img src="https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmY5YWQzYmMzOTExMzJhNThjODQ5YmZiYzI2ZDI2MDhfanhNN1VMQUFueUNoQmdUSW81eGRlVFlIWmxVSlhrTTBfVG9rZW46R3E3SmJ3TjdYb21hTTB4SnBjaGNYTHpVblJlXzE3MjE4NDExMjk6MTcyMTg0NDcyOV9WNA" alt></p><blockquote><p>从库是不是越多越好</p></blockquote><p>不是，从库的数据增加，从库连接上来的I/O线程就越多，<strong>主库建立同样多的log dump线程来处理复制的请求，对主库资源消耗比较高，同时还限制于主库的网络带宽</strong></p><p>在实际使用中，一般一主跟2~3从库</p><blockquote><p>MySQL主从复制还有哪些模型</p></blockquote><ul><li><p>同步复制</p></li><li><p>异步复制</p></li><li><p>半同步复制</p></li></ul><h3 id=binlog是什么时候刷盘>binlog是什么时候刷盘？</h3><h2 id=5为什么需要两阶段提交>5.为什么需要两阶段提交？</h2><h3 id=两阶段提交的过程是怎样的>两阶段提交的过程是怎样的？</h3><h3 id=重启异常会出现什么现象>重启异常会出现什么现象？</h3></section></main><footer id=main-footer><div class=footer><a href=#>回到顶部 ↑</a><div class=footer-copyright><div>© 2025 Chen-Hang</div><div>powered by <a href=https://github.com/math-queiroz/rusty-typewriter target=_blank>Rusty Typewriter</a> theme for <a href=https://gohugo.io/ target=_blank>Hugo</a></div></div></div></footer></div><aside id=side-pane class=side-sticky><div class=side-details><span>4474 字数</span>
<span>16 - 21 阅读时间</span><div class=side-details-taxonomy><small>categories:
<span class=details-taxonomy><a href=https://chhz0.github.io/categories/note>Note</a></span></small></div></div><h3>目录</h3><nav id=TableOfContents><ul><li><a href=#1为什么需要undo-log>1.为什么需要undo log？</a></li><li><a href=#2为什么需要buffer-pool>2.为什么需要Buffer Pool？</a><ul><li><a href=#buffer-pool缓冲了什么>Buffer Pool缓冲了什么？</a></li></ul></li><li><a href=#3为什么需要-redo-log>3.为什么需要 redo log？</a><ul><li><a href=#什么是redo-log>什么是redo log？</a></li><li><a href=#被修改undo页面需要记录对应redo-log吗>被修改undo页面，需要记录对应redo log吗？</a></li><li><a href=#redo-log和undo-log区别在哪里>redo log和undo log区别在哪里？</a></li><li><a href=#redo-log要写磁盘数据也要写磁盘为什么要多次一举>redo log要写磁盘，数据也要写磁盘，为什么要多次一举？</a></li><li><a href=#产生的redo-log是直接写入磁盘的吗>产生的redo log是直接写入磁盘的吗</a></li><li><a href=#redo-log什么时候刷盘>redo log什么时候刷盘？</a></li><li><a href=#redo-log-文件写满了怎么办>redo log 文件写满了怎么办？</a></li></ul></li><li><a href=#4为什么需要binlog>4.为什么需要binlog？</a><ul><li><a href=#redolog-和-binlog有什么区别>redolog 和 binlog有什么区别？</a></li><li><a href=#主从复制是怎么实现的>主从复制是怎么实现的？</a></li><li><a href=#binlog是什么时候刷盘>binlog是什么时候刷盘？</a></li></ul></li><li><a href=#5为什么需要两阶段提交>5.为什么需要两阶段提交？</a><ul><li><a href=#两阶段提交的过程是怎样的>两阶段提交的过程是怎样的？</a></li><li><a href=#重启异常会出现什么现象>重启异常会出现什么现象？</a></li></ul></li></ul></nav><h3>相关</h3><ul><li><a href=/notes/database/mysql/mysql-lock/>Mysql Lock(bate)</a></li><li><a href=/notes/database/mysql/mysql-index/>Mysql Index(bate)</a></li><li><a href=/notes/database/mysql/mysql-buffer-pool/>Mysql Buffer Pool(bate)</a></li><li><a href=/notes/database/mysql/mysql-arch/>Mysql Arch(bate)</a></li><li><a href=/notes/database/mysql/todo/>MySQL - Todo</a></li></ul></aside></div></div></body></html>