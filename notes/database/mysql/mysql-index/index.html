<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Mysql Index(bate) | ch.hugo</title>
<link rel=icon href=favicon.svg sizes=any type=image/svg+xml><meta property="og:url" content="https://chhz0.github.io/notes/database/mysql/mysql-index/"><meta property="og:site_name" content="ch.hugo"><meta property="og:title" content="Mysql Index(bate)"><meta property="og:description" content="MySQL 索引
1. B+树（索引数据结构） 什么是索引？ 为什么索引能加快查询？ 索引的数据结构是什么？ B+ 树 和（B 树 和 红黑树）有什么区别？ 为什么选择 B+树 作为索引数据结构？
为什么Mysql InnoDB选择B+ Tree作为索引？ B+ 树 vs B 树 B+ 树只在叶子节点存储数据，B树的非叶子节点也要存储数据，所以B+ 树的单个节点的数据量更小 B+ 树 vs 二叉树 对于有N个叶子节点的B+ 树，搜索复制度为O（logdn） B+ 树 vs Hash 08 索引:排序的艺术
为什么 MySQL 采用 B+ 树作为索引？
2. 索引组织表（索引存储） 堆表和索引组织表有什么区别？
分别应用场景是什么？
Mysql InnoDB存储引擎中数据存储方式：索引组织表
数据存储有堆表和索引组织表两种。
堆表中的数据是无序存放的，数据的排序完全依赖索引
索引组织表，数据根据主键进行排序存放在索引中，主键索引也叫聚集索引（Clustered Index）
在索引组织表中，数据即索引，索引即数据
二级索引 InnoDB存储引擎的数据是根据主键索引排序存储的，除了主键索引外，其它的索引都称为二级索引（Secondeary Index），或者非聚集索引
二级索引也是一颗B+树索引，但是它和主键索引不同的是叶子节点存放的是索引键值、主键值
通过二级索引idx_name 只能定位主键值，需要额外再通过主键索引进行查询，才能得到最终结果。
这种二级索引通过主键索引进行再一次查询的操作叫做“回表”
这样的二级索引设计的好处：若记录发生了修改，则其它索引无须进行维护，除非记录的主键发生了修改
在索引组织表中，万物皆索引，索引就是数据，数据就是索引。
二级索引的性能评估 要比较顺序，对聚集索引性能友好
尽可能紧凑，对二级索引的性能和存储友好
函数索引（先了解） …"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="notes"><meta property="article:published_time" content="2025-07-03T23:16:07+08:00"><meta property="article:modified_time" content="2025-07-03T23:16:07+08:00"><meta property="article:tag" content="MySQL"><meta name=twitter:card content="summary"><meta name=twitter:title content="Mysql Index(bate)"><meta name=twitter:description content="MySQL 索引
1. B+树（索引数据结构） 什么是索引？ 为什么索引能加快查询？ 索引的数据结构是什么？ B+ 树 和（B 树 和 红黑树）有什么区别？ 为什么选择 B+树 作为索引数据结构？
为什么Mysql InnoDB选择B+ Tree作为索引？ B+ 树 vs B 树 B+ 树只在叶子节点存储数据，B树的非叶子节点也要存储数据，所以B+ 树的单个节点的数据量更小 B+ 树 vs 二叉树 对于有N个叶子节点的B+ 树，搜索复制度为O（logdn） B+ 树 vs Hash 08 索引:排序的艺术
为什么 MySQL 采用 B+ 树作为索引？
2. 索引组织表（索引存储） 堆表和索引组织表有什么区别？
分别应用场景是什么？
Mysql InnoDB存储引擎中数据存储方式：索引组织表
数据存储有堆表和索引组织表两种。
堆表中的数据是无序存放的，数据的排序完全依赖索引
索引组织表，数据根据主键进行排序存放在索引中，主键索引也叫聚集索引（Clustered Index）
在索引组织表中，数据即索引，索引即数据
二级索引 InnoDB存储引擎的数据是根据主键索引排序存储的，除了主键索引外，其它的索引都称为二级索引（Secondeary Index），或者非聚集索引
二级索引也是一颗B+树索引，但是它和主键索引不同的是叶子节点存放的是索引键值、主键值
通过二级索引idx_name 只能定位主键值，需要额外再通过主键索引进行查询，才能得到最终结果。
这种二级索引通过主键索引进行再一次查询的操作叫做“回表”
这样的二级索引设计的好处：若记录发生了修改，则其它索引无须进行维护，除非记录的主键发生了修改
在索引组织表中，万物皆索引，索引就是数据，数据就是索引。
二级索引的性能评估 要比较顺序，对聚集索引性能友好
尽可能紧凑，对二级索引的性能和存储友好
函数索引（先了解） …"><link rel=stylesheet href=/css/components.min.9d886688d3ae94cecf1b057e706bf74497fcd5cea352d433c34cda3b9425a8d4.css integrity="sha256-nYhmiNOulM7PGwV+cGv3RJf81c6jUtQzw0zaO5QlqNQ=" crossorigin=anonymous><link rel=stylesheet href=/css/main.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css integrity="sha256-47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=" crossorigin=anonymous><link rel=stylesheet href=/css/root.min.1677bc99f2421f7cb9fc1d00b09addcc951fd9d4c785e22b20ed55c0602786fc.css integrity="sha256-Fne8mfJCH3y5/B0AsJrdzJUf2dTHheIrIO1VwGAnhvw=" crossorigin=anonymous><link rel=stylesheet href=/css/search.min.cb1ed1dad3ee872e229e9f1fc681bdbd20d923389f1fa6aaf89f9aee93af4fbf.css integrity="sha256-yx7R2tPuhy4inp8fxoG9vSDZIzifH6aq+J+a7pOvT78=" crossorigin=anonymous><link rel=stylesheet href=/css/bundle.min.4878d16c866148ae8cfd6f4f44052d25f2548b24ab4a9bc857279dc6d06df2b5.css integrity="sha256-SHjRbIZhSK6M/W9PRAUtJfJUiySrSpvIVyedxtBt8rU=" crossorigin=anonymous><script src=/js/bundle.995e4ec99401021e081ec256bee66154ef7f4e5136809432513b2e6d014b4b1d.js integrity="sha256-mV5OyZQBAh4IHsJWvuZhVO9/TlE2gJQyUTsubQFLSx0=" crossorigin=anonymous></script><script defer src=/js/search/flexsearch.compact.64594b125f7b78bdf4fa8316955922bbebb1cd6baef3f16654bfca20309f18f8.js integrity="sha256-ZFlLEl97eL30+oMWlVkiu+uxzWuu8/FmVL/KIDCfGPg="></script><script defer src=/js/search/search.1d980f84df11f3eb7c8c5f17f541d49a0611608df179dd74fa7f06225eb56ace.js integrity="sha256-HZgPhN8R8+t8jF8X9UHUmgYRYI3xed10+n8GIl61as4="></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:opsz,wght@12..96,200..800&family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel=stylesheet></head><body class=notransition><div id=container><header id=main-header><div role=navigation aria-label=Main><div class=nav-left><a href=https://chhz0.github.io/ style=color:inherit>ch.hugo</a></div><div class=nav-right><div style=position:absolute;width:0;height:0><div id=nav-dropdown-menu class=hidden href=#><div class=nav-item><a href=/blogs/>博客</a></div><div class=nav-item><a aria-current=true class=ancestor href=/notes/>笔记</a></div><div class=nav-item><a href=/about/>关于</a></div></div></div><a id=nav-dropdown-button href=#><svg width="20" height="20" viewBox="0 0 24 24" fill="none"><path d="M4 6H20M4 12H20M4 18H20" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></a><div id=nav-menu><div class=nav-item><a href=/blogs/>博客</a></div><div class=nav-item><a aria-current=true class=ancestor href=/notes/>笔记</a></div><div class=nav-item><a href=/about/>关于</a></div></div><a id=theme-switcher href=#><svg class="light-icon" viewBox="0 0 24 24" fill="none"><path d="M12 3V4m0 16v1M4 12H3M6.31412 6.31412 5.5 5.5m12.1859.81412L18.5 5.5M6.31412 17.69 5.5 18.5001M17.6859 17.69 18.5 18.5001M21 12H20m-4 0c0 2.2091-1.7909 4-4 4-2.20914.0-4-1.7909-4-4 0-2.20914 1.79086-4 4-4 2.2091.0 4 1.79086 4 4z" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
<svg class="dark-icon" viewBox="0 0 24 24" fill="none"><path d="M3.32031 11.6835c0 4.9706 4.02944 9 8.99999 9 3.7872.0 7.028-2.3392 8.3565-5.6515C19.6402 15.4486 18.5059 15.6834 17.3203 15.6834c-4.9706.0-8.99999-4.0294-8.99999-8.99998C8.32031 5.50338 8.55165 4.36259 8.96453 3.32996 5.65605 4.66028 3.32031 7.89912 3.32031 11.6835z" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
</a>|
<a id=theme-switcher href=https://github.com/chhz0 aria-label=GitHub><svg class="light-icon" width="800" height="800" viewBox="0 0 20 20" xmlns:xlink="http://www.w3.org/1999/xlink"><title>github [#142]</title><desc>Created with Sketch.</desc><defs/><g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="Dribbble-Light-Preview" transform="translate(-140.000000, -7559.000000)" fill="#fff"><g id="icons" transform="translate(56.000000, 160.000000)"><path d="M94 7399C99.523 7399 104 7403.59 104 7409.253 104 7413.782 101.138 7417.624 97.167 7418.981 96.66 7419.082 96.48 7418.762 96.48 7418.489 96.48 7418.151 96.492 7417.047 96.492 7415.675 96.492 7414.719 96.172 7414.095 95.813 7413.777 98.04 7413.523 100.38 7412.656 100.38 7408.718 100.38 7407.598 99.992 7406.684 99.35 7405.966 99.454 7405.707 99.797 7404.664 99.252 7403.252 99.252 7403.252 98.414 7402.977 96.505 7404.303 95.706 7404.076 94.85 7403.962 94 7403.958 93.15 7403.962 92.295 7404.076 91.497 7404.303 89.586 7402.977 88.746 7403.252 88.746 7403.252 88.203 7404.664 88.546 7405.707 88.649 7405.966 88.01 7406.684 87.619 7407.598 87.619 7408.718 87.619 7412.646 89.954 7413.526 92.175 7413.785 91.889 7414.041 91.63 7414.493 91.54 7415.156 90.97 7415.418 89.522 7415.871 88.63 7414.304 88.63 7414.304 88.101 7413.319 87.097 7413.247 87.097 7413.247 86.122 7413.234 87.029 7413.87 87.029 7413.87 87.684 7414.185 88.139 7415.37 88.139 7415.37 88.726 7417.2 91.508 7416.58 91.513 7417.437 91.522 7418.245 91.522 7418.489 91.522 7418.76 91.338 7419.077 90.839 7418.982 86.865 7417.627 84 7413.783 84 7409.253 84 7403.59 88.478 7399 94 7399" id="github-[#142]"/></g></g></g></svg><svg class="dark-icon" width="800" height="800" viewBox="0 0 20 20" xmlns:xlink="http://www.w3.org/1999/xlink"><title>github [#142]</title><desc>Created with Sketch.</desc><defs/><g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="Dribbble-Light-Preview" transform="translate(-140.000000, -7559.000000)" fill="#000"><g id="icons" transform="translate(56.000000, 160.000000)"><path d="M94 7399C99.523 7399 104 7403.59 104 7409.253 104 7413.782 101.138 7417.624 97.167 7418.981 96.66 7419.082 96.48 7418.762 96.48 7418.489 96.48 7418.151 96.492 7417.047 96.492 7415.675 96.492 7414.719 96.172 7414.095 95.813 7413.777 98.04 7413.523 100.38 7412.656 100.38 7408.718 100.38 7407.598 99.992 7406.684 99.35 7405.966 99.454 7405.707 99.797 7404.664 99.252 7403.252 99.252 7403.252 98.414 7402.977 96.505 7404.303 95.706 7404.076 94.85 7403.962 94 7403.958 93.15 7403.962 92.295 7404.076 91.497 7404.303 89.586 7402.977 88.746 7403.252 88.746 7403.252 88.203 7404.664 88.546 7405.707 88.649 7405.966 88.01 7406.684 87.619 7407.598 87.619 7408.718 87.619 7412.646 89.954 7413.526 92.175 7413.785 91.889 7414.041 91.63 7414.493 91.54 7415.156 90.97 7415.418 89.522 7415.871 88.63 7414.304 88.63 7414.304 88.101 7413.319 87.097 7413.247 87.097 7413.247 86.122 7413.234 87.029 7413.87 87.029 7413.87 87.684 7414.185 88.139 7415.37 88.139 7415.37 88.726 7417.2 91.508 7416.58 91.513 7417.437 91.522 7418.245 91.522 7418.489 91.522 7418.76 91.338 7419.077 90.839 7418.982 86.865 7417.627 84 7413.783 84 7409.253 84 7403.59 88.478 7399 94 7399" id="github-[#142]"/></g></g></g></svg></a></div></div></header><div class="flex grow"><div id=main-pane><main id=main-content><div class=single-header><ol class=breadcrumbs itemscope itemtype=https://schema.org/BreadcrumbList><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://chhz0.github.io/><span itemprop=name>Home</span>
</a><meta itemprop=position content='1'></li><span>&nbsp»&nbsp</span><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://chhz0.github.io/notes/><span itemprop=name>Notes</span>
</a><meta itemprop=position content='2'></li><span>&nbsp»&nbsp</span><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://chhz0.github.io/notes/database/><span itemprop=name>Database</span>
</a><meta itemprop=position content='3'></li><span>&nbsp»&nbsp</span><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://chhz0.github.io/notes/database/mysql/><span itemprop=name>MySQL</span>
</a><meta itemprop=position content='4'></li><span>&nbsp»&nbsp</span></ol><h1>Mysql Index(bate)</h1><time class=dim datetime=2025-07-03T23:16:07+08:00>July 3, 2025</time><div class=term-container><div class=tag><a href=https://chhz0.github.io/tags/mysql/>#MySQL</a></div></ol></div><section class=page-section><blockquote><p>MySQL 索引</p></blockquote><h2 id=1-b树索引数据结构>1. B+树（索引数据结构）</h2><p>什么是索引？
为什么索引能加快查询？
索引的数据结构是什么？
B+ 树 和（B 树 和 红黑树）有什么区别？
为什么选择 B+树 作为索引数据结构？</p><h3 id=为什么mysql-innodb选择b-tree作为索引>为什么Mysql InnoDB选择B+ Tree作为索引？</h3><ol><li>B+ 树 vs B 树
B+ 树只在叶子节点存储数据，B树的非叶子节点也要存储数据，所以B+ 树的单个节点的数据量更小</li><li>B+ 树 vs 二叉树
对于有N个叶子节点的B+ 树，搜索复制度为O（logdn）</li><li>B+ 树 vs Hash</li></ol><blockquote><p><a href=https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%98%E5%AE%9D%E5%85%B8/08%20%20%E7%B4%A2%E5%BC%95%EF%BC%9A%E6%8E%92%E5%BA%8F%E7%9A%84%E8%89%BA%E6%9C%AF.md>08 索引:排序的艺术</a></p><p><a href=https://xiaolincoding.com/mysql/index/why_index_chose_bpuls_tree.html>为什么 MySQL 采用 B+ 树作为索引？</a></p></blockquote><h2 id=2-索引组织表索引存储>2. 索引组织表（索引存储）</h2><p>堆表和索引组织表有什么区别？</p><p>分别应用场景是什么？</p><p>Mysql InnoDB存储引擎中数据存储方式：<strong>索引组织表</strong></p><p>数据存储有<strong>堆表和索引组织表两种。</strong></p><ul><li><p>堆表中的数据是无序存放的，数据的排序完全依赖索引</p></li><li><p>索引组织表，数据根据主键进行排序存放在索引中，主键索引也叫<strong>聚集索引</strong>（Clustered Index）</p></li></ul><p>在索引组织表中，数据即索引，索引即数据</p><h3 id=二级索引>二级索引</h3><p>InnoDB存储引擎的数据是根据主键索引排序存储的，除了主键索引外，其它的索引都称为二级索引（Secondeary Index），或者非聚集索引</p><p>二级索引也是一颗B+树索引，但是它和主键索引不同的是叶子节点存放的是索引键值、主键值</p><p>通过二级索引<code>idx_name</code> 只能定位主键值，需要额外再通过主键索引进行查询，才能得到最终结果。</p><p><strong>这种二级索引通过<strong><strong>主键</strong></strong>索引进行再一次查询的操作叫做“回表”</strong></p><p>这样的二级索引设计的好处：若记录发生了修改，则其它索引无须进行维护，除非记录的主键发生了修改</p><p><strong>在索引组织表中，万物皆索引，索引就是数据，数据就是索引</strong>。</p><h3 id=二级索引的性能评估>二级索引的性能评估</h3><ul><li><p>要比较顺序，对聚集索引性能友好</p></li><li><p>尽可能紧凑，对二级索引的性能和存储友好</p></li></ul><h3 id=函数索引先了解>函数索引（先了解）</h3><p>&mldr;</p><blockquote><p><a href=https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%98%E5%AE%9D%E5%85%B8/09%20%20%E7%B4%A2%E5%BC%95%E7%BB%84%E7%BB%87%E8%A1%A8%EF%BC%9A%E4%B8%87%E7%89%A9%E7%9A%86%E7%B4%A2%E5%BC%95.md>09 索引组织表:万物皆索引</a></p></blockquote><h2 id=3组合索引联合索引>3.组合索引（联合索引）</h2><p>联合索引的结构是什么？</p><p>如果利用联合索引提升查询性能</p><p>组合索引（Compound Index）是指由多个列所组合而成的B+树索引</p><p>组合索引既可以是主键索引，也可以是二级索引，只是排序的键值从1个变成了多个，本质还是一棵B+树索引</p><h3 id=索引覆盖>索引覆盖</h3><p>目的是为了避免回表，由于二级组合索引的叶子节点，包含索引键值和主键值，若查询的字段在二级索引的叶子节点中，则可以直接返回结果，无需回表。</p><p>这种组合索引避免回表的优化手段称为索引覆盖（Covering Index）</p><blockquote><p><a href=https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%98%E5%AE%9D%E5%85%B8/10%20%20%E7%BB%84%E5%90%88%E7%B4%A2%E5%BC%95%EF%BC%9A%E7%94%A8%E5%A5%BD%EF%BC%8C%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87%2010%20%E5%80%8D%EF%BC%81.md>10 组合索引:用好，性能提升 10 倍!</a></p><p><a href=https://ls8sck0zrg.feishu.cn/wiki/CgAqwymqXiSxYikP0Mac273fnkb>MySQL夜市8月25日（联合索引）</a></p></blockquote><h2 id=4索引失效>4.索引失效</h2><p>有哪些索引失效的场景？</p><p>为什么会失效？</p><p>前提：索引可以提高语句查询速度，但是索引并不是万能的，建立了索引，并不意味着任何查询语句都能走索引扫描</p><h3 id=索引存储结构长什么样>索引存储结构长什么样？</h3><p>MySQL默认的存储引擎是InnoDB，采用的是B+树作为索引的数据结构。在建表的时候，InnoDB存储引擎默认会创建一个主键索引，也就是聚簇索引，其它索引都属于二级索引</p><h3 id=失效情况>失效情况</h3><h4 id=a-对索引使用左或者左右模糊匹配>A. 对索引使用左或者左右模糊匹配</h4><p>索引<strong>B+树</strong>是按照索引值有序存储的，只能根据前缀进行比较</p><h4 id=b-对索引使用函数><strong>B.</strong> 对索引使用函数</h4><p>索引保存的是索引字段的原始值，而不是经过函数计算后的值</p><h4 id=c-对索引进行表达式计算>C. 对索引进行表达式计算</h4><p>原因与索引使用函数差不多，进行了表达式计算后得到的值不是原本的值，无法走索引</p><h4 id=d-对索引隐式类型转换>D. 对索引隐式类型转换</h4><p>Mysql的类型转换规则：</p><ul><li><p>字符串 &ndash;> 数字，就相当于 数字比较</p></li><li><p>数字 &ndash;> 字符串，就是字符串比较</p></li></ul><p>小总结：在Mysql中，遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较</p><h4 id=e-联合索引非最左匹配>E. 联合索引非最左匹配</h4><h4 id=f-where-子句中的or>F. Where 子句中的OR</h4><p>在WHERE子句中，如果在OR前的条件列是索引列，而OR后面不是索引列，那么索引会失效</p><blockquote><p><a href=https://xiaolincoding.com/mysql/index/index_lose.html#%E7%B4%A2%E5%BC%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E9%95%BF%E4%BB%80%E4%B9%88%E6%A0%B7>索引失效有哪些？</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;mid=2247502059&amp;idx=1&amp;sn=ccbee22bda8c3d6a98237be769a7c89c&amp;scene=21#wechat_redirect">B+树里面的节点存放的是什么？查询数据的结果又是怎样的？</a></p></blockquote><h3 id=5索引选择>5.索引选择</h3><p>Mysql数据库中的优化器是怎么执行的？</p><p>根据什么标准选择索引？</p><h4 id=mysql是如何选择所索引的>MySQL是如何选择所索引的？</h4><p>在关系型数据库中，B+树索引只是存储的一种数据结构，具体使用还需要依赖数据库的优化器，优化器决定了具体某一索引的选择</p><p><strong>而<strong><strong>优化器</strong></strong>的选择是基于成本（cost），哪个索引的成本越低，优先选择哪个索引</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span>Cost <span style=color:#f92672>=</span> Server Cost <span style=color:#f92672>+</span> Engine Cost
</span></span><span style=display:flex><span>     <span style=color:#f92672>=</span> CPU Cost <span style=color:#f92672>+</span> IO Cost
</span></span></code></pre></div><p>先看MySQL数据库的结构，MySQL由Server层和Engine层组成：</p><ul><li><p>Server层有SQL分析器、SQL优化器、SQL执行器，用于负责SQL语句的具体执行过程</p></li><li><p>Engine层负责存储具体的数据，常使用InnoDB存储引擎，还有用于内存中存储临时结果集的TempTable引擎</p></li></ul><p>MySQL索引出错：</p><ol><li><p>未使用创建的索引</p></li><li><p>索引创建在有限状态上</p></li></ol><blockquote><p><a href=https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%98%E5%AE%9D%E5%85%B8/11%20%20%E7%B4%A2%E5%BC%95%E5%87%BA%E9%94%99%EF%BC%9A%E8%AF%B7%E7%90%86%E8%A7%A3%20CBO%20%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.md>11 索引出错:请理解 CBO 的工作原理</a></p></blockquote><h3 id=6索引应用>6.索引应用</h3><p>建立索引有什么优点和缺点？</p><p>如何正确使用索引？</p><p>哪些场景下适合建立索引？</p><p>哪些场景下不适合建立索引？</p><h2 id=总结>总结</h2><ol><li><p>B+树索引</p><ol><li><p>索引的加快查询的一种数据结构，其原理是插入时对数据排序，缺点是会影响插入的性能</p></li><li><p>Mysql当前支持B+树索引、全文索引、R树索引</p></li><li><p>B+树索引的高度通常为3~4层，高度为4的B+树可以存放50亿左右的数据</p></li><li><p>由于B+树的高度不高，查询效率高，50亿的数据也只需插叙4次I/O</p></li><li><p>Mysql单表的索引没有个数限制，业务查询需要，创建即可</p></li><li><p>可以通过表sys.schema_unused_indexes和索引不可见特性，删除无用的索引</p></li><li><p>Mysql采用B+树索引？从数据结构、磁盘I/O操作次数出发</p></li></ol></li><li><p>索引组织表</p></li></ol><p>Mysql InnoDB存储引擎是索引组织表，以及索引组织表和堆表之间的区别：</p><ul><li><p>索引组织表主键是聚集索引，索引的叶子节点存放表中一整行完整记录</p></li><li><p>除主键索引外的索引都是二级索引，索引的叶子节点存放的是（键值，主键值）</p></li><li><p>由于二级索引不存放完整记录，因此需要通过主键值再进行一次回表才能定位到完整数据</p></li><li><p>索引组织表对比堆表，在海量并发的OLTP业务中能有更好的性能表现</p></li><li><p>每种不同数据，对二级索引的性能开销影响不一样</p></li><li><p>有时通过函数索引可以更快解决线上SQL的性能问题</p></li><li><p>虚拟列不占用实际存储空间，在虚拟类上创建索引本质就是函数索引</p></li></ul><ol start=3><li><p>组合索引</p><p>  组合索引也是一颗B+树，只是索引的列由多个组成，组合索引既可以是主键索引，也可以是二级索引</p><p>  组合索引的三大优势</p><ol start=3><li><p>覆盖多个查询条件，如（a，b）索引可以覆盖查询 a = ? 或者 a = ? and b = ?</p></li><li><p>避免SQL的额外排序，提高SQL性能，如WHERE a = ? OR ORDER BY b 这样的查询条件</p></li><li><p>利用组合索引包含多个列的特性，可以利用索引覆盖技术，提高SQL的查询性能，用好索引覆盖技术，性能提升10倍不是难事</p></li></ol></li><li><p>索引失效</p><p>  6种会发生索引失效的情况：</p><ol start=2><li><p>使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者<code>like %xx%</code> 这两种方式，都会造成索引失效</p></li><li><p>当我们查询条件中对所有列使用<code>函数</code>，会导致索引失效</p></li><li><p>在查询条件中对所有列进行<code>表达式运算</code>，会导致索引失效</p></li><li><p>MySQL遇到字符串和数字比较的时候，会自动把字符串转为数字，再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么所有列会发生隐式类型转换，由于隐式类型转换是通过CAST函数实现的，等于对索引列使用了函数，所以导致索引失效</p></li><li><p>联合索引要能正确使用遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则索引会失效</p></li><li><p>在WHERE子句中，如果在OR前的条件列是索引列，而在OR后的条件列不是索引列，那么所有会失效</p></li></ol></li><li><p>索引选择</p></li></ol><p>MySQL优化器是CBO，是一种基于成本的优化器。会判断每个索引的执行成本，从中选择出最优的执行计划</p><ul><li><p>MySQL优化器是CBO（Cost-based Optimizer）的</p></li><li><p>MySQL会选择成本最低的执行计划，可以通过explain命令查看每个SQL的成本</p></li><li><p>一般只对高选择度的字段和字段组合起来建立索引，选择度低的字段如性别，不建议建立索引</p></li><li><p>若数据存在倾斜，可以创建直方图，让优化器知道索引中的数据的分布，进一步校准执行计划</p></li></ul><h2 id=面试题>面试题：</h2><h3 id=1为什么innodb选择btree作为索引的数据结构>1.为什么InnoDB选择B+Tree作为索引的数据结构？</h3><ol><li><p>B+树 vs B树</p><ol><li><p>存储相同数据量级下，B+树高比B树低，磁盘I/O次数更少</p></li><li><p>B+树叶子节点用双向链表串起来，适合范围查询，B树无法做到这点</p></li></ol></li><li><p>B+树 vs 二叉树</p><ol><li>随着数据量的增加，二叉树的树高会越来越高，磁盘I/O次数也会更多，B+树在千万级别的数据量下，高度依然维持在3~4层左右</li></ol></li><li><p>B+树 vs Hash</p><ol><li>虽然Hash的等值查询效率高，但是无法做到范围查询</li></ol></li></ol><h3 id=2什么时候适用索引>2.什么时候适用索引？</h3><ul><li><p>字段有唯一限制性</p></li><li><p>经常用于WHERE查询条件</p></li><li><p>经常用于GROUP BY 和 ORDER BY的字段</p></li></ul><h3 id=3什么时候不需要创建索引>3.什么时候不需要创建索引？</h3><ul><li><p>WHERE条件，GROUP BY，ORDER BY里用不到的字段</p></li><li><p>字段中存在大量重复数据</p></li><li><p>表数据太少</p></li><li><p>经常需要更新的字段</p></li></ul><h3 id=4什么时候索引会失效>4.什么时候索引会失效？</h3><ul><li><p>左或左右模糊匹配</p></li><li><p>在查询条件中对索引列做了计算、函数、类型转换等操作</p></li><li><p>联合索引要正确遵循最左匹配原则</p></li><li><p>在WHRER子句中，如果在OR前的条件是索引列而OR后的条件列不是索引列</p></li><li><p>为了更好使用索引，索引列要设置为NOT NULL</p></li></ul><h3 id=5有什么优化索引的方法>5.有什么优化索引的方法？</h3><p>回答：</p><ul><li><p>前缀索引优化</p></li><li><p>覆盖索引优化</p></li><li><p>主键索引最好是自增的</p></li><li><p>防止索引失效</p></li><li><p>#MySQL</p></li></ul></section></main><footer id=main-footer><div class=footer><a href=#>回到顶部 ↑</a><div class=footer-copyright><div>© 2025 Chen-Hang</div><div>powered by <a href=https://github.com/math-queiroz/rusty-typewriter target=_blank>Rusty Typewriter</a> theme for <a href=https://gohugo.io/ target=_blank>Hugo</a></div></div></div></footer></div><aside id=side-pane class=side-sticky><div class=side-details><span>3051 字数</span>
<span>10 - 13 阅读时间</span><div class=side-details-taxonomy><small>categories:
<span class=details-taxonomy><a href=https://chhz0.github.io/categories/note>Note</a></span></small></div></div><h3>目录</h3><nav id=TableOfContents><ul><li><a href=#1-b树索引数据结构>1. B+树（索引数据结构）</a><ul><li><a href=#为什么mysql-innodb选择b-tree作为索引>为什么Mysql InnoDB选择B+ Tree作为索引？</a></li></ul></li><li><a href=#2-索引组织表索引存储>2. 索引组织表（索引存储）</a><ul><li><a href=#二级索引>二级索引</a></li><li><a href=#二级索引的性能评估>二级索引的性能评估</a></li><li><a href=#函数索引先了解>函数索引（先了解）</a></li></ul></li><li><a href=#3组合索引联合索引>3.组合索引（联合索引）</a><ul><li><a href=#索引覆盖>索引覆盖</a></li></ul></li><li><a href=#4索引失效>4.索引失效</a><ul><li><a href=#索引存储结构长什么样>索引存储结构长什么样？</a></li><li><a href=#失效情况>失效情况</a></li><li><a href=#5索引选择>5.索引选择</a></li><li><a href=#6索引应用>6.索引应用</a></li></ul></li><li><a href=#总结>总结</a></li><li><a href=#面试题>面试题：</a><ul><li><a href=#1为什么innodb选择btree作为索引的数据结构>1.为什么InnoDB选择B+Tree作为索引的数据结构？</a></li><li><a href=#2什么时候适用索引>2.什么时候适用索引？</a></li><li><a href=#3什么时候不需要创建索引>3.什么时候不需要创建索引？</a></li><li><a href=#4什么时候索引会失效>4.什么时候索引会失效？</a></li><li><a href=#5有什么优化索引的方法>5.有什么优化索引的方法？</a></li></ul></li></ul></nav><h3>相关</h3><ul><li><a href=/notes/database/mysql/mysql-buffer-pool/>Mysql Buffer Pool(bate)</a></li><li><a href=/notes/database/mysql/mysql-arch/>Mysql Arch(bate)</a></li><li><a href=/notes/database/mysql/todo/>MySQL - Todo</a></li></ul></aside></div></div></body></html>