<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Mysql Arch(bate) | ch.hugo</title>
<link rel=icon href=favicon.svg sizes=any type=image/svg+xml><meta property="og:url" content="https://chhz0.github.io/notes/database/mysql/mysql-arch/"><meta property="og:site_name" content="ch.hugo"><meta property="og:title" content="Mysql Arch(bate)"><meta property="og:description" content="MySQL 架构- server && storage-engine
6.1 SQL执行过程 推荐阅读 小林coding/mysql
MySQL架构分为两层：server层和存储引擎层
Server层负责建立连接、分析和执行SQL MySQL大多数核心功能模块都在这里：连接器、查询缓存、解析器、预处理器、优化器、执行器等 还有所有的内置函数 所有跨存储引擎的功能 存储引擎层负责数据的存储和提取 支持InnoDB、MyISAM、Memory等多个存储引擎 6.1.1 连接器 MySQL是基于TCP协议进行传输的，所以在连接MySQL的时候需要先进行TCP三次握手，在命令行使用命令进行连接
mysql -h $ip -u$user -p 用户通过用户密码成功连接后，连接器会获取用户的权限，然后保存起来，在后续的此连接的任何操作，都会基于连接开始的时候读取到的权限逻辑进行判断
建立连接后，即使修改了该用户的权限，也不影响已连接的权限。只有新建的连接才会有新的权限设置
6.1.1.1 查看MySQL服务的客户端连接 可以执行show processlist 命令进行查看
6.1.1.2 空闲连接会一直占着 不会，MySQL定义了空闲连接的最大空闲时长，由wait_timeout 参数控制，默认值是8小时，超过这个时间，连接器就会把这个连接断开
使用命令可以查看该值
show variables like 'wait_timeout'; 可以手动断开空闲的连接，使用的是
kill connection + id 当空闲的连接被服务端主动断开后，这个客户端并不会马上知道，等到客户端在发起下一个请求时，才会收到报错
“ERROR 2013 (HY000): Lost connection to MySQL server during query”
6.1.1.3 MySQL的连接限制 MySQL服务支持的最大连接数由max_connections 参数控制
show variables like 'max_connections'; MySQL的连接跟HTTP一样，有短连接和长连接的概念
// 短连接 连接 mysql 服务（TCP 三次握手） 执行sql 断开 mysql 服务（TCP 四次挥手） // 长连接 连接 mysql 服务（TCP 三次握手） 执行sql 执行sql 执行sql .... 断开 mysql 服务（TCP 四次挥手） 一般推荐长连接，但是使用长连接可能会占用内存增多，因为_MySQL在执行查询过程中临时使用内存管理连接对象__，_只有在连接断开的时候才会释放"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="notes"><meta property="article:published_time" content="2025-07-03T23:15:49+08:00"><meta property="article:modified_time" content="2025-07-03T23:15:49+08:00"><meta property="article:tag" content="MySQL"><meta name=twitter:card content="summary"><meta name=twitter:title content="Mysql Arch(bate)"><meta name=twitter:description content="MySQL 架构- server && storage-engine
6.1 SQL执行过程 推荐阅读 小林coding/mysql
MySQL架构分为两层：server层和存储引擎层
Server层负责建立连接、分析和执行SQL MySQL大多数核心功能模块都在这里：连接器、查询缓存、解析器、预处理器、优化器、执行器等 还有所有的内置函数 所有跨存储引擎的功能 存储引擎层负责数据的存储和提取 支持InnoDB、MyISAM、Memory等多个存储引擎 6.1.1 连接器 MySQL是基于TCP协议进行传输的，所以在连接MySQL的时候需要先进行TCP三次握手，在命令行使用命令进行连接
mysql -h $ip -u$user -p 用户通过用户密码成功连接后，连接器会获取用户的权限，然后保存起来，在后续的此连接的任何操作，都会基于连接开始的时候读取到的权限逻辑进行判断
建立连接后，即使修改了该用户的权限，也不影响已连接的权限。只有新建的连接才会有新的权限设置
6.1.1.1 查看MySQL服务的客户端连接 可以执行show processlist 命令进行查看
6.1.1.2 空闲连接会一直占着 不会，MySQL定义了空闲连接的最大空闲时长，由wait_timeout 参数控制，默认值是8小时，超过这个时间，连接器就会把这个连接断开
使用命令可以查看该值
show variables like 'wait_timeout'; 可以手动断开空闲的连接，使用的是
kill connection + id 当空闲的连接被服务端主动断开后，这个客户端并不会马上知道，等到客户端在发起下一个请求时，才会收到报错
“ERROR 2013 (HY000): Lost connection to MySQL server during query”
6.1.1.3 MySQL的连接限制 MySQL服务支持的最大连接数由max_connections 参数控制
show variables like 'max_connections'; MySQL的连接跟HTTP一样，有短连接和长连接的概念
// 短连接 连接 mysql 服务（TCP 三次握手） 执行sql 断开 mysql 服务（TCP 四次挥手） // 长连接 连接 mysql 服务（TCP 三次握手） 执行sql 执行sql 执行sql .... 断开 mysql 服务（TCP 四次挥手） 一般推荐长连接，但是使用长连接可能会占用内存增多，因为_MySQL在执行查询过程中临时使用内存管理连接对象__，_只有在连接断开的时候才会释放"><link rel=stylesheet href=/css/components.min.9d886688d3ae94cecf1b057e706bf74497fcd5cea352d433c34cda3b9425a8d4.css integrity="sha256-nYhmiNOulM7PGwV+cGv3RJf81c6jUtQzw0zaO5QlqNQ=" crossorigin=anonymous><link rel=stylesheet href=/css/main.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css integrity="sha256-47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=" crossorigin=anonymous><link rel=stylesheet href=/css/root.min.1677bc99f2421f7cb9fc1d00b09addcc951fd9d4c785e22b20ed55c0602786fc.css integrity="sha256-Fne8mfJCH3y5/B0AsJrdzJUf2dTHheIrIO1VwGAnhvw=" crossorigin=anonymous><link rel=stylesheet href=/css/search.min.cb1ed1dad3ee872e229e9f1fc681bdbd20d923389f1fa6aaf89f9aee93af4fbf.css integrity="sha256-yx7R2tPuhy4inp8fxoG9vSDZIzifH6aq+J+a7pOvT78=" crossorigin=anonymous><link rel=stylesheet href=/css/bundle.min.4878d16c866148ae8cfd6f4f44052d25f2548b24ab4a9bc857279dc6d06df2b5.css integrity="sha256-SHjRbIZhSK6M/W9PRAUtJfJUiySrSpvIVyedxtBt8rU=" crossorigin=anonymous><script src=/js/bundle.995e4ec99401021e081ec256bee66154ef7f4e5136809432513b2e6d014b4b1d.js integrity="sha256-mV5OyZQBAh4IHsJWvuZhVO9/TlE2gJQyUTsubQFLSx0=" crossorigin=anonymous></script><script defer src=/js/search/flexsearch.compact.64594b125f7b78bdf4fa8316955922bbebb1cd6baef3f16654bfca20309f18f8.js integrity="sha256-ZFlLEl97eL30+oMWlVkiu+uxzWuu8/FmVL/KIDCfGPg="></script><script defer src=/js/search/search.1d980f84df11f3eb7c8c5f17f541d49a0611608df179dd74fa7f06225eb56ace.js integrity="sha256-HZgPhN8R8+t8jF8X9UHUmgYRYI3xed10+n8GIl61as4="></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:opsz,wght@12..96,200..800&family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel=stylesheet></head><body class=notransition><div id=container><header id=main-header><div role=navigation aria-label=Main><div class=nav-left><a href=https://chhz0.github.io/ style=color:inherit>ch.hugo</a></div><div class=nav-right><div style=position:absolute;width:0;height:0><div id=nav-dropdown-menu class=hidden href=#><div class=nav-item><a href=/blogs/>博客</a></div><div class=nav-item><a aria-current=true class=ancestor href=/notes/>笔记</a></div><div class=nav-item><a href=/about/>关于</a></div></div></div><a id=nav-dropdown-button href=#><svg width="20" height="20" viewBox="0 0 24 24" fill="none"><path d="M4 6H20M4 12H20M4 18H20" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></a><div id=nav-menu><div class=nav-item><a href=/blogs/>博客</a></div><div class=nav-item><a aria-current=true class=ancestor href=/notes/>笔记</a></div><div class=nav-item><a href=/about/>关于</a></div></div><a id=theme-switcher href=#><svg class="light-icon" viewBox="0 0 24 24" fill="none"><path d="M12 3V4m0 16v1M4 12H3M6.31412 6.31412 5.5 5.5m12.1859.81412L18.5 5.5M6.31412 17.69 5.5 18.5001M17.6859 17.69 18.5 18.5001M21 12H20m-4 0c0 2.2091-1.7909 4-4 4-2.20914.0-4-1.7909-4-4 0-2.20914 1.79086-4 4-4 2.2091.0 4 1.79086 4 4z" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
<svg class="dark-icon" viewBox="0 0 24 24" fill="none"><path d="M3.32031 11.6835c0 4.9706 4.02944 9 8.99999 9 3.7872.0 7.028-2.3392 8.3565-5.6515C19.6402 15.4486 18.5059 15.6834 17.3203 15.6834c-4.9706.0-8.99999-4.0294-8.99999-8.99998C8.32031 5.50338 8.55165 4.36259 8.96453 3.32996 5.65605 4.66028 3.32031 7.89912 3.32031 11.6835z" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
</a>|
<a id=theme-switcher href=https://github.com/chhz0 aria-label=GitHub><svg class="light-icon" width="800" height="800" viewBox="0 0 20 20" xmlns:xlink="http://www.w3.org/1999/xlink"><title>github [#142]</title><desc>Created with Sketch.</desc><defs/><g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="Dribbble-Light-Preview" transform="translate(-140.000000, -7559.000000)" fill="#fff"><g id="icons" transform="translate(56.000000, 160.000000)"><path d="M94 7399C99.523 7399 104 7403.59 104 7409.253 104 7413.782 101.138 7417.624 97.167 7418.981 96.66 7419.082 96.48 7418.762 96.48 7418.489 96.48 7418.151 96.492 7417.047 96.492 7415.675 96.492 7414.719 96.172 7414.095 95.813 7413.777 98.04 7413.523 100.38 7412.656 100.38 7408.718 100.38 7407.598 99.992 7406.684 99.35 7405.966 99.454 7405.707 99.797 7404.664 99.252 7403.252 99.252 7403.252 98.414 7402.977 96.505 7404.303 95.706 7404.076 94.85 7403.962 94 7403.958 93.15 7403.962 92.295 7404.076 91.497 7404.303 89.586 7402.977 88.746 7403.252 88.746 7403.252 88.203 7404.664 88.546 7405.707 88.649 7405.966 88.01 7406.684 87.619 7407.598 87.619 7408.718 87.619 7412.646 89.954 7413.526 92.175 7413.785 91.889 7414.041 91.63 7414.493 91.54 7415.156 90.97 7415.418 89.522 7415.871 88.63 7414.304 88.63 7414.304 88.101 7413.319 87.097 7413.247 87.097 7413.247 86.122 7413.234 87.029 7413.87 87.029 7413.87 87.684 7414.185 88.139 7415.37 88.139 7415.37 88.726 7417.2 91.508 7416.58 91.513 7417.437 91.522 7418.245 91.522 7418.489 91.522 7418.76 91.338 7419.077 90.839 7418.982 86.865 7417.627 84 7413.783 84 7409.253 84 7403.59 88.478 7399 94 7399" id="github-[#142]"/></g></g></g></svg><svg class="dark-icon" width="800" height="800" viewBox="0 0 20 20" xmlns:xlink="http://www.w3.org/1999/xlink"><title>github [#142]</title><desc>Created with Sketch.</desc><defs/><g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="Dribbble-Light-Preview" transform="translate(-140.000000, -7559.000000)" fill="#000"><g id="icons" transform="translate(56.000000, 160.000000)"><path d="M94 7399C99.523 7399 104 7403.59 104 7409.253 104 7413.782 101.138 7417.624 97.167 7418.981 96.66 7419.082 96.48 7418.762 96.48 7418.489 96.48 7418.151 96.492 7417.047 96.492 7415.675 96.492 7414.719 96.172 7414.095 95.813 7413.777 98.04 7413.523 100.38 7412.656 100.38 7408.718 100.38 7407.598 99.992 7406.684 99.35 7405.966 99.454 7405.707 99.797 7404.664 99.252 7403.252 99.252 7403.252 98.414 7402.977 96.505 7404.303 95.706 7404.076 94.85 7403.962 94 7403.958 93.15 7403.962 92.295 7404.076 91.497 7404.303 89.586 7402.977 88.746 7403.252 88.746 7403.252 88.203 7404.664 88.546 7405.707 88.649 7405.966 88.01 7406.684 87.619 7407.598 87.619 7408.718 87.619 7412.646 89.954 7413.526 92.175 7413.785 91.889 7414.041 91.63 7414.493 91.54 7415.156 90.97 7415.418 89.522 7415.871 88.63 7414.304 88.63 7414.304 88.101 7413.319 87.097 7413.247 87.097 7413.247 86.122 7413.234 87.029 7413.87 87.029 7413.87 87.684 7414.185 88.139 7415.37 88.139 7415.37 88.726 7417.2 91.508 7416.58 91.513 7417.437 91.522 7418.245 91.522 7418.489 91.522 7418.76 91.338 7419.077 90.839 7418.982 86.865 7417.627 84 7413.783 84 7409.253 84 7403.59 88.478 7399 94 7399" id="github-[#142]"/></g></g></g></svg></a></div></div></header><div class="flex grow"><div id=main-pane><main id=main-content><div class=single-header><ol class=breadcrumbs itemscope itemtype=https://schema.org/BreadcrumbList><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://chhz0.github.io/><span itemprop=name>Home</span>
</a><meta itemprop=position content='1'></li><span>&nbsp»&nbsp</span><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://chhz0.github.io/notes/><span itemprop=name>Notes</span>
</a><meta itemprop=position content='2'></li><span>&nbsp»&nbsp</span><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://chhz0.github.io/notes/database/><span itemprop=name>Database</span>
</a><meta itemprop=position content='3'></li><span>&nbsp»&nbsp</span><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://chhz0.github.io/notes/database/mysql/><span itemprop=name>MySQL</span>
</a><meta itemprop=position content='4'></li><span>&nbsp»&nbsp</span></ol><h1>Mysql Arch(bate)</h1><time class=dim datetime=2025-07-03T23:15:49+08:00>July 3, 2025</time><div class=term-container><div class=tag><a href=https://chhz0.github.io/tags/mysql/>#MySQL</a></div></ol></div><section class=page-section><blockquote><p>MySQL 架构- server && storage-engine</p></blockquote><h2 id=61-sql执行过程>6.1 SQL执行过程</h2><p>推荐阅读 <a href=https://xiaolincoding.com/mysql/base/how_select.html#mysql-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84>小林coding/mysql</a></p><p>MySQL架构分为两层：<strong>server层和存储引擎层</strong></p><ul><li>Server层负责建立连接、分析和执行SQL<ul><li>MySQL大多数核心功能模块都在这里：连接器、查询缓存、解析器、预处理器、优化器、执行器等</li><li>还有所有的内置函数</li><li>所有跨存储引擎的功能</li></ul></li><li>存储引擎层负责数据的存储和提取<ul><li>支持InnoDB、MyISAM、Memory等多个存储引擎</li></ul></li></ul><h3 id=611-连接器>6.1.1 连接器</h3><p>MySQL是基于TCP协议进行传输的，所以在连接MySQL的时候需要先进行TCP三次握手，在命令行使用命令进行连接</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Bash data-lang=Bash><span style=display:flex><span>mysql -h $ip -u$user -p
</span></span></code></pre></div><p>用户通过用户密码成功连接后，连接器会获取用户的权限，然后保存起来，在后续的此连接的任何操作，都会基于连接开始的时候读取到的权限逻辑进行判断</p><p>建立连接后，即使修改了该用户的权限，也不影响已连接的权限。只有新建的连接才会有新的权限设置</p><h4 id=6111-查看mysql服务的客户端连接>6.1.1.1 查看MySQL服务的客户端连接</h4><p>可以执行<code>show processlist</code> 命令进行查看</p><h4 id=6112-空闲连接会一直占着>6.1.1.2 空闲连接会一直占着</h4><p>不会，MySQL定义了空闲连接的最大空闲时长，由<code>wait_timeout</code> 参数控制，默认值是8小时，超过这个时间，连接器就会把这个连接断开</p><p>使用命令可以查看该值</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Bash data-lang=Bash><span style=display:flex><span>show variables like <span style=color:#e6db74>&#39;wait_timeout&#39;</span>;
</span></span></code></pre></div><p>可以手动断开空闲的连接，使用的是</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-SQL data-lang=SQL><span style=display:flex><span>kill <span style=color:#66d9ef>connection</span> <span style=color:#f92672>+</span> id
</span></span></code></pre></div><p>当空闲的连接被服务端主动断开后，这个客户端并不会马上知道，等到客户端在发起下一个请求时，才会收到报错</p><p>“ERROR 2013 (HY000): Lost connection to MySQL server during query”</p><h4 id=6113-mysql的连接限制>6.1.1.3 MySQL的连接限制</h4><p>MySQL服务支持的最大连接数由<code>max_connections</code> 参数控制</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Bash data-lang=Bash><span style=display:flex><span>show variables like <span style=color:#e6db74>&#39;max_connections&#39;</span>;
</span></span></code></pre></div><p>MySQL的连接跟HTTP一样，有短连接和长连接的概念</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-SQL data-lang=SQL><span style=display:flex><span><span style=color:#f92672>//</span> <span style=color:#960050;background-color:#1e0010>短连接</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>连接</span> mysql <span style=color:#960050;background-color:#1e0010>服务（</span>TCP <span style=color:#960050;background-color:#1e0010>三次握手）</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>执行</span><span style=color:#66d9ef>sql</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>断开</span> mysql <span style=color:#960050;background-color:#1e0010>服务（</span>TCP <span style=color:#960050;background-color:#1e0010>四次挥手）</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>//</span> <span style=color:#960050;background-color:#1e0010>长连接</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>连接</span> mysql <span style=color:#960050;background-color:#1e0010>服务（</span>TCP <span style=color:#960050;background-color:#1e0010>三次握手）</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>执行</span><span style=color:#66d9ef>sql</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>执行</span><span style=color:#66d9ef>sql</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>执行</span><span style=color:#66d9ef>sql</span>
</span></span><span style=display:flex><span>....
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>断开</span> mysql <span style=color:#960050;background-color:#1e0010>服务（</span>TCP <span style=color:#960050;background-color:#1e0010>四次挥手）</span>
</span></span></code></pre></div><p>一般推荐长连接，但是使用长连接可能会占用内存增多，因为_MySQL在执行查询过程中临时使用内存管理连接对象__，_只有在连接断开的时候才会释放</p><h4 id=6114-怎么解决长连接占用内存的问题>6.1.1.4 怎么解决长连接占用内存的问题</h4><p>两个解决方案：</p><ol><li><p>定期断开长连接</p></li><li><p>客户端主动重置连接</p><p>  MySQL在5.7版本实现了<code>mysql_reset_connection()</code>函数的接口，可以使得客户端执行一个很大的操作后，在代码里调用该函数，来进行重置连接，达到释放内存的效果</p></li></ol><blockquote><ul><li><p>与客户端进行 TCP 三次握手建立连接；</p></li><li><p>校验客户端的用户名和密码，如果用户名或密码不对，则会报错；</p></li><li><p>如果用户名和密码都对了，会读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限；</p></li></ul></blockquote><h3 id=612-查询缓存>6.1.2 查询缓存</h3><p>连接器完成连接后，服务端收到SQL语句，就会解析出SQL语句是什么类型的语句</p><p>如果是SELECT语句，MYSQL会先去查询缓存（Query Cache）查找缓存数据，这个查询缓存是以<code>key-value</code> 形式保存在内存中，key为SQL查询语句，value为SQL语句查询的结果</p><p>如果缓存命中，就会直接发送value给客户端，否则就继续往下执行</p><p>在MySQL8.0版本，这个查询缓存被删除了，因为这个查询缓存的命中率很低，因为只要有一个表有更新操作，那么这个表的查询缓存就会被清空，如果刚缓存了一个查询结果很大的数据，还没有使用，刚好这个表有更新操作，查询缓存就被清空了，相当于缓存浪费了</p><blockquote><p>这里说的查询缓存是 server 层的，也就是 MySQL 8.0 版本移除的是 server 层的查询缓存，并不是 Innodb 存储引擎中的 buffer pool</p></blockquote><h3 id=613-解析sql>6.1.3 解析SQL</h3><p>解析器会做下面两件事</p><ol><li><p>词法解析：识别关键字</p></li><li><p>语法解析：根据词法解析的结果，根据语法规则，构建出SQL语法树</p></li></ol><p>如果我们输入的SQL语句语法不对，就会在解析器这个阶段报错</p><blockquote><p>注意：表不存在或者字段不存在，并不在解析器里识别。解析器只负责检查语法和构建语法树，但不会去查表或者字段存不存在</p></blockquote><h3 id=614-执行sql>6.1.4 执行SQL</h3><p>经过解析器后，进入执行SQL查询语法的流程，主要可分为下面三个阶段</p><ul><li><p>prepare阶段，预处理阶段</p></li><li><p>optimize阶段，优化阶段</p></li><li><p>execute阶段，执行阶段</p></li></ul><h4 id=6141-预处理器>6.1.4.1 预处理器</h4><p>预处理阶段做以下的事：</p><ul><li><p>检查SQL查询语句中的表或者字段是否存在</p></li><li><p>将<code>*</code>扩展为表上所有列</p></li></ul><h4 id=6142-优化器>6.1.4.2 优化器</h4><p>预处理阶段后，需要为SQL语句制定一个执行计划，就交由优化器完成</p><p>优化器主要负责将SQL查询语句的执行方案确定下来，决定使用哪个索引</p><p>在查询语句前加个<code>explain</code>命令，就会输出这条SQL语句的执行计划</p><h4 id=6143-执行器>6.1.4.3 执行器</h4><p>执行器：开始真正执行语句。在执行过程中，执行器就会和存储引擎交互，过程如下</p><ul><li><p>主键索引查询</p></li><li><p>全表扫描</p></li><li><p>索引下推</p></li></ul><h5 id=61431-主键索引查询>6.1.4.3.1 主键索引查询</h5><p>在SQL语句中查询条件使用主键索引，访问类型为const，那么执行器与存储引擎执行流程大致如下</p><ul><li><p>执行器第一次查询，调用<code>read_first_record</code>函数指针指向函数，访问类型为const，指向InnoDB引擎<strong>索引查询</strong>的接口，让存储引擎定位符合条件的记录</p></li><li><p>存储引擎通过主键索引的B+树结构定位到符合条件的记录，如果记录不存在，就会向执行器上报记录找不到的错误，查询结束；如果记录存在，则返回记录给执行器</p></li><li><p>执行器从存储引擎读到记录后，接着判断记录是否符合查询条件，如果符合则发送给客户端，不符合则跳过该记录</p></li><li><p>执行器查询的过程是一个while循环，所以会在查询一次，此时调用<code>read_record</code>函数指针指向的函数，因为优化器选择的访问类型是const，这个函数指针指向一个永远返回-1的函数，所以当调用函数的时候，执行器退出循环，查询结束</p></li></ul><h5 id=61432-全表扫描>6.1.4.3.2 全表扫描</h5><p>全表查询是没有用到索引，所以优化器决定选用访问类型为ALL</p><ul><li><p>执行器第一次查询，调用<code>read_first_record</code>函数指针指向函数，访问类型为const，指向InnoDB引擎<strong>全扫描</strong>的接口，让存储引擎定位符合条件的记录</p></li><li><p>执行器会判断读到的记录是不是符合条件，不是则跳过；是则将记录发送给客户（Server 层每从存储引擎读到一条记录就会发送给客户端，之所以客户端显示的时候是直接显示所有记录的，是因为客户端是等查询语句查询完成后，才会显示出所有的记录）</p></li><li><p>执行器查询的过程是一个 while 循环，所以还会再查一次，会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为 all，read_record 函数指针指向的还是 InnoDB 引擎全扫描的接口，所以接着向存储引擎层要求继续读刚才那条记录的下一条记录，存储引擎把下一条记录取出后就将其返回给执行器（Server层），执行器继续判断条件，不符合查询条件即跳过该记录，否则发送到客户端；</p></li><li><p>一直重复上述过程，直到存储引擎把表中的所有记录读完，然后向执行器（Server层） 返回了读取完毕的信息；</p></li><li><p>执行器收到存储引擎报告的查询完毕的信息，退出循环，停止查询。</p></li></ul><h5 id=61433-索引下推>6.1.4.3.3 索引下推</h5><p>索引下推能够减少二级索引在查询时的回表操作，提高查询的效率（它是将server层部分负责的事，交由存储引擎层去处理）</p><h3 id=总结>总结</h3><p>执行一条 SQL 查询语句，期间发生了什么？</p><ul><li><p>连接器：建立连接，管理连接、校验用户身份；</p></li><li><p>查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；</p></li><li><p>解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；</p></li><li><p>执行 SQL：执行 SQL 共有三个阶段：</p><ul><li><p>预处理阶段：检查表或字段是否存在；将 <code>select *</code> 中的 <code>*</code> 符号扩展为表上的所有列。</p></li><li><p>优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；</p></li><li><p>执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；</p></li></ul></li></ul><h2 id=62-mysql存储一行记录>6.2 MySQL存储一行记录</h2><h3 id=总结-1>总结</h3><ul><li>MySQL的NULL值是怎么存放的？</li></ul><p>MySQL的Compact行格式中会使用NULL值列表来标记NULL的列，NULL值并不会存储在行格式中的真实数据</p><p>NULL值列表会占用1字节空间，当表中所有字段都定义成NOT NULL，行格式就不会有NULL值列表，可以节省1字节空间</p><h2 id=6-引擎分类>6.? 引擎分类</h2><p><a href=https://juejin.cn/post/7160557698642083847>https://juejin.cn/post/7160557698642083847</a></p></section></main><footer id=main-footer><div class=footer><a href=#>回到顶部 ↑</a><div class=footer-copyright><div>© 2025 Chen-Hang</div><div>powered by <a href=https://github.com/math-queiroz/rusty-typewriter target=_blank>Rusty Typewriter</a> theme for <a href=https://gohugo.io/ target=_blank>Hugo</a></div></div></div></footer></div><aside id=side-pane class=side-sticky><div class=side-details><span>2544 字数</span>
<span>8 - 10 阅读时间</span><div class=side-details-taxonomy><small>categories:
<span class=details-taxonomy><a href=https://chhz0.github.io/categories/note>Note</a></span></small></div></div><h3>目录</h3><nav id=TableOfContents><ul><li><a href=#61-sql执行过程>6.1 SQL执行过程</a><ul><li><a href=#611-连接器>6.1.1 连接器</a></li><li><a href=#612-查询缓存>6.1.2 查询缓存</a></li><li><a href=#613-解析sql>6.1.3 解析SQL</a></li><li><a href=#614-执行sql>6.1.4 执行SQL</a></li><li><a href=#总结>总结</a></li></ul></li><li><a href=#62-mysql存储一行记录>6.2 MySQL存储一行记录</a><ul><li><a href=#总结-1>总结</a></li></ul></li><li><a href=#6-引擎分类>6.? 引擎分类</a></li></ul></nav><h3>相关</h3><ul><li><a href=/notes/database/mysql/todo/>MySQL - Todo</a></li></ul></aside></div></div></body></html>