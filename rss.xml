<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ch.hugo</title><link>https://chhz0.github.io/</link><description>Recent content on ch.hugo</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Fri, 04 Jul 2025 15:10:00 +0800</lastBuildDate><atom:link href="https://chhz0.github.io/rss.xml" rel="self" type="application/rss+xml"/><item><title>Makefile-learn</title><link>https://chhz0.github.io/blogs/2025/0704.makefile-learn/</link><pubDate>Fri, 04 Jul 2025 15:10:00 +0800</pubDate><guid>https://chhz0.github.io/blogs/2025/0704.makefile-learn/</guid><description>&lt;blockquote>
&lt;p>Makefile 快速入门&lt;/p>&lt;/blockquote>
&lt;h2 id="概述">概述&lt;/h2>
&lt;hr>
&lt;p>&lt;code>makefile&lt;/code> 关系到了整个工程的编译规则，&lt;code>makefile&lt;/code> 定义了一系列的规则来指定，哪些文件需要先编译，哪些文件后需要编译，哪些文件需要重新编译，甚者进行更复杂的功能操作，&lt;code>makefile&lt;/code> 像 &lt;code>shell&lt;/code>脚本一样，其中也可以执行操作系统的命令。&lt;/p>
&lt;p>&lt;code>makefile&lt;/code>带来的好处是-“自动化编译”，一旦写好，一个&lt;code>make&lt;/code>命令，整个工程完全自动编译，极大提高了软件开发的效率。&lt;code>make&lt;/code>是一个命令工具，是一个解释&lt;code>makefile&lt;/code>中指令的命令工具。&lt;/p>
&lt;h2 id="makefile结构说明">Makefile结构说明&lt;/h2>
&lt;hr>
&lt;p>&lt;code>makefile&lt;/code> 主要包含了五个东西：变量定义，显示规则，隐晦规则，文件标示和注释。&lt;/p>
&lt;ol>
&lt;li>变量定义。在&lt;code>makefile&lt;/code>中我们需要定义一系列的变量，一般是字符串，当&lt;code>makefile&lt;/code>被执行时，其中的变量都会被扩展到相应的引用位置上。&lt;/li>
&lt;li>显示规则。说明了如何生成一个或者多个目标文件，由&lt;code>makefile&lt;/code>的书写者明显指出，要生成的文件，文件的依赖文件，生成的文件。【可类似&lt;code>shell&lt;/code>脚本】&lt;/li>
&lt;li>隐晦规则。由于make有自动推导功能，使用隐晦的规则可以让我们比较粗糙地简略书写&lt;code>makefile&lt;/code>&lt;/li>
&lt;li>文件指示。其中包括了三个部分。\&lt;/li>
&lt;li>注释。&lt;code>Makefile&lt;/code>中只有行注释，使用 &lt;code>#&lt;/code> 字符&lt;/li>
&lt;/ol>
&lt;h2 id="makefile中的预定义变量">Makefile中的预定义变量&lt;/h2>
&lt;hr>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>预定变量&lt;/th>
 &lt;th>说明&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>$* 　&lt;/td>
 &lt;td>　不包含扩展名的目标文件名称&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>$+ 　&lt;/td>
 &lt;td>　所有的依赖文件，以空格分开，并以出现的先后为序，可能包含重复的依赖文件&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>$&amp;lt; 　&lt;/td>
 &lt;td>　第一个依赖文件的名称&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>$? 　&lt;/td>
 &lt;td>　所有的依赖文件，以空格分开，这些依赖文件的修改日期比目标的创建日期晚&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>$@ 　&lt;/td>
 &lt;td>目标的完整名称&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>$^ 　&lt;/td>
 &lt;td>　所有的依赖文件，以空格分开，不包含重复的依赖文件&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>$%&lt;/td>
 &lt;td>如果目标是归档成员，则该变量表示目标的归档成员名称&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;h2 id="go-makefile">Go Makefile&lt;/h2>
&lt;hr>
&lt;p>使用&lt;code>makefile&lt;/code>快速编译Go web程序，期望：&lt;/p>
&lt;ul>
&lt;li>高级、简单的命令。比如：&lt;code>compile&lt;/code> &lt;code>start&lt;/code> &lt;code>stop&lt;/code> &lt;code>watch&lt;/code> 等等&lt;/li>
&lt;li>管理具体项目环境的变量，它应该包含 &lt;code>.env&lt;/code> 文件&lt;/li>
&lt;li>开发模式，修改时自动编译&lt;/li>
&lt;li>开发模式，修改时自动重启服务&lt;/li>
&lt;li>开发模式，简洁地显示编译的错误信息&lt;/li>
&lt;li>具体项目的GOPATH，可以在&lt;code>vendor&lt;/code>目录维护依赖包&lt;/li>
&lt;li>简化文件查看，&lt;/li>
&lt;/ul>
&lt;h3 id="1-环境变量">1. 环境变量&lt;/h3>
&lt;p>在&lt;code>makefile&lt;/code>中 &lt;code>include&lt;/code>为项目定义环境变量，第一行如下&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Plaintext" data-lang="Plaintext">&lt;span style="display:flex;">&lt;span>include .env
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>^^^
(待补充&amp;hellip;)&lt;/p>
&lt;h2 id="final最终版本">final.最终版本&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-makefile" data-lang="makefile">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">include&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">.env&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PROJECTNAME&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>shell basename &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>PWD&lt;span style="color:#66d9ef">)&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Go related variables.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>GOBASE&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>shell pwd&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>GOPATH&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>GOBASE&lt;span style="color:#66d9ef">)&lt;/span>&lt;span style="color:#e6db74">/vendor:&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>GOBASE&lt;span style="color:#66d9ef">)&lt;/span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&lt;/span>GOBIN&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>GOBASE&lt;span style="color:#66d9ef">)&lt;/span>/bin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>GOFILES&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>wildcard *.go&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Redirect error output to a file, so we can show it in development mode.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>STDERR&lt;span style="color:#f92672">=&lt;/span>/tmp/.&lt;span style="color:#66d9ef">$(&lt;/span>PROJECTNAME&lt;span style="color:#66d9ef">)&lt;/span>-stderr.txt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># PID file will keep the process id of the server
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>PID&lt;span style="color:#f92672">=&lt;/span>/tmp/.&lt;span style="color:#66d9ef">$(&lt;/span>PROJECTNAME&lt;span style="color:#66d9ef">)&lt;/span>.pid
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Make is verbose in Linux. Make it silent.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>MAKEFLAGS &lt;span style="color:#f92672">+=&lt;/span> --silent
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">## install: Install missing dependencies. Runs `go get` internally. e.g; make install get=github.com/foo/bar
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">install&lt;/span>&lt;span style="color:#f92672">:&lt;/span> go-get
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">## start: Start in development mode. Auto-starts when code changes.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">start&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bash -c &lt;span style="color:#e6db74">&amp;#34;trap &amp;#39;make stop&amp;#39; EXIT; &lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>MAKE&lt;span style="color:#66d9ef">)&lt;/span>&lt;span style="color:#e6db74"> compile start-server watch run=&amp;#39;make compile start-server&amp;#39;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">## stop: Stop development mode.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">stop&lt;/span>&lt;span style="color:#f92672">:&lt;/span> stop-server
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">start-server&lt;/span>&lt;span style="color:#f92672">:&lt;/span> stop-server
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @echo &lt;span style="color:#e6db74">&amp;#34; &amp;gt; &lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>PROJECTNAME&lt;span style="color:#66d9ef">)&lt;/span>&lt;span style="color:#e6db74"> is available at &lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>ADDR&lt;span style="color:#66d9ef">)&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @-&lt;span style="color:#66d9ef">$(&lt;/span>GOBIN&lt;span style="color:#66d9ef">)&lt;/span>/&lt;span style="color:#66d9ef">$(&lt;/span>PROJECTNAME&lt;span style="color:#66d9ef">)&lt;/span> 2&amp;gt;&amp;amp;&lt;span style="color:#ae81ff">1&lt;/span> &amp;amp; echo $$! &amp;gt; &lt;span style="color:#66d9ef">$(&lt;/span>PID&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @cat &lt;span style="color:#66d9ef">$(&lt;/span>PID&lt;span style="color:#66d9ef">)&lt;/span> | sed &lt;span style="color:#e6db74">&amp;#34;/^/s/^/ \&amp;gt; PID: /&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">stop-server&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @-touch &lt;span style="color:#66d9ef">$(&lt;/span>PID&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @-kill &lt;span style="color:#e6db74">`&lt;/span>cat &lt;span style="color:#66d9ef">$(&lt;/span>PID&lt;span style="color:#66d9ef">)&lt;/span>&lt;span style="color:#e6db74">`&lt;/span> 2&amp;gt; /dev/null &lt;span style="color:#f92672">||&lt;/span> true
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @-rm &lt;span style="color:#66d9ef">$(&lt;/span>PID&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">## watch: Run given command when code changes. e.g; make watch run=&amp;#34;echo &amp;#39;hey&amp;#39;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">watch&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @GOPATH&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>GOPATH&lt;span style="color:#66d9ef">)&lt;/span> GOBIN&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>GOBIN&lt;span style="color:#66d9ef">)&lt;/span> yolo -i . -e vendor -e bin -c &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>run&lt;span style="color:#66d9ef">)&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">restart-server&lt;/span>&lt;span style="color:#f92672">:&lt;/span> stop-server start-server
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">## compile: Compile the binary.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">compile&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @-touch &lt;span style="color:#66d9ef">$(&lt;/span>STDERR&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @-rm &lt;span style="color:#66d9ef">$(&lt;/span>STDERR&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @-&lt;span style="color:#66d9ef">$(&lt;/span>MAKE&lt;span style="color:#66d9ef">)&lt;/span> -s go-compile 2&amp;gt; &lt;span style="color:#66d9ef">$(&lt;/span>STDERR&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @cat &lt;span style="color:#66d9ef">$(&lt;/span>STDERR&lt;span style="color:#66d9ef">)&lt;/span> | sed -e &lt;span style="color:#e6db74">&amp;#39;1s/.*/\nError:\n/&amp;#39;&lt;/span> | sed &lt;span style="color:#e6db74">&amp;#39;s/make\[.*/ /&amp;#39;&lt;/span> | sed &lt;span style="color:#e6db74">&amp;#34;/^/s/^/ /&amp;#34;&lt;/span> 1&amp;gt;&amp;amp;&lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">## exec: Run given command, wrapped with custom GOPATH. e.g; make exec run=&amp;#34;go test ./...&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">exec&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @GOPATH&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>GOPATH&lt;span style="color:#66d9ef">)&lt;/span> GOBIN&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>GOBIN&lt;span style="color:#66d9ef">)&lt;/span> &lt;span style="color:#66d9ef">$(&lt;/span>run&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">## clean: Clean build files. Runs `go clean` internally.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">clean&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @&lt;span style="color:#f92672">(&lt;/span>MAKEFILE&lt;span style="color:#f92672">)&lt;/span> go-clean
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">go-compile&lt;/span>&lt;span style="color:#f92672">:&lt;/span> go-clean go-get go-build
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">go-build&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @echo &lt;span style="color:#e6db74">&amp;#34; &amp;gt; Building binary...&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @GOPATH&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>GOPATH&lt;span style="color:#66d9ef">)&lt;/span> GOBIN&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>GOBIN&lt;span style="color:#66d9ef">)&lt;/span> go build -o &lt;span style="color:#66d9ef">$(&lt;/span>GOBIN&lt;span style="color:#66d9ef">)&lt;/span>/&lt;span style="color:#66d9ef">$(&lt;/span>PROJECTNAME&lt;span style="color:#66d9ef">)&lt;/span> &lt;span style="color:#66d9ef">$(&lt;/span>GOFILES&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">go-generate&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @echo &lt;span style="color:#e6db74">&amp;#34; &amp;gt; Generating dependency files...&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @GOPATH&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>GOPATH&lt;span style="color:#66d9ef">)&lt;/span> GOBIN&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>GOBIN&lt;span style="color:#66d9ef">)&lt;/span> go generate &lt;span style="color:#66d9ef">$(&lt;/span>generate&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">go-get&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @echo &lt;span style="color:#e6db74">&amp;#34; &amp;gt; Checking if there is any missing dependencies...&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @GOPATH&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>GOPATH&lt;span style="color:#66d9ef">)&lt;/span> GOBIN&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>GOBIN&lt;span style="color:#66d9ef">)&lt;/span> go get &lt;span style="color:#66d9ef">$(&lt;/span>get&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">go-install&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @GOPATH&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>GOPATH&lt;span style="color:#66d9ef">)&lt;/span> GOBIN&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>GOBIN&lt;span style="color:#66d9ef">)&lt;/span> go install &lt;span style="color:#66d9ef">$(&lt;/span>GOFILES&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">go-clean&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @echo &lt;span style="color:#e6db74">&amp;#34; &amp;gt; Cleaning build cache&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @GOPATH&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>GOPATH&lt;span style="color:#66d9ef">)&lt;/span> GOBIN&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>GOBIN&lt;span style="color:#66d9ef">)&lt;/span> go clean
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">.PHONY&lt;/span>&lt;span style="color:#f92672">:&lt;/span> help
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">all&lt;/span>&lt;span style="color:#f92672">:&lt;/span> help
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">help&lt;/span>&lt;span style="color:#f92672">:&lt;/span> Makefile
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @echo
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @echo &lt;span style="color:#e6db74">&amp;#34; Choose a command run in &amp;#34;&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>PROJECTNAME&lt;span style="color:#66d9ef">)&lt;/span>&lt;span style="color:#e6db74">&amp;#34;:&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @echo
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @sed -n &lt;span style="color:#e6db74">&amp;#39;s/^##//p&amp;#39;&lt;/span> $&amp;lt; | column -t -s &lt;span style="color:#e6db74">&amp;#39;:&amp;#39;&lt;/span> | sed -e &lt;span style="color:#e6db74">&amp;#39;s/^/ /&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @echo
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="相关资料">相关资料&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://blog.csdn.net/haoel/article/details/2886">(陈皓) 跟我一起写 Makefile（一）_haoel的博客-CSDN博客_makefile标签&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/47390641">Makefile由浅入深&amp;ndash;教程、干货 - 知乎 (zhihu.com)&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Mysql Transaction(bate)</title><link>https://chhz0.github.io/notes/database/mysql/mysql-transaction/</link><pubDate>Thu, 03 Jul 2025 23:16:28 +0800</pubDate><guid>https://chhz0.github.io/notes/database/mysql/mysql-transaction/</guid><description>&lt;blockquote>
&lt;p>MySQL 事务&lt;/p>&lt;/blockquote>
&lt;h2 id="1事务有哪些特征">1.事务有哪些特征&lt;/h2>
&lt;p>原子性，隔离性，一致性，持久性&lt;/p>
&lt;ul>
&lt;li>
&lt;p>原子性：要么全做，要么全不做&lt;/p>
&lt;/li>
&lt;li>
&lt;p>隔离性：保证其它的状态转换不会影响到本次状态的转&lt;/p>
&lt;/li>
&lt;li>
&lt;p>一致性：数据全部符合现实世界的约束&lt;/p>
&lt;/li>
&lt;li>
&lt;p>持久性： 更新后的数据存储到磁盘&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>InnoDB引擎通过以下技术来保证事务的四个特性&lt;/p>
&lt;ol>
&lt;li>
&lt;p>持久性是通过 redo log（重做日志）来保证&lt;/p>
&lt;/li>
&lt;li>
&lt;p>原子性是通过 undo log（回滚日志）来保证&lt;/p>
&lt;/li>
&lt;li>
&lt;p>隔离性是通过 mvcc（多版本并发控制）或者锁机制来保证&lt;/p>
&lt;/li>
&lt;li>
&lt;p>一致性是通过持久性+原子性+隔离性来保证&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="2并发事务会引发的问题">2.并发事务会引发的问题&lt;/h2>
&lt;p>MySQL服务端是允许多个客户端连接，这意味着MySQL会出现同时处理多个事务的情况&lt;/p>
&lt;p>在同时处理多个事务的时候，可能会出现脏读、不可重复读、幻读的问题&lt;/p>
&lt;ul>
&lt;li>
&lt;p>脏读：一个事务读到了另一个&lt;strong>未提交事务修改过&lt;/strong>的数据&lt;/p>
&lt;/li>
&lt;li>
&lt;p>不可重复读：在一个事务中多次读取同一个&lt;strong>数据&lt;/strong>，出现前后两次读到的数据不一样的情况&lt;/p>
&lt;/li>
&lt;li>
&lt;p>幻读：在一个事务中多次查询某个符合查询条件的&lt;strong>记录数量&lt;/strong>，如果出现前后两次查询到的记录数据不一样的情况&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>以上三个现象，问题的严重性是 脏读 &amp;gt; 不可重复读 &amp;gt; 幻读&lt;/p>
&lt;h2 id="3事务的隔离级别">3.事务的隔离级别&lt;/h2>
&lt;p>四种隔离级别：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>读未提交：指一个事务还没有提交时，它做的变更就能被其他事务看到&lt;/p>
&lt;/li>
&lt;li>
&lt;p>读提交：指一个事务提交之后，它做的变更才能被其他事务看到&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可重复读：指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，&lt;strong>MySQL&lt;/strong> &lt;strong>InnoDB引擎的默认隔离级别&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>串行化：对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生读写冲突的时候，后访问的事务必须等前一个事务执行完成&lt;/p>
&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>按隔离水平高低排序如下：&lt;/p>
&lt;p>串行化 &amp;gt; 可重复读 &amp;gt; 读已提交 &amp;gt; 读未提交&lt;/p>&lt;/blockquote>
&lt;p>针对不同的隔离级别：并发事务时可能发生的现象也不同&lt;/p>
&lt;ul>
&lt;li>
&lt;p>读未提交：脏读、不可重复读、幻读&lt;/p>
&lt;/li>
&lt;li>
&lt;p>读提交：不可重复读、幻读&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可重复读：幻读&lt;/p>
&lt;/li>
&lt;li>
&lt;p>串行化：&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>可重复读的隔离级别下，可以&lt;strong>很大程度上避免&lt;/strong>幻读现象的发生，所以MySQL不使用串行化隔离级别来避免幻读现象的发生，因为&lt;strong>串行化隔离级别会影响性能&lt;/strong>&lt;/p>
&lt;p>InnoDB在默认隔离级别：&lt;strong>可重复读&lt;/strong>的情况下很大程度上解决幻读现象的解决方案有两种：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>针对**快照读（普通 select 语句），**是通过MVCC方式解决幻读&lt;/p>
&lt;/li>
&lt;li>
&lt;p>针对**当前读（select &amp;hellip; for update），**通过next-key lock（记录锁+间隙锁）方式解决了幻读&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>四种隔离事务是怎么实现的&lt;/p>
&lt;ul>
&lt;li>
&lt;p>对于读未提交：可以读到未提交事务修改的数据，所以直接读取就行&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对于串行化，通过加读写锁的方式来避免并行访问&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对于读提交和可重复读这两种隔离级别的事务，是通过Read View来实现的，它们的区别是在于创建Read View时，读提交隔离级别是在每个语句执行之前都会重新生成一个Read View；而可重复读隔离级别是启动事务时生成一个Read View，然后整个事务都在用这个Read View&lt;/p></description></item><item><title>Mysql Log(bate)</title><link>https://chhz0.github.io/notes/database/mysql/mysql-log/</link><pubDate>Thu, 03 Jul 2025 23:16:14 +0800</pubDate><guid>https://chhz0.github.io/notes/database/mysql/mysql-log/</guid><description>&lt;blockquote>
&lt;p>MySQL 日志 - undo log | redo log | bin log&lt;/p>&lt;/blockquote>
&lt;p>先理解执行一条sql语句，在mysql内部会发生什么？&lt;/p>
&lt;p>以执行一条&lt;code>update&lt;/code> 语句为例：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>客户端会先通过连接器建立连接，连接器会判断用户身份&lt;/p>
&lt;/li>
&lt;li>
&lt;p>这里是一条update语句，所以不需要经过查询缓存（注意，当表上有更新语句，会把整个查询缓存清空，所以在Mysql8.0这个功能就被移除了）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>解析器会通过词法分析识别出关键字，构建出语法树，接着做语法分析，判断输入的语句是否符合MySQL语法&lt;/p>
&lt;/li>
&lt;li>
&lt;p>预处理器会判断表和字段是否存在&lt;/p>
&lt;/li>
&lt;li>
&lt;p>优化器确定执行计划（使用索引或者全表查询）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>执行器负责具体执行，找到这一行然后更新&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>不过，更新语句的流程会涉及到&lt;strong>undo&lt;/strong> &lt;strong>log&lt;/strong>**，redo log，binlog**三种日志：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>undo log（回滚日志）：是InnoDB存储引擎生成的日志，实现了事务中的&lt;strong>原子性&lt;/strong>，主要用于事务回滚和MVCC&lt;/p>
&lt;/li>
&lt;li>
&lt;p>redo log（重做日志）：是InnoDB存储引擎生成的日志，实现了事务中的&lt;strong>持久性&lt;/strong>，主要用于掉电等故障恢复&lt;/p>
&lt;/li>
&lt;li>
&lt;p>bing log（归档日志）：是Server层生成的日志，主要用于数据备份和主从复制&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="1为什么需要undo-log">1.为什么需要undo log？&lt;/h2>
&lt;p>在执行一条“增删改”语句的时候，MySQL会隐式开启事务，执行完后自动提交事务&lt;/p>
&lt;blockquote>
&lt;p>MySQL中执行一条语句后是否自动提交事务，是由&lt;code>autocommit&lt;/code> 参数来决定的，默认是开启的&lt;/p>&lt;/blockquote>
&lt;p>当事务执行过程中，都记录下回滚时需要的信息到一个日志中，那么在事务执行过程中发生MySQL崩溃后，可以通过这个日志回滚到事务之前的数据&lt;/p>
&lt;p>实现这一机制就是 &lt;strong>undo&lt;/strong> &lt;strong>log&lt;/strong>**（回滚日志），它保证了事务的&lt;strong>&lt;strong>ACID&lt;/strong>&lt;/strong>特性中的原子性**&lt;/p>
&lt;p>每当InnoDB引擎对每种操作进行回滚时，进行相反操作就行：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>插入 - 删除&lt;/p>
&lt;/li>
&lt;li>
&lt;p>删除 - 插入&lt;/p>
&lt;/li>
&lt;li>
&lt;p>更新 - 更新为旧值&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>一条记录每次进行操作产生的undo log格式都有一个roll_pointer和一个trx_id事务id：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>trx_id：记录该记录是被哪些事务修改的&lt;/p>
&lt;/li>
&lt;li>
&lt;p>roll_pointer：指针可以将这些undo log串成一个链表，这个链表被称为版本链&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=N2UyNDE0NmNmNDU2N2UyY2Q5NDJkYzZiNzAwMzY3OTRfUjh5Zmw4d3VoWFI5VGZnaFR2a0NsVWk0bVdPTEM2WW5fVG9rZW46V3FmemIzbkhQb1BkRjB4UGFLbWNwR2RpbkRLXzE3MjE4NDExMjk6MTcyMTg0NDcyOV9WNA" alt="">&lt;/p>
&lt;p>另外，undo log可以跟Read View一起实现MVCC（多版本并发控制）：&lt;/p>
&lt;p>对于 &lt;strong>读提交&lt;/strong> 和 &lt;strong>可重复读&lt;/strong> 隔离级别的事务来说，它们的快照读（普通select语句）是通过Read View + undo log来实现的，区别在于创建Read View的时机不同&lt;/p>
&lt;ul>
&lt;li>
&lt;p>读提交：是在每一个select都会生成一个新的Read View，也意味着事务期间的多次读取同一数据，前后两次读的数据可能会出现不一致（不可重复读）&lt;/p></description></item><item><title>Mysql Lock(bate)</title><link>https://chhz0.github.io/notes/database/mysql/mysql-lock/</link><pubDate>Thu, 03 Jul 2025 23:16:11 +0800</pubDate><guid>https://chhz0.github.io/notes/database/mysql/mysql-lock/</guid><description>&lt;blockquote>
&lt;p>MySQL 锁 - 全局锁|表级锁|行级锁&lt;/p>&lt;/blockquote>
&lt;h2 id="锁的类型">锁的类型&lt;/h2>
&lt;p>Mysql的锁，根据加锁的范围可以分为全局锁、表级锁和行锁三类&lt;/p>
&lt;h3 id="全局锁">全局锁&lt;/h3>
&lt;p>要使用全局锁，执行下面这条命令：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C" data-lang="C">&lt;span style="display:flex;">&lt;span>flush tables with read lock
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>执行之后，整个数据库就处于只读状态，这时其他线程执行以下操作，就会被阻塞&lt;/p>
&lt;ul>
&lt;li>
&lt;p>对数据的增删改，比如insert、delete、update等&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对表结构的更改操作，比如alter table、drop table等&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>要释放全局锁，执行下面的命令：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C" data-lang="C">&lt;span style="display:flex;">&lt;span>unlock tables
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>全局锁的应用场景：&lt;/p>
&lt;p>全局锁主要用于做&lt;strong>全库逻辑备份&lt;/strong>，这样在备份数据库期间，不会因为数据或者结构的更新，而出现备份文件的数据与预期的不一样&lt;/p>&lt;/blockquote>
&lt;p>加全局锁带来的缺点：会导致业务停滞，因为加全局锁之后，整个数据库都只是只读状态，不能更新数据&lt;/p>
&lt;p>可以通过开启事务，在可重复读的隔离级别下，即使其他事务更新了表的数据，也不会影响备份数据库时的Read View，&lt;/p>
&lt;p>备份数据库的工具是&lt;code>mysqldump&lt;/code> ，在使用mysqldump时加上&lt;code>-single-transaction&lt;/code> 参数的时候，就会在备份数据库之前开启事务&lt;/p>
&lt;h3 id="表级锁">表级锁&lt;/h3>
&lt;p>MySQL里面表级锁有以下几种：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>表锁&lt;/p>
&lt;/li>
&lt;li>
&lt;p>元数据锁（MDL）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>意向锁&lt;/p>
&lt;/li>
&lt;li>
&lt;p>AUTO-INC锁&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h4 id="表锁">表锁&lt;/h4>
&lt;p>使用下面的命令对表加锁和释放锁&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C" data-lang="C">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 加读锁
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>lock tables &lt;span style="color:#f92672">&amp;lt;&lt;/span>table_name&lt;span style="color:#f92672">&amp;gt;&lt;/span> read;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 写锁
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>lock tables &lt;span style="color:#f92672">&amp;lt;&lt;/span>table_name&lt;span style="color:#f92672">&amp;gt;&lt;/span> write;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 释放锁
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>unlock tables;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>表锁会影响别的线程和本线程的读写操作&lt;/p>
&lt;h4 id="元数据锁mdl">元数据锁（MDL）&lt;/h4>
&lt;p>对于MDL，我们不需要显示使用，因为当我们在对数据库进行操作时，会自动给这个表上加MDL：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>对一张表进行CURD操作时，加的是MDL读锁&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对一张表做结构变更操作的时候，加的是MDL写锁&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>MDL是为了保证当前用户对表执行CRUD操作时，防止其他线程对这个表结构做了变更&lt;/p>
&lt;p>MDL是在事务提交之后才会释放，这意味着&lt;strong>事务执行期间，MDL是一直持有&lt;/strong>&lt;/p>
&lt;p>需要注意的是，在事务启用之后，如果事务A没有提交，此时如果有表结构的修改请求发起，就会发生阻塞，这个阻塞也会导致其他CURD的请求被阻塞住&lt;/p>
&lt;p>这是因为申请MDL锁的操作会形成一个队列，队列中&lt;strong>写锁&lt;strong>&lt;strong>获取优先级大于&lt;/strong>&lt;/strong>读锁&lt;/strong>，一旦出现MDL写锁等待，会阻塞该表后续的CRUD操作&lt;/p>
&lt;h4 id="意向锁">意向锁&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>在使用InnoDB引擎的表里对某些记录加上共享锁之前，需要先在表级别加上一个意向共享锁&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在使用InnoDB引擎的表里对某些记录加上独占锁之前，需要先在表级别加上一个意向独占锁&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>在执行insert、update、delete操作时，需要先对表上加 意向独占锁，然后对该记录加独占锁&lt;/p>
&lt;p>而普通的select是不会加行级锁，普通的select语句是利用MVCC实现一致性读，是无锁的&lt;/p></description></item><item><title>Mysql Index(bate)</title><link>https://chhz0.github.io/notes/database/mysql/mysql-index/</link><pubDate>Thu, 03 Jul 2025 23:16:07 +0800</pubDate><guid>https://chhz0.github.io/notes/database/mysql/mysql-index/</guid><description>&lt;blockquote>
&lt;p>MySQL 索引&lt;/p>&lt;/blockquote>
&lt;h2 id="1-b树索引数据结构">1. B+树（索引数据结构）&lt;/h2>
&lt;p>什么是索引？
为什么索引能加快查询？
索引的数据结构是什么？
B+ 树 和（B 树 和 红黑树）有什么区别？
为什么选择 B+树 作为索引数据结构？&lt;/p>
&lt;h3 id="为什么mysql-innodb选择b-tree作为索引">为什么Mysql InnoDB选择B+ Tree作为索引？&lt;/h3>
&lt;ol>
&lt;li>B+ 树 vs B 树
B+ 树只在叶子节点存储数据，B树的非叶子节点也要存储数据，所以B+ 树的单个节点的数据量更小&lt;/li>
&lt;li>B+ 树 vs 二叉树
对于有N个叶子节点的B+ 树，搜索复制度为O（logdn）&lt;/li>
&lt;li>B+ 树 vs Hash&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>&lt;a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%98%E5%AE%9D%E5%85%B8/08%20%20%E7%B4%A2%E5%BC%95%EF%BC%9A%E6%8E%92%E5%BA%8F%E7%9A%84%E8%89%BA%E6%9C%AF.md">08 索引:排序的艺术&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://xiaolincoding.com/mysql/index/why_index_chose_bpuls_tree.html">为什么 MySQL 采用 B+ 树作为索引？&lt;/a>&lt;/p>&lt;/blockquote>
&lt;h2 id="2-索引组织表索引存储">2. 索引组织表（索引存储）&lt;/h2>
&lt;p>堆表和索引组织表有什么区别？&lt;/p>
&lt;p>分别应用场景是什么？&lt;/p>
&lt;p>Mysql InnoDB存储引擎中数据存储方式：&lt;strong>索引组织表&lt;/strong>&lt;/p>
&lt;p>数据存储有&lt;strong>堆表和索引组织表两种。&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>堆表中的数据是无序存放的，数据的排序完全依赖索引&lt;/p>
&lt;/li>
&lt;li>
&lt;p>索引组织表，数据根据主键进行排序存放在索引中，主键索引也叫&lt;strong>聚集索引&lt;/strong>（Clustered Index）&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>在索引组织表中，数据即索引，索引即数据&lt;/p>
&lt;h3 id="二级索引">二级索引&lt;/h3>
&lt;p>InnoDB存储引擎的数据是根据主键索引排序存储的，除了主键索引外，其它的索引都称为二级索引（Secondeary Index），或者非聚集索引&lt;/p>
&lt;p>二级索引也是一颗B+树索引，但是它和主键索引不同的是叶子节点存放的是索引键值、主键值&lt;/p>
&lt;p>通过二级索引&lt;code>idx_name&lt;/code> 只能定位主键值，需要额外再通过主键索引进行查询，才能得到最终结果。&lt;/p>
&lt;p>&lt;strong>这种二级索引通过&lt;strong>&lt;strong>主键&lt;/strong>&lt;/strong>索引进行再一次查询的操作叫做“回表”&lt;/strong>&lt;/p>
&lt;p>这样的二级索引设计的好处：若记录发生了修改，则其它索引无须进行维护，除非记录的主键发生了修改&lt;/p>
&lt;p>&lt;strong>在索引组织表中，万物皆索引，索引就是数据，数据就是索引&lt;/strong>。&lt;/p>
&lt;h3 id="二级索引的性能评估">二级索引的性能评估&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>要比较顺序，对聚集索引性能友好&lt;/p>
&lt;/li>
&lt;li>
&lt;p>尽可能紧凑，对二级索引的性能和存储友好&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="函数索引先了解">函数索引（先了解）&lt;/h3>
&lt;p>&amp;hellip;&lt;/p></description></item><item><title>Mysql Buffer Pool(bate)</title><link>https://chhz0.github.io/notes/database/mysql/mysql-buffer-pool/</link><pubDate>Thu, 03 Jul 2025 23:15:59 +0800</pubDate><guid>https://chhz0.github.io/notes/database/mysql/mysql-buffer-pool/</guid><description>&lt;blockquote>
&lt;p>MySQL 缓存池&lt;/p>&lt;/blockquote>
&lt;h2 id="为什么要有buffer-pool">为什么要有Buffer Pool&lt;/h2>
&lt;p>MySQL的数据存储在磁盘的，如果每次都从磁盘里面读取数据，这样性能是很差的&lt;/p>
&lt;p>提高性能，就需要加入缓存。当数据从磁盘中取出来之后，缓存内存中，下次查询同样的数据，直接从内存中读取&lt;/p>
&lt;p>为此InnoDB存储引擎设计了&lt;strong>一个缓存池（Buffer Pool），来提高数据库的读写性能&lt;/strong>&lt;/p>
&lt;p>有了缓冲池后：&lt;/p>
&lt;ul>
&lt;li>读取数据时，如果数据存在于Buffer Pool中，客户端就会直接读取Buffer Pool中的数据，否则再去磁盘中读取&lt;/li>
&lt;li>当修改数据时，首先修改Buffer Pool中数据所在的数据页，然后将该页设置为脏页，最后由后台线程将脏页写入到磁盘&lt;/li>
&lt;/ul>
&lt;h2 id="buffer-pool有多大">Buffer Pool有多大？&lt;/h2>
&lt;p>Buffer Pool在MySQL启动的时候，向操作系统申请的一片连续的内存空间，默认配置下Buffer Pool只有&lt;code>128MB&lt;/code>&lt;/p>
&lt;p>可以通过调整&lt;code>innodb_buffer_pool_size&lt;/code> 参数来设置Buffer Pool的大小，一般建议设置为可用物理内存的60%~80%&lt;/p>
&lt;h2 id="buffer-pool缓存什么">Buffer Pool缓存什么？&lt;/h2>
&lt;p>InnoDB会把存储的数据分为若干个&lt;strong>页&lt;/strong>，以页作为磁盘和内存交互的基本单位，一个页的默认大小为**16kb，**因此Buffer Pool同样需要按页来划分&lt;/p>
&lt;p>在MySQL启动的时候，**InnoDB会为Buffer Pool申请一片连续的&lt;strong>&lt;strong>内存&lt;/strong>&lt;/strong>空间，然后按照默认的16&lt;strong>&lt;strong>kb&lt;/strong>&lt;/strong>的大小划分出一个个的页，Buffer Pool中的页就叫做缓存页。**这些缓存页都是空的，之后随着程序的运行，才会有磁盘上的页被缓存到Buffer Pool中&lt;/p>
&lt;p>所以，MySQL刚启动的时候，其使用的虚拟内存空间很大，而使用到的物理内存空间很小，这时因为这些虚拟内存被访问后，操作系统才会触发缺页中断，接着将虚拟地址和物理地址建立映射关系&lt;/p>
&lt;p>Buffer Pool缓存了以下的：&lt;/p>
&lt;ul>
&lt;li>索引页&lt;/li>
&lt;li>数据页&lt;/li>
&lt;li>插入缓存页&lt;/li>
&lt;li>Undo页&lt;/li>
&lt;li>自适应哈希索引&lt;/li>
&lt;li>锁信息&lt;/li>
&lt;/ul>
&lt;p>为了更好管理Buffer Pool中的缓存页，InnoDB为每一个缓存页都创建了一个**控制块，**控制块包括缓存页的表空间，页号，缓存页地址，链表节点等，控制块也占据内存空间，它是在Buffer Pool的最前面，接着才是缓存页&lt;/p>
&lt;p>暂时无法在飞书文档外展示此内容&lt;/p>
&lt;p>上面的控制块和缓存页之间的空白空间称为&lt;strong>碎片空间&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>碎片空间：每一个控制块对应一个缓存页，在分配足够多的控制块和缓存页后，可能剩余的空间不足够一个控制块和缓存页的大小，那么这块空间就不被使用，剩下的这块空间就被称为碎片&lt;/p>
&lt;p>当Buffer Pool的大小设置的刚刚好，就不会产生碎片&lt;/p>&lt;/blockquote>
&lt;p>查询一条记录时，InnoDB会把整个页的数据加载到Buffer Pool中，通过索引只能定位到磁盘中的页，而不能定位到页中一条记录。&lt;/p>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s/A5gNVXMNE-iIlY3oofXtLw">mp.weixin.qq.com&lt;/a>(从数据页的角度看B+树——InnoDB存储引擎)&lt;/p>
&lt;p>记录是按照行来存储的，但是数据库的读取并不是以&lt;strong>行&lt;/strong>为单位，否则一次读取（一次IO操作）只能处理一行数据，效率会非常低，因此，&lt;strong>InnoDB的数据是按照数据页为单位来读写的&lt;/strong>&lt;/p>
&lt;p>数据页的结构分为7个部分&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>&lt;/th>
 &lt;th>&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>File Header(38)&lt;/td>
 &lt;td>文件头，表示页的信息&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>Page Header(56)&lt;/td>
 &lt;td>页头，表示页的状态信息&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>infimum+supermun(26)&lt;/td>
 &lt;td>两个虚拟伪记录，分别表示页中最小记录和最大记录&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>User Records(unclear)&lt;/td>
 &lt;td>存储行记录内容&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>Free Space(unclear)&lt;/td>
 &lt;td>页中还没被使用的&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>Page Directory(unclear)&lt;/td>
 &lt;td>页目录，存储用户记录的相对位置，对记录起索引作用&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>File Tailer(8)&lt;/td>
 &lt;td>校验页是否完整&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>其中，行记录由&lt;code>infimum+supremum&lt;/code> 和 &lt;code>User Records&lt;/code>构成&lt;/p></description></item><item><title>Mysql Arch(bate)</title><link>https://chhz0.github.io/notes/database/mysql/mysql-arch/</link><pubDate>Thu, 03 Jul 2025 23:15:49 +0800</pubDate><guid>https://chhz0.github.io/notes/database/mysql/mysql-arch/</guid><description>&lt;blockquote>
&lt;p>MySQL 架构- server &amp;amp;&amp;amp; storage-engine&lt;/p>&lt;/blockquote>
&lt;h2 id="61-sql执行过程">6.1 SQL执行过程&lt;/h2>
&lt;p>推荐阅读 &lt;a href="https://xiaolincoding.com/mysql/base/how_select.html#mysql-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84">小林coding/mysql&lt;/a>&lt;/p>
&lt;p>MySQL架构分为两层：&lt;strong>server层和存储引擎层&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Server层负责建立连接、分析和执行SQL
&lt;ul>
&lt;li>MySQL大多数核心功能模块都在这里：连接器、查询缓存、解析器、预处理器、优化器、执行器等&lt;/li>
&lt;li>还有所有的内置函数&lt;/li>
&lt;li>所有跨存储引擎的功能&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>存储引擎层负责数据的存储和提取
&lt;ul>
&lt;li>支持InnoDB、MyISAM、Memory等多个存储引擎&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="611-连接器">6.1.1 连接器&lt;/h3>
&lt;p>MySQL是基于TCP协议进行传输的，所以在连接MySQL的时候需要先进行TCP三次握手，在命令行使用命令进行连接&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Bash" data-lang="Bash">&lt;span style="display:flex;">&lt;span>mysql -h $ip -u$user -p
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>用户通过用户密码成功连接后，连接器会获取用户的权限，然后保存起来，在后续的此连接的任何操作，都会基于连接开始的时候读取到的权限逻辑进行判断&lt;/p>
&lt;p>建立连接后，即使修改了该用户的权限，也不影响已连接的权限。只有新建的连接才会有新的权限设置&lt;/p>
&lt;h4 id="6111-查看mysql服务的客户端连接">6.1.1.1 查看MySQL服务的客户端连接&lt;/h4>
&lt;p>可以执行&lt;code>show processlist&lt;/code> 命令进行查看&lt;/p>
&lt;h4 id="6112-空闲连接会一直占着">6.1.1.2 空闲连接会一直占着&lt;/h4>
&lt;p>不会，MySQL定义了空闲连接的最大空闲时长，由&lt;code>wait_timeout&lt;/code> 参数控制，默认值是8小时，超过这个时间，连接器就会把这个连接断开&lt;/p>
&lt;p>使用命令可以查看该值&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Bash" data-lang="Bash">&lt;span style="display:flex;">&lt;span>show variables like &lt;span style="color:#e6db74">&amp;#39;wait_timeout&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以手动断开空闲的连接，使用的是&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-SQL" data-lang="SQL">&lt;span style="display:flex;">&lt;span>kill &lt;span style="color:#66d9ef">connection&lt;/span> &lt;span style="color:#f92672">+&lt;/span> id
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当空闲的连接被服务端主动断开后，这个客户端并不会马上知道，等到客户端在发起下一个请求时，才会收到报错&lt;/p>
&lt;p>“ERROR 2013 (HY000): Lost connection to MySQL server during query”&lt;/p>
&lt;h4 id="6113-mysql的连接限制">6.1.1.3 MySQL的连接限制&lt;/h4>
&lt;p>MySQL服务支持的最大连接数由&lt;code>max_connections&lt;/code> 参数控制&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Bash" data-lang="Bash">&lt;span style="display:flex;">&lt;span>show variables like &lt;span style="color:#e6db74">&amp;#39;max_connections&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>MySQL的连接跟HTTP一样，有短连接和长连接的概念&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-SQL" data-lang="SQL">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">//&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">短连接&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">连接&lt;/span> mysql &lt;span style="color:#960050;background-color:#1e0010">服务（&lt;/span>TCP &lt;span style="color:#960050;background-color:#1e0010">三次握手）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">执行&lt;/span>&lt;span style="color:#66d9ef">sql&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">断开&lt;/span> mysql &lt;span style="color:#960050;background-color:#1e0010">服务（&lt;/span>TCP &lt;span style="color:#960050;background-color:#1e0010">四次挥手）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">//&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">长连接&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">连接&lt;/span> mysql &lt;span style="color:#960050;background-color:#1e0010">服务（&lt;/span>TCP &lt;span style="color:#960050;background-color:#1e0010">三次握手）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">执行&lt;/span>&lt;span style="color:#66d9ef">sql&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">执行&lt;/span>&lt;span style="color:#66d9ef">sql&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">执行&lt;/span>&lt;span style="color:#66d9ef">sql&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>....
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">断开&lt;/span> mysql &lt;span style="color:#960050;background-color:#1e0010">服务（&lt;/span>TCP &lt;span style="color:#960050;background-color:#1e0010">四次挥手）&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>一般推荐长连接，但是使用长连接可能会占用内存增多，因为_MySQL在执行查询过程中临时使用内存管理连接对象__，_只有在连接断开的时候才会释放&lt;/p></description></item><item><title>Git Repo Readme(bate)</title><link>https://chhz0.github.io/notes/git/git-repo-readme/</link><pubDate>Thu, 03 Jul 2025 23:09:20 +0800</pubDate><guid>https://chhz0.github.io/notes/git/git-repo-readme/</guid><description>&lt;blockquote>
&lt;p>Git 仓库 README.md 规范&lt;/p>&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-markdown" data-lang="markdown">&lt;span style="display:flex;">&lt;span># 项目名称
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&amp;lt;!-- 写一段简短的话描述项目 --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">## 功能特性
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&amp;lt;!-- 描述该项目的核心功能点 --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">## 软件架构(可选)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&amp;lt;!-- 可以描述下项目的架构 --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">## 快速开始
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">### 依赖检查
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&amp;lt;!-- 描述该项目的依赖，比如依赖的包、工具或者其他任何依赖项 --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">### 构建
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&amp;lt;!-- 描述如何构建该项目 --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">### 运行
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&amp;lt;!-- 描述如何运行该项目 --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">## 使用指南
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&amp;lt;!-- 描述如何使用该项目 --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">## 如何贡献
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&amp;lt;!-- 告诉其他开发者如果给该项目贡献源码 --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">## 社区(可选)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&amp;lt;!-- 如果有需要可以介绍一些社区相关的内容 --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">## 关于作者
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&amp;lt;!-- 这里写上项目作者 --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">## 谁在用(可选)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&amp;lt;!-- 可以列出使用本项目的其他有影响力的项目，算是给项目打个广告吧 --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">## 许可证
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&amp;lt;!-- 这里链接上该项目的开源许可证 --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Git Commit(bate)</title><link>https://chhz0.github.io/notes/git/git-commit/</link><pubDate>Thu, 03 Jul 2025 23:08:59 +0800</pubDate><guid>https://chhz0.github.io/notes/git/git-commit/</guid><description>&lt;blockquote>
&lt;p>写出符合Angular规范的Git Commit Message&lt;/p>&lt;/blockquote>
&lt;h2 id="git-commit-规范">git commit 规范&lt;/h2>
&lt;h3 id="符合angular规范的commit-message">符合Angular规范的Commit Message&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>&amp;lt;type&amp;gt;[(optional scope)]: &amp;lt;description&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>// 空行
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[optional body]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>// 空行
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[optional footers]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>分为了Header、Body、footer三个部分&lt;/p>
&lt;h4 id="header">Header&lt;/h4>
&lt;p>Header部分只有一行&lt;code>&amp;lt;type&amp;gt;[(optional scope)]: &amp;lt;description&amp;gt;&lt;/code>，其中type必选，其它可选&lt;/p>
&lt;p>type&amp;ndash;&amp;gt;归为两类：&lt;/p>
&lt;ul>
&lt;li>Development(项目管理类变更，不影响用户和生产环境的代码)&lt;/li>
&lt;li>Production(影响用户和生产环境的代码)&lt;/li>
&lt;/ul>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>类型&lt;/th>
 &lt;th>类别&lt;/th>
 &lt;th>说明&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>feat&lt;/td>
 &lt;td>Production&lt;/td>
 &lt;td>新增功能&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>fix&lt;/td>
 &lt;td>Production&lt;/td>
 &lt;td>修复缺陷&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>perf&lt;/td>
 &lt;td>Production&lt;/td>
 &lt;td>提高代码性能的变更&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>style&lt;/td>
 &lt;td>Development&lt;/td>
 &lt;td>代码格式类的变更，例如使用gofmt格式化代码&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>refactor&lt;/td>
 &lt;td>Production&lt;/td>
 &lt;td>其他代码类的变更，例如 简化代码、重命名变量、删除冗余代码等等&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>test&lt;/td>
 &lt;td>Development&lt;/td>
 &lt;td>新增测试用例或更新现有的测试用例&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>ci&lt;/td>
 &lt;td>Development&lt;/td>
 &lt;td>持续基础和部署相关的改动，例如修改Jenkins、GitLab CI等Ci配置文件或者更新系统单元文件&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>docs&lt;/td>
 &lt;td>Development&lt;/td>
 &lt;td>文档类的更新，包括修改用户文档、开发文档&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>chore&lt;/td>
 &lt;td>Development&lt;/td>
 &lt;td>其他类型，例如构建流程、依赖管理或者复制工具的变动&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>scope&amp;ndash;&amp;gt;不设置太具体的值，说明commit的影响范围
description&amp;ndash;&amp;gt;对commit的简短描述，以动词开头&lt;/p>
&lt;h4 id="body">Body&lt;/h4>
&lt;p>Body对Commit Message的高度概况，方便查看具体做了什么变更&lt;/p>
&lt;h4 id="footer">Footer&lt;/h4>
&lt;p>Footer部分不是必选，可根据需要选择，主要用来说什么本次commit导致的后果，通常用来说明不兼容的改动或者关闭的issue&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>BREAKING CHANGE: &amp;lt;breaking change summary&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>// 空行
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;breaking change description + migration instructions&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>// 空行
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>// 空行
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Fixes(Closes) #&amp;lt;issue number&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="revert-commit">Revert Commit&lt;/h4>
&lt;p>特殊的Commit Message。还原了先前的commit，则以&lt;code>revert&lt;/code>开头，后面跟还原的commit的Header，
在Body必须写&lt;code>This reverts commit &amp;lt;hash&amp;gt;&lt;/code>，其中hash为要还原的commit的SHA标识&lt;/p></description></item><item><title>Git Commands(bate)</title><link>https://chhz0.github.io/notes/git/git-commands/</link><pubDate>Thu, 03 Jul 2025 23:08:11 +0800</pubDate><guid>https://chhz0.github.io/notes/git/git-commands/</guid><description>&lt;blockquote>
&lt;p>git 命令&lt;/p>&lt;/blockquote>
&lt;h2 id="git-rebase">git rebase&lt;/h2>
&lt;p>git rebase的最大作用是重写历史&lt;/p>
&lt;p>使用&lt;code>git rebase -i &amp;lt;commit ID&amp;gt;&lt;/code>使用git rebase命令 修改某次 commit 的 message&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>命令&lt;/th>
 &lt;th>目的&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>p,pick&lt;/td>
 &lt;td>不对该commit做任何处理&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>r,reword&lt;/td>
 &lt;td>保留该commit，但是修改提交信息&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>e,edit&lt;/td>
 &lt;td>保留该commit，但是rebase是会暂停，允许你修改这个commit&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>s,squash&lt;/td>
 &lt;td>保留该commit，但是将当前commit与上一个commit合并&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>f,fixup&lt;/td>
 &lt;td>与squash相同，但不会保存当前commit的提交信息&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>x,exec&lt;/td>
 &lt;td>执行其他shell命令&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>d,drop&lt;/td>
 &lt;td>删除该commit&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;h2 id="git-commit--amend">git commit -amend&lt;/h2>
&lt;p>git commit –amend：修改最近一次 commit 的 message&lt;/p></description></item><item><title>Deploy Go applications using docker(bate)</title><link>https://chhz0.github.io/notes/docker/docker-deploy/</link><pubDate>Thu, 03 Jul 2025 22:17:26 +0800</pubDate><guid>https://chhz0.github.io/notes/docker/docker-deploy/</guid><description>&lt;blockquote>
&lt;p>使用Docker 以及Docker Compose部署Go程序&lt;/p>&lt;/blockquote>
&lt;h3 id="部署示例">部署示例&lt;/h3>
&lt;h4 id="1准备代码">1.准备代码&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Plaintext" data-lang="Plaintext">&lt;span style="display:flex;">&lt;span>package main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>import (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;fmt&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;net/http&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>func main() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> http.HandleFunc(&amp;#34;/&amp;#34;, hello)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> server := &amp;amp;http.Server{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Addr: &amp;#34;:8888&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.Println(&amp;#34;server startup...&amp;#34;)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> if err := server.ListenAndServe(); err != nil {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.Printf(&amp;#34;server startup failed, err:%v\n&amp;#34;, err)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>func hello(w http.ResponseWriter, _ *http.Request) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> w.Write([]byte(&amp;#34;hello liwenzhou.com!&amp;#34;))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里是简单代码&lt;/p>
&lt;h4 id="2创建docker镜像">2.创建Docker镜像&lt;/h4>
&lt;blockquote>
&lt;p>镜像(image)包含运行应用程序所需的所有东西——代码/二进制文件、运行时、依赖项以及所需的任何其它人间系统对象&lt;/p>&lt;/blockquote>
&lt;p>简单讲，镜像是定义应用程序以及运行所需的一切&lt;/p>
&lt;h4 id="3编写dockerfile">3.编写Dockerfile&lt;/h4>
&lt;p>要创建Docker镜像(image)必须在配置文件中的指定步骤，这个文件默认称为&lt;code>Dockerfile&lt;/code>&lt;/p></description></item><item><title>Dockerfile(bate)</title><link>https://chhz0.github.io/notes/docker/dockerfile/</link><pubDate>Thu, 03 Jul 2025 22:17:17 +0800</pubDate><guid>https://chhz0.github.io/notes/docker/dockerfile/</guid><description>&lt;blockquote>
&lt;p>Dockerfile 构建你自己的容器&lt;/p>&lt;/blockquote>
&lt;p>学习自&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://juejin.cn/post/7179042892395053113">一篇文章带你吃透 Dockerfile - 掘金 (juejin.cn)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.docker.com/engine/reference/builder/">Dockerfile reference&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://juejin.cn/post/7042663735156015140">全网最详细的Docker-Compose详细教程 - 掘金 (juejin.cn)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/387840381">docker compose 配置文件 .yml 全面指南 - 知乎 (zhihu.com)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/compose-spec/compose-spec/blob/master/spec.md">compose-spec/spec.md at master · compose-spec/compose-spec · GitHub&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>学习Dockers前期，通过Docker的官方镜像仓库拉取里面的镜像，根据这些镜像创建出容器并运行&lt;/p>
&lt;p>实际上，Docker官方镜像也是通过一定的方式构建出来的，只要弄清其中的逻辑，我们也可以仿照官方镜像的构建过程，构建出自己的镜像&lt;/p>
&lt;p>&lt;code>Dockerfile&lt;/code>就是这样一个用于描述Docker镜像构建过程的文本文件，dockerfile可以包含多条构建指令，以及相关的描述&lt;/p>
&lt;h3 id="1什么是容器">1.什么是容器&lt;/h3>
&lt;p>容器是计算机上的沙盒进程，与主机上的其它进程隔离，这种隔离利用了&lt;code>内核命名空间和cgroups&lt;/code>。简而言之容器是：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>是&lt;code>image&lt;/code>的可运行实例&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可以在本地计算机、虚拟机上运行或部署到云中&lt;/p>
&lt;/li>
&lt;li>
&lt;p>是可移植的&lt;/p>
&lt;/li>
&lt;li>
&lt;p>与其它容器隔离，并运行自己的软件，二进制文件和配置&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="2什么是容器映射">2.什么是容器映射&lt;/h3>
&lt;p>当容器运行时，它使用了隔离的文件系统。这个自定义的文件系统由容器映像&lt;code>container image&lt;/code>提供。因为image包含了容器的问价系统，使用image必须包含所有的运行应用程序所必须的所有东西——依赖项、配置、脚本、二进制文件等等。&lt;/p>
&lt;blockquote>
&lt;p>沙盒进程是指在计算机系统中，为了保障安全和隔离性而采用的一种技术，将应用程序运行在一个受限制的环境中，限制它们能访问的资源和操作范围，从而避免恶意程序和授权程序对系统的破坏&lt;/p>&lt;/blockquote>
&lt;h3 id="3容器是怎么运行的">3.容器是怎么运行的&lt;/h3>
&lt;p>当一个容器运行时，它为其文件系统使用来image的各个层。每个容器都有自己的命名空间来创建/更新/删除文件。在另一个容器中不会看到任何更改，即使它们使用相同的image&lt;/p>
&lt;h3 id="4容器卷container-volumes">4.容器卷[container volumes]&lt;/h3>
&lt;p>每个容器启动时都是从容器的定义开始的。在容器中可以创建、更新和删除文件，但当容器被删除时，这些改变将回丢失，所有更变都被隔离在各个容器中&lt;/p>
&lt;p>卷：提供了将容器的特定文件系统路径链路到主机的能力。如果在主机上的某个文件被挂载，那么当容器中该文件路径下的文件发送更改时，我们在主机上同样也可以看到更改。同样的，启动另一个挂载了同一个文件目录的容器，它也可以访问到相同的文件&lt;/p>
&lt;h2 id="镜像构建原理">镜像构建原理&lt;/h2>
&lt;hr>
&lt;h3 id="1docker架构模式">1.Docker架构模式&lt;/h3>
&lt;p>&lt;img src="https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=ODNkMzZjNzQ1MTljOTE0ZThhNjliYjMwODFiMjQ0NTJfSVlseWZldFNjR0l6QVpDbzFMdmNhYXg1TWRZb1oxUjZfVG9rZW46RjhBeWJoWkZpb2ZZbll4WEd2dGN3RXJHbkxoXzE3MjE4NDA4ODE6MTcyMTg0NDQ4MV9WNA" alt="">&lt;/p>
&lt;p>&lt;code>docker&lt;/code>使用了&lt;strong>client&lt;/strong>/&lt;strong>server&lt;/strong>的架构模式。构建镜像时，用户在&lt;strong>dockers&lt;/strong> &lt;strong>client&lt;/strong>输入构建命令。&lt;strong>docker&lt;/strong>引擎以 &lt;code>REST API&lt;/code>的形式，像 &lt;strong>docker&lt;/strong> &lt;strong>daemon&lt;/strong>发送构建请求，如何dockers daemon就根据构建请求的内容，开始镜像构建的工作，并向Client持续放回构建过程的信息。&lt;/p>
&lt;h3 id="2镜像分层模型">2.镜像分层模型&lt;/h3>
&lt;hr>
&lt;p>&lt;strong>docker&lt;/strong>镜像是用于创建容器的只读模板，是通过 &lt;strong>Dockerfile&lt;/strong>中定义的指令构建而成的，构建结束后，会在原有的镜像层上生成一个新的镜像层，如下所示&lt;/p>
&lt;p>&lt;img src="https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=NmE5Yjk1OTNiMTc0MDI5YmU0NGZiNTNjZDU4NDQ5MDFfZmlPNWJYSnRaQ0RUSnJZNXpGSmN0anNFN1V6WGw4VkRfVG9rZW46RU9scmI4N0Jrb2RQVHJ4cVJFM2NwNlNtblBkXzE3MjE4NDA4ODE6MTcyMTg0NDQ4MV9WNA" alt="">&lt;/p>
&lt;p>在 tomcat 镜像创建一个容器后，会在tomcat镜像之上新创建一个可写的容器层，在容器中写文件时，会保存到这个容器层中&lt;/p>
&lt;p>&lt;img src="https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=MWU3YzUzYTM5OTE3NmZkZmEyNjhiYjZhYjljZTFiOTZfaTY2T1RORTY0UEVXWVJ0cnZ4RGxnSVE2ZGE0QWtsVlVfVG9rZW46Vk5McWI1RVV1b2h5WFV4aHBPM2NrcTNRbnVnXzE3MjE4NDA4ODE6MTcyMTg0NDQ4MV9WNA" alt="">&lt;/p>
&lt;h3 id="3基础镜像与父级镜像">3.基础镜像与父级镜像&lt;/h3>
&lt;hr>
&lt;p>用于构建基础镜像的 &lt;strong>Dockerfile&lt;/strong> 不指定父级镜像，Docker约定使用如下形式基础镜像&lt;/p></description></item><item><title>Docker(bate)</title><link>https://chhz0.github.io/notes/docker/docker/</link><pubDate>Thu, 03 Jul 2025 22:17:11 +0800</pubDate><guid>https://chhz0.github.io/notes/docker/docker/</guid><description>&lt;blockquote>
&lt;p>Docker 一文&lt;/p>&lt;/blockquote>
&lt;blockquote>
&lt;p>&lt;a href="https://yeasy.gitbook.io/docker_practice/">https://yeasy.gitbook.io/docker_practice/&lt;/a>&lt;/p>&lt;/blockquote>
&lt;h2 id="一基本概念">一、基本概念&lt;/h2>
&lt;ul>
&lt;li>镜像(&lt;code>Image&lt;/code>)&lt;/li>
&lt;li>容器(&lt;code>Container&lt;/code>)&lt;/li>
&lt;li>仓库(&lt;code>Repository&lt;/code>)&lt;/li>
&lt;/ul>
&lt;p>理解以上三个概念，就能理解docker的生命周期&lt;/p>
&lt;h3 id="1镜像">1.镜像&lt;/h3>
&lt;p>&lt;strong>Docker镜像&lt;/strong>是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件，以及一些运行时所需的配置参数。镜像不包含任何动态数据，其内容在插件之后也不会被改变&lt;/p>
&lt;p>&lt;strong>分层存储&lt;/strong>，镜像采用了分层存储的架构，由一组文件系统组成的（多层文件系统联合组成）。在构建镜像时，会一层一层构建，后一层依赖于上一层，后一层上的任何改变都只会发生在本层，不会干涉到上一层。因此构建镜像的时候，需要对每层需要添加的东西尽量加最少最有必要的东西，减少额外的东西&lt;/p>
&lt;p>分层存储的特征还使得&lt;strong>镜像的复用，定制&lt;/strong>更为容易&lt;/p>
&lt;h3 id="2容器">2.容器&lt;/h3>
&lt;p>容器是镜像运行时的实体，可以被创建、启动、停止、删除暂停等&lt;/p>
&lt;blockquote>
&lt;p>镜像(Image)和容器(container)的关系，就像是面向对象程序设计中的&lt;code>类&lt;/code> 和&lt;code>实例&lt;/code> 一样&lt;/p>&lt;/blockquote>
&lt;p>容器的实质是进程，运行于属于自己的独立的命名空间。因此容器可以拥有自己的&lt;code>root&lt;/code> 文件系统，网络配置、进程空间等，运行在一个隔离的环境。这样的隔离特性，使得容器封装的应用比直接在宿主运行更加安全&lt;/p>
&lt;p>容器也是分层存储，是&lt;strong>以镜像为基础层&lt;/strong>，在其上创建一个当前容器的存储层，这个层是为容器运行时进行读写而准备的，称为&lt;strong>容器存储层&lt;/strong>&lt;/p>
&lt;p>容器存储层的生命周期跟容器一样，当容器消亡时，容器存储层也随之消亡，因此任何保存于容器存储层的信息都会随着容器的删除而丢失&lt;/p>
&lt;blockquote>
&lt;p>Dokcer最佳实践的要求，容器不应该向其存储层写入任何数据，容器存储层保存无状态化，所有的文件写入操作，都应该使用数据卷、或者绑定宿主目录&lt;/p>
&lt;p>数据卷独立于容器，使用容器卷，容器的删除或者重写运行之后，数据都不会丢失&lt;/p>&lt;/blockquote>
&lt;h3 id="3仓库">3.仓库&lt;/h3>
&lt;p>Docker Register：提供一个集中的存储、分发镜像的服务&lt;/p>
&lt;p>一个&lt;strong>Docker Register&lt;/strong>可以包含多个**仓库（&lt;strong>&lt;strong>Repository&lt;/strong>&lt;/strong>）;&lt;strong>每个仓库可以包含多个&lt;/strong>标签（Tag）,**每个标签对应一个镜像&lt;/p>
&lt;p>可以通过&lt;code>&amp;lt;Repository Name&amp;gt;:&amp;lt;Tag Name&amp;gt;&lt;/code> 的格式来指定具体的软件是那个版本的镜像&lt;/p>
&lt;p>仓库名以两段路径形式出现，比如&lt;code>jwilder/nginx-proxy&lt;/code> 前者是Docker Registry多用户环境下的用户名，后者是对应的软件名&lt;/p>
&lt;h3 id="docker-registry-公开服务">Docker Registry 公开服务&lt;/h3>
&lt;p>Docker Registry公开服务是开放给用户使用、允许用户管理镜像的Registry服务。&lt;/p>
&lt;p>最常见的是Docker Registry公开服务是官方的&lt;a href="https://hub.docker.com/">hub.docker.com&lt;/a>，也是默认的Registry&lt;/p>
&lt;p>也可以使用国内的镜像网站&lt;/p>
&lt;h3 id="私有docker-registry">私有Docker Registry&lt;/h3>
&lt;p>用户可以在本地搭建私有的Docker Registry。Docker提供了Docker Registry镜像，可以直接使用搭建私有Registry服务&lt;/p>
&lt;h2 id="二镜像">二、镜像&lt;/h2>
&lt;h3 id="1获取镜像">1.获取镜像&lt;/h3>
&lt;p>从Docker镜像仓库获取镜像的命令是 &lt;code>docker pull&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Dockerfile" data-lang="Dockerfile">&lt;span style="display:flex;">&lt;span>docker pull &lt;span style="color:#f92672">[&lt;/span>选项&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">[&lt;/span>Docker Registry 地址&lt;span style="color:#f92672">[&lt;/span>:端口号&lt;span style="color:#f92672">]&lt;/span>/&lt;span style="color:#f92672">]&lt;/span> 仓库名&lt;span style="color:#f92672">[&lt;/span>:标签&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>具体选项可以从&lt;code>docker pull --help&lt;/code> 命令查看，&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Docker镜像仓库地址：地址格式一般为 &lt;code>&amp;lt;域名/IP&amp;gt;[:端口号]&lt;/code>。默认地址是 Docker Hub&lt;/p></description></item><item><title>Redis - Todo</title><link>https://chhz0.github.io/notes/database/redis/todo/</link><pubDate>Thu, 03 Jul 2025 22:06:22 +0800</pubDate><guid>https://chhz0.github.io/notes/database/redis/todo/</guid><description>&lt;blockquote>
&lt;p>Redis代办事项&lt;/p>&lt;/blockquote>
&lt;ul>
&lt;li>&lt;input disabled="" type="checkbox"> Redis 数据结构
&lt;ul>
&lt;li>&lt;input disabled="" type="checkbox"> 字符串 String&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 链表 LinkList&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 集合 Set&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 有序集合 ZSet&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 哈希表 Hash&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 跳表 SkipList&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> Redis 架构
&lt;ul>
&lt;li>&lt;input disabled="" type="checkbox"> 单线程模型&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> Reactor&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 多线程&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 过期淘汰算法&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> Redis 持久化
&lt;ul>
&lt;li>&lt;input disabled="" type="checkbox"> AOF&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> RDB&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 混合持久&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> Redis 缓存应用
&lt;ul>
&lt;li>&lt;input disabled="" type="checkbox"> 缓存击穿&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 缓存穿透&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 缓存雪崩&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 缓存一致性&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> Redis 集群
&lt;ul>
&lt;li>&lt;input disabled="" type="checkbox"> 主从模式&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 哨兵模式&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 集群模式&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 一致性hash&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> Redis 应用场景
&lt;ul>
&lt;li>&lt;input disabled="" type="checkbox"> 分布式锁&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 查询缓存&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>MySQL - Todo</title><link>https://chhz0.github.io/notes/database/mysql/todo/</link><pubDate>Wed, 02 Jul 2025 15:37:39 +0800</pubDate><guid>https://chhz0.github.io/notes/database/mysql/todo/</guid><description>&lt;blockquote>
&lt;p>MySQL 内容代办事项&lt;/p>&lt;/blockquote>
&lt;ul>
&lt;li>&lt;input disabled="" type="checkbox"> SQL基础语法&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> MySQL架构
&lt;ul>
&lt;li>&lt;input disabled="" type="checkbox"> client层&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> server层
&lt;ul>
&lt;li>&lt;input disabled="" type="checkbox"> 连接器&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 查询缓存&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 解析器&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 优化器&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 执行器&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 存储引擎
&lt;ul>
&lt;li>&lt;input disabled="" type="checkbox"> InnoDB
&lt;ul>
&lt;li>&lt;input disabled="" type="checkbox"> 表空间&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 数据页结构&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 行记录存储&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> Buffer Pool&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> MyISAM&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> Memory&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> MySQL索引
&lt;ul>
&lt;li>&lt;input disabled="" type="checkbox"> 数据结构
&lt;ul>
&lt;li>&lt;input disabled="" type="checkbox"> B+树索引&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> Hash索引&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> Full-text&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 索引类型
&lt;ul>
&lt;li>&lt;input disabled="" type="checkbox"> 聚簇索引&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 非聚簇索引&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 索引优化
&lt;ul>
&lt;li>&lt;input disabled="" type="checkbox"> 主键索引&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 唯一索引&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 普通索引&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 联合索引&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 前缀索引&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 索引失效
&lt;ul>
&lt;li>&lt;input disabled="" type="checkbox"> 索引覆盖&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 索引下推&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 索引选择&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> MySQL事务
&lt;ul>
&lt;li>&lt;input disabled="" type="checkbox"> ACID
&lt;ul>
&lt;li>&lt;input disabled="" type="checkbox"> 原子性&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 隔离性&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 持久性&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 一致性&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 事务并发
&lt;ul>
&lt;li>&lt;input disabled="" type="checkbox"> 脏读&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 不可重复读&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 幻读&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 事务隔离级别
&lt;ul>
&lt;li>&lt;input disabled="" type="checkbox"> 读未提交&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 读已提交&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 可重复读&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 串行化&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 隔离级别实现
&lt;ul>
&lt;li>&lt;input disabled="" type="checkbox"> MVCC&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 锁&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> MySQL锁
&lt;ul>
&lt;li>&lt;input disabled="" type="checkbox"> 全局锁&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 表级锁
&lt;ul>
&lt;li>&lt;input disabled="" type="checkbox"> 表锁&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> MDL锁&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 意向锁&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 自增锁&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 局部锁
&lt;ul>
&lt;li>&lt;input disabled="" type="checkbox"> 记录锁&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 间隙锁&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 临键锁&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 插入意见锁&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 死锁&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> MySQL日志
&lt;ul>
&lt;li>&lt;input disabled="" type="checkbox"> undo log&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> redo log
&lt;ul>
&lt;li>&lt;input disabled="" type="checkbox"> WAL&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 两阶段提交&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> bin log&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> MySQL调优
&lt;ul>
&lt;li>&lt;input disabled="" type="checkbox"> explain 解释计划&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 查询性能调优&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 分页调优&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 连接池&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> MySQL高可用
&lt;ul>
&lt;li>&lt;input disabled="" type="checkbox"> 读写分离&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 分库分表&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 分布式ID&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 分布式锁&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 数据迁移&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 分布式事务&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 高可用&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 分布式数据库&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 数据库设计
&lt;ul>
&lt;li>&lt;input disabled="" type="checkbox"> 设计规范(三范式)&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 设计原则&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 反范式设计&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Redis - Encoding&lt;HashTable></title><link>https://chhz0.github.io/notes/database/redis/datatypes/encoding/hashtable/</link><pubDate>Tue, 10 Jun 2025 22:36:08 +0800</pubDate><guid>https://chhz0.github.io/notes/database/redis/datatypes/encoding/hashtable/</guid><description>&lt;h2 id="redis-enc-hashtable-">Redis&amp;lt; enc-HashTable &amp;gt;&lt;/h2>
&lt;p>&lt;code>HASHTABLE&lt;/code>可以使用O(1)时间复杂度能够快速找到&lt;code>field&lt;/code>对应的&lt;code>value&lt;/code>，简单理解，&lt;code>HASHTABLE&lt;/code>是一个目录，可以帮助我们快速找到需要内容&lt;/p>
&lt;p>&lt;code>HASHTABLE&lt;/code>的结构:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">typedef&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> dictht {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dictEntry &lt;span style="color:#f92672">**&lt;/span>table;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> size;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> sizemask;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> used;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} dictht;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最外层封装一个&lt;code>dictht&lt;/code>结构，字段含义如下：&lt;/p>
&lt;ul>
&lt;li>&lt;code>Table&lt;/code>: 指向实际hash存储。存储可以看做一个数组&lt;/li>
&lt;li>&lt;code>Size&lt;/code>: 哈希表大小，实际就是dictEntry有多少元素空间&lt;/li>
&lt;li>&lt;code>Sizemask&lt;/code>: 哈希表大小的掩码表示，总是等于size-1. 这个属性和哈希值一起决定一个键应该放到table数组的那个索引上面，规则 &lt;strong>Index = hash &amp;amp; sizemask&lt;/strong>.&lt;/li>
&lt;li>&lt;code>Used&lt;/code>: 表示已经使用的节点数量。通过这个字段可以查询目前HASHTABLE元素总量&lt;/li>
&lt;/ul>
&lt;p>&lt;code>dictEntry&lt;/code>结构如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">typedef&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> dictEntry {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>key;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">union&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>val;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">uint64_t&lt;/span> u64;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int64_t&lt;/span> s64;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">double&lt;/span> d;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } v;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> dictEntry &lt;span style="color:#f92672">*&lt;/span>next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>metadata[];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} dictEntry;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://chhz0.github.io/redis/redis-encoding-hashtable-struct.drawio.svg" alt="redis-encodng-hashtable-struct">&lt;/p>
&lt;h3 id="hash-渐进式扩容缩容">Hash 渐进式扩容/缩容&lt;/h3>
&lt;h4 id="扩容">扩容&lt;/h4>
&lt;p>渐进式扩容就是一点一点扩大&lt;code>HASHTABLE&lt;/code>的容量，默认值为4 (#define DICT_HT_INTTIAL_SIZE 4)
为了实现渐进式扩容，Redis没有直接把dictht暴露给上层，而是再封装了一层&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">typedef&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> dict {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dictType &lt;span style="color:#f92672">*&lt;/span>type;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>privdata;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dictht ht[&lt;span style="color:#ae81ff">2&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> rehashidx;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> iterators;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} dict;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>dict&lt;/code>结构里面，包含了2个dictht结构，也就是2个HASHTABLE结构。&lt;/p></description></item><item><title>Redis - Encoding&lt;sds></title><link>https://chhz0.github.io/notes/database/redis/datatypes/encoding/sds/</link><pubDate>Tue, 10 Jun 2025 22:36:08 +0800</pubDate><guid>https://chhz0.github.io/notes/database/redis/datatypes/encoding/sds/</guid><description>&lt;h2 id="redis-enc-sds-">Redis&amp;lt; enc-SDS &amp;gt;&lt;/h2>
&lt;p>sds(Simple Synamic String)，简单动态字符串，是redis内部作为基石的字符串封装（很重要）&lt;/p>
&lt;p>sds是redis封装字符串结构，用以解决字符串追加和长度计算操作来带的性能瓶颈问题&lt;/p>
&lt;p>redis中SDS分为sdshdr8、sdshdr16、sdshdr32、sdshdr64，字段属性一致，区别再对应不同大小的字符串&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">__attribute__&lt;/span>((__packed__)) sdshdr8 {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">uint8_t&lt;/span> len; &lt;span style="color:#75715e">// 使用了多少内部
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">uint8_t&lt;/span> alloc; &lt;span style="color:#75715e">// 分配了多少内存
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> flags; &lt;span style="color:#75715e">// 标记是什么分类 例如： #define SDS_TYPE_8 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> buf[];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>从上面的结构可以看出SDS是怎么解决问题的：&lt;/p>
&lt;ol>
&lt;li>增加len字段，快速返回长度&lt;/li>
&lt;li>增加空余空间(alloc - len)，为后续追加数据留余地&lt;/li>
&lt;li>不要以&amp;rsquo;\0&amp;rsquo;作为判断标准，二进制安全&lt;/li>
&lt;/ol>
&lt;p>SDS预留空间大小的规则：alloc = min(len, 1M) + len：&lt;/p>
&lt;ul>
&lt;li>len小于1M的情况下，alloc=2*len, 预留len大小的空间&lt;/li>
&lt;li>len大于1M的情况下，alloc=1M+lne, 预留1M大小的空间&lt;/li>
&lt;/ul></description></item><item><title>Redis - Encoding&lt;SkipList></title><link>https://chhz0.github.io/notes/database/redis/datatypes/encoding/skiplist/</link><pubDate>Tue, 10 Jun 2025 22:36:08 +0800</pubDate><guid>https://chhz0.github.io/notes/database/redis/datatypes/encoding/skiplist/</guid><description>&lt;h2 id="redis-enc-skiplist-">Redis&amp;lt; enc-SkipList &amp;gt;&lt;/h2>
&lt;p>跳表是Redis有序集合ZSet底层的数据结构&lt;/p>
&lt;p>redis中跳表的两处应用：&lt;/p>
&lt;pre>&lt;code>1. 实现有序集合键
2. 在集群节点中作为内部数据结构
&lt;/code>&lt;/pre>
&lt;p>从本质上看是链表，这种结构虽然简单清晰，但是查询某个节点的效率比较低，而在有序集合场景，无论是查找还是添加删除元素，我们是需要快速通过score定位到具体位置，如果是链表的话时间复杂度是O(N)&lt;/p>
&lt;p>为了提高查找的性能，Redis引入跳表，跳表在链表的基础上，给链表增加了多级的索引，通过索引可以一次实现多个节点的跳跃，提高性能&lt;/p>
&lt;h3 id="skiplist-结构">SKIPLIST 结构&lt;/h3>
&lt;p>Redis &lt;code>SKIPLIST&lt;/code> 单节点的结构:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">typedef&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> zskiplistNode {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sds ele;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">double&lt;/span> score;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> zskiplistNode &lt;span style="color:#f92672">*&lt;/span>backward;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> zskiplistLevel {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> zskiplistNode &lt;span style="color:#f92672">*&lt;/span>forward;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> span;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } level[];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} zskiplistNode;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>字段的定义：&lt;/p>
&lt;ul>
&lt;li>&lt;code>Ele&lt;/code>: SDS结构，用来存储数据&lt;/li>
&lt;li>&lt;code>Score&lt;/code>: 节点的分数，浮点型数据&lt;/li>
&lt;li>&lt;code>Backward&lt;/code>: 指向上一个节点的回退指针，支持从表尾向表头遍历，也就是ZREVRANGE这个命令&lt;/li>
&lt;li>&lt;code>level&lt;/code>: 是个zskiplistLevel结构体数组，包含两个字段，一个是forward，指向该层下个能跳到的节点，span记录距离下个节点的步数，数组结构表示每个节点可能是多层结构&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>在标准的跳表中，score值是不可重复的，但是在Redis ZIPLIST中，score值是可重复的，增加了回退指针&lt;/p>&lt;/blockquote>
&lt;h3 id="skiplist-细节">SKIPLIST 细节&lt;/h3>
&lt;ul>
&lt;li>Redis跳表单个节点有几层？&lt;/li>
&lt;/ul>
&lt;p>层次的决定，需要比较随机，才能在各个场景表现出较平均的性能，这里Redis使用概率均衡的思路来确定插入节点的层数：&lt;/p>
&lt;p>Redis跳表决定每一个节点，是否能增加一层的概率为25%，而最大层数限制在Redis 5.0是64层，在Redis 7.0是32层&lt;/p>
&lt;ul>
&lt;li>Redis跳表的性能优化了多少？&lt;/li>
&lt;/ul>
&lt;p>平均时间复杂度为O(log(n))，跳表的最坏平均时间复杂度是O(N)，当然实际的生产过程中，体现出来的基本是跳表的平均时间复杂度&lt;/p></description></item><item><title>Redis - Encoding&lt;ZipList></title><link>https://chhz0.github.io/notes/database/redis/datatypes/encoding/ziplist/</link><pubDate>Tue, 10 Jun 2025 22:36:08 +0800</pubDate><guid>https://chhz0.github.io/notes/database/redis/datatypes/encoding/ziplist/</guid><description>&lt;h2 id="redis-enc-ziplist-">Redis&amp;lt; enc-ZipList &amp;gt;&lt;/h2>
&lt;p>&lt;code>ZIPLIST&lt;/code>压缩列表，是排列紧凑的列表，为Redis供紧凑型的数据存储方式，能节约内存（节省链表指针的开销），数据量小的时候遍历访问性能好（连续+缓存命中率友好）&lt;/p>
&lt;p>关于&lt;code>LISTPACK&lt;/code>是Redis 5.0引入，Redis 7.0完全替代&lt;code>ZIPLIST&lt;/code>.&lt;/p>
&lt;h3 id="ziplsit-整体结构">ZIPLSIT 整体结构&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>// redis代码注释，描述了ZIPLIST的结构
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;zlbytes&amp;gt; &amp;lt;zltail&amp;gt; &amp;lt;zllen&amp;gt; &amp;lt;entry&amp;gt; &amp;lt;entry&amp;gt; ... &amp;lt;entry&amp;gt; &amp;lt;zlend&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>各字段定义：&lt;/p>
&lt;ul>
&lt;li>&lt;code>zlbytes&lt;/code>: 表示该ZIPLIST一共占了多少字节，这个数字是包含zlbytes本身占据的字节的&lt;/li>
&lt;li>&lt;code>zltail&lt;/code>: ZIPLIST尾巴节点，相对于ZIPLIST的开头，偏移的字节数&lt;/li>
&lt;li>&lt;code>zllen&lt;/code>: 表示有多少个数据节点&lt;/li>
&lt;li>&lt;code>entry&lt;/code>: 表示压缩列表的数据节点&lt;/li>
&lt;li>&lt;code>zlend&lt;/code>: 一个特殊的entry节点，为1个字节&lt;code>11111111&lt;/code>即255占据，表示ZIPLIST的结束&lt;/li>
&lt;/ul>
&lt;h3 id="ziplist-节点结构---entrys">ZIPLIST 节点结构 - entrys&lt;/h3>
&lt;p>其定义如下&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span> * &amp;lt;prevlen&amp;gt; &amp;lt;encoding&amp;gt; &amp;lt;entry-data&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>各字段含义：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>prevlen&lt;/code>: 表示前一个节点的长度。通过该节点定位到前一个节点的起始地址，如果前一个节点是压缩列表的开头，那么这个字段的值为0，通过该字段，可以实现往前操作，即&lt;code>ZIPLIST&lt;/code>可以从后往前遍历.&lt;/p>
&lt;blockquote>
&lt;p>有关上一个&lt;code>entry&lt;/code>的长度，从&lt;code>prevlen&lt;/code>字段可以获得，根据&lt;code>entry&lt;/code>的大小，&lt;code>prevlen&lt;/code>所占字节也会有所变化:&lt;/p>
&lt;ul>
&lt;li>entry &amp;lt; 254 : &lt;code>prevlen&lt;/code>为1字节，(值得注意的是255在entry中是个特殊数字，被&lt;code>zlend&lt;/code>使用，表示&lt;code>ZIPLIST&lt;/code>的结束)&lt;/li>
&lt;li>entry &amp;gt;= 254 : &lt;code>prevlen&lt;/code>为5字节，在这5个字节中，第一个字节作为标志位，固定为&lt;code>11111110&lt;/code>，表示&lt;code>prevlen&lt;/code>是5个字节，后面4个字节才是&lt;code>prevlen&lt;/code>记录的上一个节点长度.&lt;/li>
&lt;/ul>&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>&lt;code>encoding&lt;/code>: 编码类型，包含了entry的长度信息，用于正序遍历.&lt;/p>
&lt;blockquote>
&lt;p>encoding是一个整型数据，其二进制数据由&lt;code>entry-data&lt;/code>的类型和字节长度组成&lt;/p>
&lt;ul>
&lt;li>如果是string类型，那么encoding由两部分，前几位为标识位、后几位标识长度&lt;/li>
&lt;li>如果是int类型，整体1字节编码，那么仅标识类型，根据不同的int类型，确定其长度，例如int32就是32位，4字节&lt;/li>
&lt;/ul>&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>&lt;code>entry-data&lt;/code>: 实际的数据&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="ziplist-查询数据">ZIPLIST 查询数据&lt;/h3>
&lt;ul>
&lt;li>获取节点数量
&lt;code>ZIPLIST&lt;/code>可以在O(1)时间复杂度返回节点数量，因为其header定义了记录节点数量的&lt;code>zllen&lt;/code>，但是&lt;code>zllen&lt;/code>仅占2字节长度，最大记录&lt;strong>65534&lt;/strong>，当节点数量超过65535时，就需要通过遍历节点获取节点数量.&lt;/li>
&lt;/ul>
&lt;p>之所以zllen是2个字节，原因是redis中应用ZIPLIST是为了节点个数少的场景，所以将zllen设计得比较小，节约内存空间&lt;/p></description></item><item><title>Redis - Hash</title><link>https://chhz0.github.io/notes/database/redis/datatypes/hash/</link><pubDate>Tue, 10 Jun 2025 22:36:08 +0800</pubDate><guid>https://chhz0.github.io/notes/database/redis/datatypes/hash/</guid><description>&lt;h2 id="redis--hash-">Redis &amp;lt; Hash &amp;gt;&lt;/h2>
&lt;p>Redis Hash 是结构化为字段值(field)-&amp;gt;值(value)集合的记录类型. 可以使用&lt;code>Hash&lt;/code>来表示基础对象并存储计数器分组.&lt;/p>
&lt;blockquote>
&lt;p>创建的&lt;code>Hash&lt;/code>数量没有实际限制，除了受到可用内存的限制，
但是每个&lt;code>Hash&lt;/code>最多可以存储 4,294,967,295 (2^32 - 1) 个字段值对&lt;/p>&lt;/blockquote>
&lt;p>&lt;code>Hash&lt;/code>可以很方便的表示对象&lt;/p>
&lt;h3 id="hash-命令">Hash 命令&lt;/h3>
&lt;p>Hash常用命令：&lt;/p>
&lt;ul>
&lt;li>创建：&lt;code>HSET&lt;/code>, &lt;code>HSETNX&lt;/code>
&lt;ul>
&lt;li>&lt;code>HSET key field value&lt;/code> # 为集合对于field设置value，可以一次设置多个field-value&lt;/li>
&lt;li>&lt;code>HSETNX key field value&lt;/code> # 如果field不存在，则为集合对应field设置value数据&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>查询：&lt;code>HGETALL&lt;/code>, &lt;code>HGET&lt;/code>, &lt;code>HLEN&lt;/code>, &lt;code>HSCAN&lt;/code>
&lt;ul>
&lt;li>&lt;code>HGETALL key&lt;/code> # 查找全部数据&lt;/li>
&lt;li>&lt;code>HGET key field&lt;/code> # 查找某个key（field）&lt;/li>
&lt;li>&lt;code>HLEN key&lt;/code> # 查找Hash中元素总数&lt;/li>
&lt;li>&lt;code>HSCAN key cursor [MATCH pattern] [COUNT count]&lt;/code> # 从指定位置查询一定数量的数据，这里注意如果是小数据量下，处于ZIPLIST时，COUNT不管填多少，都是返回全部，因为ZIPLIST本身就用于小集合，没必要切分几段返回&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>更新：&lt;code>HSET&lt;/code>, &lt;code>HSETNX&lt;/code>, &lt;code>HDEL&lt;/code>
&lt;ul>
&lt;li>&lt;code>HDEL key field [field ...]&lt;/code> # 删除指定field，可以一次删除多个&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>删除：&lt;code>DEL&lt;/code>
&lt;ul>
&lt;li>&lt;code>DEL key [key ...]&lt;/code> # 删除Hash对象&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="hash-编码底层实现">Hash 编码(底层实现)&lt;/h3>
&lt;p>Hash底层有两个编码方式：&lt;code>ZIPLIST&lt;/code>, &lt;code>HASHTABLE&lt;/code>&lt;/p></description></item><item><title>Redis - List</title><link>https://chhz0.github.io/notes/database/redis/datatypes/list/</link><pubDate>Tue, 10 Jun 2025 22:36:08 +0800</pubDate><guid>https://chhz0.github.io/notes/database/redis/datatypes/list/</guid><description>&lt;h2 id="redis--list-">Redis &amp;lt; List &amp;gt;&lt;/h2>
&lt;p>Redis List是一组连续的字符串值&lt;strong>链表&lt;/strong>，这意味着向List的头部或者尾部中添加新元素的操作会在恒定的时间内完成，
无论其已经存储了多少元素，但是缺点是访问元素的操作则需要遍历List，时间复杂度为O(N)&lt;/p>
&lt;p>Redis List经常用于:&lt;/p>
&lt;ul>
&lt;li>实现堆栈和队列&lt;/li>
&lt;li>为后台系统构建队列管理&lt;/li>
&lt;/ul>
&lt;h3 id="list-命令">List 命令&lt;/h3>
&lt;p>常用命令:&lt;/p>
&lt;ul>
&lt;li>创建 &amp;ndash;&amp;gt; &lt;code>LPUSH&lt;/code>, &lt;code>RPUSH&lt;/code>
&lt;ul>
&lt;li>&lt;code>LPUSH key value [value ...]&lt;/code> # 从头部增加元素，返回List中元素总数&lt;/li>
&lt;li>&lt;code>RPUSH key value [value ...]&lt;/code> # 从尾部增加元素，返回List中元素总数&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>查询 &amp;ndash;&amp;gt; &lt;code>LLEN&lt;/code>, &lt;code>LRANGE&lt;/code>
&lt;ul>
&lt;li>&lt;code>LLEN&lt;/code> # 查看List的长度，即List中元素的总数&lt;/li>
&lt;li>&lt;code>LRANGE key start stop&lt;/code> # 查看start到stop为角标的元素&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>更新 &amp;ndash;&amp;gt; &lt;code>LPUSH&lt;/code>, &lt;code>RPUSH&lt;/code>, &lt;code>LPOP&lt;/code>, &lt;code>RPOP&lt;/code>, &lt;code>LREM&lt;/code>
&lt;ul>
&lt;li>&lt;code>LPOP key&lt;/code> # 移除并获取列表的第一个元素&lt;/li>
&lt;li>&lt;code>RPOP key&lt;/code> # 移除并获取列表的第一个元素&lt;/li>
&lt;li>&lt;code>LREM key count value&lt;/code> # 移除值等于value的元素
&lt;ul>
&lt;li>count = 0 ，则移除所有等于value的元素；&lt;/li>
&lt;li>count &amp;gt; 0 ，则从左到右开始移除count个value元素；&lt;/li>
&lt;li>count &amp;lt; 0，则从右往左移除count个元素&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>删除 &amp;ndash;&amp;gt; &lt;code>DEL&lt;/code>, &lt;code>UNLINK&lt;/code>
&lt;ul>
&lt;li>&lt;code>DEL key [key ...]&lt;/code> # 删除对象，返回值为删除成功了几个键&lt;/li>
&lt;li>&lt;code>UNLIKN key [key ...]&lt;/code> # 删除对象，返回值为删除成功了几个键&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>del命令与unlink命令均为删除对象，不同的是del命令是同步删除目录，会阻塞客户端，直到删除完成；
unlink命令是异步删除命令，只是取消key在键空间的关联，让其不在能查到，删除是异步进行，所以不会阻塞客户端.&lt;/p></description></item><item><title>Redis - Multi Thread</title><link>https://chhz0.github.io/notes/database/redis/arch/multi-thread/</link><pubDate>Tue, 10 Jun 2025 22:36:08 +0800</pubDate><guid>https://chhz0.github.io/notes/database/redis/arch/multi-thread/</guid><description>&lt;blockquote>
&lt;p>Redis 多线程持久化 | IO复用&lt;/p>&lt;/blockquote>
&lt;h2 id="redis-多线程持久化">Redis 多线程持久化&lt;/h2>
&lt;p>Redis多线程模型&lt;/p>
&lt;p>redis一开始就是基于单线程模型，Redis里所有的数据结构都是非线程安全，规避了数据竞争问题，使得Redis对各种数据结构的操作非常简单&lt;/p>
&lt;blockquote>
&lt;p>redis选择单线程的核心原因是Redis都是内存操作，CPU处理都非常快，瓶颈更容易出现在I/O而不是CPU，所以选择了单线程模型&lt;/p>&lt;/blockquote>
&lt;p>随着数据量的增大，redis的瓶颈更容易出现在I/O而不是CPU&lt;/p>
&lt;p>因为上述情况，Redis选择了引入多线程来处理网络I/O，这样即保持了Redis核心的单线程处理价格，又引入了多线程解决提高网络I/O的性能&lt;/p></description></item><item><title>Redis - redisDB</title><link>https://chhz0.github.io/notes/database/redis/arch/redisdb/</link><pubDate>Tue, 10 Jun 2025 22:36:08 +0800</pubDate><guid>https://chhz0.github.io/notes/database/redis/arch/redisdb/</guid><description>&lt;blockquote>
&lt;p>Redis是一个基于内存的数据库，数据存储在内存中，以键值对的形式存储.&lt;/p>&lt;/blockquote>
&lt;h2 id="redis-数据库结构">Redis 数据库结构&lt;/h2>
&lt;p>Redis的数据库结构：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// redisDb 结构
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>type &lt;span style="color:#66d9ef">struct&lt;/span> redisDb {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dict &lt;span style="color:#f92672">*&lt;/span>dict; &lt;span style="color:#75715e">//字典
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> dict &lt;span style="color:#f92672">*&lt;/span>expires; &lt;span style="color:#75715e">// 过期键
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> dict &lt;span style="color:#f92672">*&lt;/span>blocking_keys;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dict &lt;span style="color:#f92672">*&lt;/span>ready_keys;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dict &lt;span style="color:#f92672">*&lt;/span>watched_keys;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> id;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> avg_ttl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> list &lt;span style="color:#f92672">*&lt;/span>defrag_later;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} redisDb;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// dict 结构
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">typedef&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> dict {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dictType &lt;span style="color:#f92672">*&lt;/span>type;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>privdata;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dictht ht[&lt;span style="color:#ae81ff">2&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> rehashidx;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> iterators;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} dict;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>redisDb&lt;/code> 代表Redis数据库结构，各种操作对象，都存储在dict数据结构里.&lt;/p>
&lt;ul>
&lt;li>&lt;code>dict&lt;/code> 是Redis的字典结构，存储键值对.&lt;/li>
&lt;li>&lt;code>expires&lt;/code> 是Redis的过期键字典结构，存储过期键.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://chhz0.github.io/redis/redis-redisDb-struct.drawio.svg" alt="redis-redisDb-struct">&lt;/p>
&lt;h3 id="操作redis在内存中的表现">操作Redis在内存中的表现&lt;/h3>
&lt;ul>
&lt;li>&lt;code>添加数据&lt;/code> # 即添加键值对，添加到dict结构字典中，Key必须为String对象，value为任何类型的对象，添加数据后，会在redisDb里字段dict上添加dict对象&lt;/li>
&lt;li>&lt;code>查询数据&lt;/code> # 直接在dict找到对应的key，即完成查询&lt;/li>
&lt;li>&lt;code>更新数据&lt;/code> # 对已经Key对象的任何变更操作，都是更新&lt;/li>
&lt;li>&lt;code>删除数据&lt;/code> # 删除即把key和value从dict结构里删除&lt;/li>
&lt;/ul>
&lt;h3 id="关于过期键-expireskey">关于过期键 expiresKey&lt;/h3>
&lt;p>Redis可以设置过期键，到达一定时间，这些对象会被自动过期并回收&lt;/p></description></item><item><title>Redis - Set</title><link>https://chhz0.github.io/notes/database/redis/datatypes/set/</link><pubDate>Tue, 10 Jun 2025 22:36:08 +0800</pubDate><guid>https://chhz0.github.io/notes/database/redis/datatypes/set/</guid><description>&lt;h2 id="redis-set-">Redis&amp;lt; Set &amp;gt;&lt;/h2>
&lt;p>Redis Set是一个唯一字符串的集合&lt;/p>
&lt;p>适用于：&lt;/p>
&lt;ol>
&lt;li>跟踪唯一目标(e.g., 跟踪访问给定博客的所有唯一IP地址)&lt;/li>
&lt;li>表示关系(e.g., 具有给定角色的所有用户集合)&lt;/li>
&lt;li>执行常见的集合运算(e.g., 根据集合运算能力获取不同用户的共同信息)&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>Redis Set的最大大小为2^32-1(4294967295)&lt;/p>&lt;/blockquote>
&lt;h3 id="set-命令">Set 命令&lt;/h3>
&lt;p>Set的基本操作有：&lt;/p>
&lt;ul>
&lt;li>创建：&lt;code>SADD&lt;/code>
&lt;ul>
&lt;li>&lt;code>SADD key member [member ...]&lt;/code> # 添加元素，返回值为成功添加了几个元素&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>查询：&lt;code>SISMEMBR&lt;/code>, &lt;code>SCARD&lt;/code>, &lt;code>SMEMBERS&lt;/code>, &lt;code>SSCAN&lt;/code>, &lt;code>SINTER&lt;/code>, &lt;code>SUNION&lt;/code>, &lt;code>SDIFF&lt;/code>
&lt;ul>
&lt;li>&lt;code>SISMEMBER key member&lt;/code> # 查询元素是否存在&lt;/li>
&lt;li>&lt;code>SCARD key&lt;/code> # 查询集合元素个数&lt;/li>
&lt;li>&lt;code>SMEMBERS key&lt;/code> # 查看集合的所有元素&lt;/li>
&lt;li>&lt;code>SSCAN key cursor[MATCH pattern][COUNT count]&lt;/code> # 查看集合元素，可以理解为指定游标进行查询，可以指定个数，默认为10&lt;/li>
&lt;li>&lt;code>SINTER key [key ...]&lt;/code> # 返回在第一个集合，同时在后面所有集合都存在元素&lt;/li>
&lt;li>&lt;code>SUNION key [key ...]&lt;/code> # 返回所有集合的并集，集合个数大于等于2&lt;/li>
&lt;li>&lt;code>SDIFF key [key ...]&lt;/code> # 返回第一个集合有，且后续集合中不存在的元素，结合个数大于等于2，注意&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>更新：&lt;code>SADD&lt;/code>, &lt;code>SREM&lt;/code>
&lt;ul>
&lt;li>&lt;code>SADD&lt;/code> &amp;ndash; &amp;gt; 参考上文&lt;/li>
&lt;li>&lt;code>SREM key member [member ...]&lt;/code> # 删除元素，返回值为成功删除几个元素&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>删除：&lt;code>DEL&lt;/code>
&lt;ul>
&lt;li>&lt;code>DEL key&lt;/code> 删除元素&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>::: tip 详细Set命令
🔗 &lt;a href="https://redis.io/docs/latest/commands/?group=set">Set命令列表&lt;/a>
:::&lt;/p></description></item><item><title>Redis - Single Thread</title><link>https://chhz0.github.io/notes/database/redis/arch/single-thread/</link><pubDate>Tue, 10 Jun 2025 22:36:08 +0800</pubDate><guid>https://chhz0.github.io/notes/database/redis/arch/single-thread/</guid><description>&lt;blockquote>
&lt;p>Redis的单线程模型&lt;/p>&lt;/blockquote>
&lt;h2 id="redis-单线程模型">Redis 单线程模型&lt;/h2>
&lt;p>redis是一个能高效处理请求的组件&lt;/p>
&lt;p>核心处理逻辑：Redis一直都是单线程，其他辅助模块会有一些多线程、多进程的功能，例如：复制模块用的多进程；某些异步流程从4.0开始用多线程；网络I/O解包从6.0开始用多线程；&lt;/p>
&lt;blockquote>
&lt;p>Redis在处理客户端的请求时，包括获取（socket写）、解析、执行、内容返回等都是由一个顺序串行的主线程处理，这就是所谓的单线程&lt;/p>&lt;/blockquote>
&lt;h3 id="redis-单线程的选择">Redis 单线程的选择&lt;/h3>
&lt;p>Redis的定位是内存k-v存储，是做短平快的热点数据处理，一般来说执行会很快，执行本身不会成为瓶颈，瓶颈通常在网络I/O，处理逻辑多线程并不会有太大收益&lt;/p>
&lt;p>同时Redis本身秉持简洁高效的理念，代码的简单性、可维护性是redis一直依赖的追求，执行本身不应该成为瓶颈，而且多线程本身也会引起额外成本&lt;/p>
&lt;h4 id="引入多线程带来复杂度和额外成本">引入多线程带来复杂度和额外成本&lt;/h4>
&lt;ol>
&lt;li>
&lt;p>多线程引入的复杂度是极大的&lt;/p>
&lt;ul>
&lt;li>多线程引入后，redis原来的顺序执行特性就不复存在，为了事务的原子性、隔离性，redis就不得不引入一些很复杂的实现&lt;/li>
&lt;li>redis的数据结构是极其高效，在单线程模式下做了很多特性的优化，如果引入多线程，那么所有底层数据都要改为线性安全，这很复杂&lt;/li>
&lt;li>多线程模式使得程序调试更加复杂和麻烦，会带来额外的开发成本及运营成本&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>多线程带来额外的成本&lt;/p>
&lt;ul>
&lt;li>上下文切换成本，多线程调度需要切换线程上下文，这个操作先存储当前线程的本地数据，程序指针，然后载入另一个线程数据，这种内核操作的成本不可忽略&lt;/li>
&lt;li>同步机制的开销，一些公共资源，在单线程模式下直接访问就行，多线程需要通过加锁等方式进行同步&lt;/li>
&lt;li>一个线程本身也占据内存大小，对redis这种内存数据库来说，内存非常珍贵，多线程本身带来的内存使用的成本也需要谨慎决策&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="redis-单线程的高性能">Redis 单线程的高性能&lt;/h3>
&lt;p>Redis 核心的请求处理是&lt;code>单线程&lt;/code>，但是Redis却能使用单线程模型达到每秒数万级别的处理能力，这是Redis多方面极致设计的一个综合结果.&lt;/p>
&lt;ol>
&lt;li>Redis的大部分操作在内存上完成，内存操作本身就特别快&lt;/li>
&lt;li>Redis选择了很多高效的数据结构，并做了很多优化，比如&lt;code>ziplist&lt;/code>，&lt;code>hash&lt;/code>，&lt;code>skiplist&lt;/code>等，有时候一种对象底层有几种实现以应对不同场景&lt;/li>
&lt;li>Redis采用了多路复用机制，使其在网络IO操作中能并发处理大量的客户端请求，实现高吞并量&lt;/li>
&lt;/ol>
&lt;h4 id="redis-io多路复用">Redis I/O多路复用&lt;/h4>
&lt;p>Redis在内存中处理数据，其性能瓶颈更多是在I/O&lt;/p>
&lt;p>Redis的I/O多路复用机制，是指Redis在处理客户端请求时，通过使用操作系统提供的I/O多路复用功能，实现同时处理多个客户端的请求，而不是阻塞等待每个请求的处理完成&lt;/p>
&lt;p>Redis做了一层包装，叫&lt;code>Reactor模型&lt;/code>，本质就是监听各种事件，当事件发生时，将事件分发给不同的处理器&lt;/p>
&lt;p>&lt;img src="https://chhz0.github.io/redis/redis-reactor.drawio.svg" alt="redis-reactor">&lt;/p>
&lt;p>I/O多路复用让redis单线程有了较大的并发度，这里是并发，不是并行，这种模式下，Redis单核的性能可以是被充分利用&lt;/p></description></item><item><title>Redis - Stream</title><link>https://chhz0.github.io/notes/database/redis/datatypes/stream/</link><pubDate>Tue, 10 Jun 2025 22:36:08 +0800</pubDate><guid>https://chhz0.github.io/notes/database/redis/datatypes/stream/</guid><description>&lt;h2 id="redis-stream-">Redis&amp;lt; Stream &amp;gt;&lt;/h2>
&lt;p>Redis Stream是一种数据结构，其作用类似于仅追加日志，但也实现了多种操作克服典型的仅追加日志的限制. 包括O(1)时间内的随机访问和复杂的消费策略&lt;/p>
&lt;p>Stream的使用示例：&lt;/p>
&lt;pre>&lt;code>1. 事件溯源(追踪用户操作、点击)；
2. 传感器健康;
3. 通知(将每个用户的通知存储在单独的流中)
&lt;/code>&lt;/pre>
&lt;p>Redis为每个流条目生成一个唯一ID，可以使用这些ID检索其关联条目或读取并处理流中的所有后续条目&lt;/p>
&lt;p>Redis支持多种修剪策略和多种消费策略&lt;/p>
&lt;h3 id="stream-命令">Stream 命令&lt;/h3>
&lt;ul>
&lt;li>&lt;code>XADD&lt;/code> # 将新条目添加到流中&lt;/li>
&lt;li>&lt;code>XREAD&lt;/code> # 读取一个或多个条目，从给定位置开始并及时向前移动&lt;/li>
&lt;li>&lt;code>XRANGE&lt;/code> # 返回两个提供的条目ID之间的条目范围&lt;/li>
&lt;li>&lt;code>XLEN&lt;/code> # 返回流的长度&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>Redis Stream 详细请阅读
&lt;a href="https://redis.io/docs/latest/develop/data-types/streams/">Redis Stream&lt;/a>&lt;/p>&lt;/blockquote></description></item><item><title>Redis - String</title><link>https://chhz0.github.io/notes/database/redis/datatypes/string/</link><pubDate>Tue, 10 Jun 2025 22:36:08 +0800</pubDate><guid>https://chhz0.github.io/notes/database/redis/datatypes/string/</guid><description>&lt;h2 id="redis-string-">Redis&amp;lt; String &amp;gt;&lt;/h2>
&lt;p>Redis String 类型，存储字节，包括文本，序列化对象和二进制数组，因此 &lt;em>&lt;strong>String是Redis最基本的数据结构&lt;/strong>&lt;/em>. 通常用于&lt;strong>缓存&lt;/strong>，而且Redis支持其他功能，允许实现&lt;strong>计数器&lt;/strong>并执行按位运算.&lt;/p>
&lt;p>由于Redis中key是一个字符串，因此Redis使用String数据结构作为key的值.&lt;/p>
&lt;p>在默认情况下，Stirng最大为512MB，可以通过配置项&lt;code>proto-max-bulk-len&lt;/code>进行修改.&lt;/p>
&lt;h3 id="string-适用场景">String 适用场景&lt;/h3>
&lt;p>使用场景：一般用来存放字节数据、文本数据、序列化后的对象数据.&lt;/p>
&lt;ol>
&lt;li>缓存场景：Value存Json字符串等信息.&lt;/li>
&lt;li>计数场景：因为Redis处理命令是单线程，所以执行命令的过程是原子的，因此String数据结构适合计数场景.&lt;/li>
&lt;/ol>
&lt;h3 id="string-命令">String 命令&lt;/h3>
&lt;p>常用命令:&lt;/p>
&lt;ul>
&lt;li>创建 &amp;ndash;&amp;gt; &lt;code>set&lt;/code>, &lt;code>setnx&lt;/code>, &lt;code>getset&lt;/code>
&lt;ul>
&lt;li>&lt;code>SET key value&lt;/code> # 设置一个key值为特定的value&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>set命令扩展参数：
EX（键过期时间秒）、PX（键过期时间毫秒）、NX（只有键不存在时才对键进行操作，基本替代下面的SETNX操作）、XX（键存在时才对键进行操作）&lt;/p>&lt;/blockquote>
&lt;ul>
&lt;li>&lt;code>SETNX key value&lt;/code> # 用于在指定的key不存在时，为key设置指定的值，对于实现锁很有用&lt;/li>
&lt;li>&lt;code>GETSET key value&lt;/code> # 设置一个key的值，并返回原来的值&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>查询 &amp;ndash;&amp;gt; &lt;code>get&lt;/code>, &lt;code>mget&lt;/code>
&lt;ul>
&lt;li>&lt;code>Get key&lt;/code> # 查询某个key，存在就返回对应的value，不存在返回nil&lt;/li>
&lt;li>&lt;code>Mget key [key ...]&lt;/code> # 一次查询多个key，如果某个key不存在，对应位置返回nil&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>更新 &amp;ndash;&amp;gt; &lt;code>set&lt;/code>
&lt;ul>
&lt;li>见上面的set命令&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>删除 &amp;ndash;&amp;gt; &lt;code>del&lt;/code>
&lt;ul>
&lt;li>&lt;code>DEL key [key ...]&lt;/code> # 删除对象，返回值为删除成功了几行&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>其他命令：&lt;code>incr&lt;/code>, &lt;code>incrby&lt;/code>, &lt;code>incrbyfloat&lt;/code>&lt;/p></description></item><item><title>Redis - ZSet</title><link>https://chhz0.github.io/notes/database/redis/datatypes/zset/</link><pubDate>Tue, 10 Jun 2025 22:36:08 +0800</pubDate><guid>https://chhz0.github.io/notes/database/redis/datatypes/zset/</guid><description>&lt;h2 id="redis-zset-">Redis&amp;lt; ZSet &amp;gt;&lt;/h2>
&lt;p>Redis ZSet 是一个关联分数排序的唯一字符串集合. 当多个字符串具有相同分数时，字符串会按照字典顺序排列。&lt;/p>
&lt;p>&lt;code>ZSet&lt;/code>可以适用于:&lt;/p>
&lt;ul>
&lt;li>排行榜. 使用ZSet维护大型游戏中最高分数的有序列表.&lt;/li>
&lt;li>速率限制器. 使用ZSet构建滑动窗口速率限制器，以防止过多的API请求.&lt;/li>
&lt;/ul>
&lt;p>&lt;code>ZSet&lt;/code>可以视为是集合和哈希的混合，一方面，其与集合类似，由唯一的、不重复的字符串元素组成；另一方面，集合内元素没有排序，但是排序集合中每个元素都和一个浮点值相关联，也就是类似于哈希，每个元素映射一个值&lt;/p>
&lt;p>此外，排序集中的元素是按顺序获取的，这个顺序遵守以下规则：&lt;/p>
&lt;ol>
&lt;li>如果 B 和 A 是具有不同分数的两个元素，则如果 A.score 是 &amp;gt; B.score，则 A &amp;gt; B.&lt;/li>
&lt;li>如果 B 和 A 的分数完全相同，则如果 A 字符串按字典顺序大于 B 字符串，则 A &amp;gt; B。 B 和 A 字符串不能相等，因为排序集仅具有唯一元素&lt;/li>
&lt;/ol>
&lt;h3 id="zset-命令">ZSet 命令&lt;/h3>
&lt;p>ZSet常见命令：&lt;/p>
&lt;ul>
&lt;li>创建：&lt;code>ZADD&lt;/code>
&lt;ul>
&lt;li>&lt;code>ZADD key score member [score member]&lt;/code> # 向Sorted Set增加数据，如果key已经存在的Key，则更新对应的数据
&lt;ul>
&lt;li>扩展参数：XX, NX, LT, GT&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>查询：&lt;code>ZRANGE&lt;/code>, &lt;code>ZCOUNT&lt;/code>, &lt;code>ZRANK&lt;/code>, &lt;code>ZCARD&lt;/code>, &lt;code>ZSCORE&lt;/code>
&lt;ul>
&lt;li>&lt;code>ZCARD key&lt;/code> # 查看ZSet中的成员&lt;/li>
&lt;li>&lt;code>ZRANGE key start stop [WITHSCORES]&lt;/code> # 查询从start到stop范围的ZSet数据，WITHSCORES选填，不写输出里只有key，没有score值&lt;/li>
&lt;li>&lt;code>ZREVRANGE key start stop [WITHSCORES]&lt;/code> # 即reverse range，从大到小遍历，WITHSCORES选项，不写不会输出score&lt;/li>
&lt;li>&lt;code>ZCOUNT key min max&lt;/code> # 计算min-max积分范围的成员&lt;/li>
&lt;li>&lt;code>ZRANK key member&lt;/code> # 查看ZSet中member的排名索引，索引从0开始，所以排名是第一，索引就是0&lt;/li>
&lt;li>&lt;code>ZSCORE key member&lt;/code> # 查询ZSet成员的分数&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>更新：&lt;code>ZADD&lt;/code>, &lt;code>ZREM&lt;/code>
&lt;ul>
&lt;li>&lt;code>ZREM key member [member ...]&lt;/code> # 删除ZSet中的元素&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>删除：&lt;code>DEL&lt;/code>, &lt;code>UNLINK&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>::: tip 详细ZSet命令
🔗 &lt;a href="https://redis.io/docs/latest/commands/?group=sorted-set">ZSets命令列表&lt;/a>
:::&lt;/p></description></item><item><title>Redis - 过期淘汰算法</title><link>https://chhz0.github.io/notes/database/redis/arch/lru-lfu/</link><pubDate>Tue, 10 Jun 2025 22:36:08 +0800</pubDate><guid>https://chhz0.github.io/notes/database/redis/arch/lru-lfu/</guid><description>&lt;blockquote>
&lt;p>Redis 中使用的过期淘汰算法 LRU &amp;amp;&amp;amp; LFU&lt;/p>&lt;/blockquote>
&lt;h2 id="redis-过期淘汰算法">Redis 过期淘汰算法&lt;/h2></description></item><item><title>Redis-core</title><link>https://chhz0.github.io/notes/database/redis/redis-core/</link><pubDate>Tue, 10 Jun 2025 22:36:08 +0800</pubDate><guid>https://chhz0.github.io/notes/database/redis/redis-core/</guid><description>&lt;blockquote>
&lt;p>一文详解 &lt;em>Redis&lt;/em> 核心内容&lt;/p>&lt;/blockquote>
&lt;h2 id="1-redis-简介">1. Redis 简介&lt;/h2>
&lt;h3 id="11-redis-安装">1.1 Redis 安装&lt;/h3>
&lt;h3 id="12-redis-命令">1.2 Redis 命令&lt;/h3>
&lt;h3 id="13-redis-高级">1.3 Redis 高级&lt;/h3>
&lt;h2 id="2-redis-数据结构">2. Redis 数据结构&lt;/h2>
&lt;h3 id="21-redis-object">2.1 Redis Object&lt;/h3>
&lt;h3 id="22-redis--string-">2.2 Redis &amp;lt; String &amp;gt;&lt;/h3>
&lt;h3 id="23-redis--list-">2.3 Redis &amp;lt; List &amp;gt;&lt;/h3>
&lt;h3 id="24-redis--set-">2.4 Redis &amp;lt; Set &amp;gt;&lt;/h3>
&lt;h3 id="25-redis--hash-">2.5 Redis &amp;lt; Hash &amp;gt;&lt;/h3>
&lt;h3 id="26-redis--zset-">2.6 Redis &amp;lt; ZSet &amp;gt;&lt;/h3>
&lt;h3 id="27-redis--stream-">2.7 Redis &amp;lt; Stream &amp;gt;&lt;/h3>
&lt;h3 id="28-redis---geospatial-hyperloglog--bitmap">2.8 Redis - Geospatial| Hyperloglog | Bitmap&lt;/h3>
&lt;h2 id="3-redis-架构设计">3. Redis 架构设计&lt;/h2>
&lt;h3 id="31-redis-单线程--多线程">3.1 Redis 单线程 | 多线程&lt;/h3>
&lt;h3 id="32-redis-过期策略算法">3.2 Redis 过期策略算法&lt;/h3>
&lt;h2 id="4-redis-持久化策略">4. Redis 持久化策略&lt;/h2>
&lt;h3 id="41-redis-aof">4.1 Redis AOF&lt;/h3>
&lt;h3 id="42-redis-rdb">4.2 Redis RDB&lt;/h3>
&lt;h3 id="43-redis-混合持久化">4.3 Redis 混合持久化&lt;/h3>
&lt;h2 id="5-redis-缓存应用">5. Redis 缓存应用&lt;/h2>
&lt;h3 id="51-redis-缓存">5.1 Redis 缓存&lt;/h3>
&lt;h3 id="52-redis-缓存一致性">5.2 Redis 缓存一致性&lt;/h3>
&lt;h2 id="6-redis-高可用">6. Redis 高可用&lt;/h2>
&lt;h3 id="61-redis-主从复制">6.1 Redis 主从复制&lt;/h3>
&lt;h3 id="62-redis-哨兵">6.2 Redis 哨兵&lt;/h3>
&lt;h3 id="63-redis-集群">6.3 Redis 集群&lt;/h3>
&lt;h2 id="redis相关资料">&lt;em>Redis相关资料&lt;/em>&lt;/h2>
&lt;blockquote>
&lt;ul>
&lt;li>&lt;a href="https://redis.io/docs/latest/">redis/Docs&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://xiaolincoding.com/redis/">小林coding/redis&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.redis.net.cn/">redis中文网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.runoob.com/redis/redis-tutorial.html">菜鸟教程/redis&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/663851226">zhihu/【超级详细】一文搞懂redis的所有知识点&lt;/a>&lt;/li>
&lt;/ul>&lt;/blockquote></description></item><item><title>Hugo Docs (Continuous Updates)</title><link>https://chhz0.github.io/notes/hugo/hugo-docs/</link><pubDate>Tue, 08 Apr 2025 03:10:00 +0800</pubDate><guid>https://chhz0.github.io/notes/hugo/hugo-docs/</guid><description>&lt;blockquote>
&lt;p>Hugo 是最受欢迎的开源静态网站生成器之一. 凭借其惊人的速度和灵活性，Hugo 让网站建设再次变得有趣.&lt;/p>&lt;/blockquote>
&lt;p>本篇内容将全部基于&lt;a href="https://gohugo.io/documentation/">Hugo&lt;/a> 官方文档以及个人的实际操作. 实际上Hugo 的官方文档非常加十分的详细，我也超级推荐直接阅读官方的文档. 但是官方文档的内容太多，这对新手来说第一时间很难上手，包括我，所以我想将整个文档进行阅读记录，以方便入门.&lt;/p>
&lt;p>于此同时，本站点也是使用了Hugo 进行搭建，所以进行这样一份学习记录也许有助于我改进网站.&lt;/p>
&lt;h1 id="hugo">Hugo&lt;/h1>
&lt;p>Hugo是一个用Go语言编写的静态网站生成器，针对速度进行优化，并且灵活设计. 它凭借先进的模板系统和快速的资产管道，Hugo可以在几秒钟内渲染出完整的站点.&lt;/p>
&lt;p>其灵活的框架设计、多语言支持和强大的分类系统，Hugo很适合搭建文档站点，博客站点，以及各种静态网站.&lt;/p>
&lt;h2 id="安装---installation">安装 - Installation&lt;/h2>
&lt;blockquote>
&lt;p>这里仅演示linux 下的安装过程&lt;/p>&lt;/blockquote>
&lt;p>在按照Hugo前，你需要先了解Hugo提供的三个版本：&lt;code>标准版&lt;/code>、&lt;code>扩展版&lt;/code>和&lt;code>扩展/部署版&lt;/code>.&lt;/p>
&lt;ul>
&lt;li>标准版：仅包含核心功能，适合于开发者和普通用户使用.&lt;/li>
&lt;li>扩展版：包含标准版所有功能，并且提供了许多扩展功能，如图片WebP格式处理, 使用嵌入的LibSass转化CSS, 使用Dart Sass转换器等.&lt;/li>
&lt;li>扩展/部署版：包含扩展版所有功能，并且提供了许多部署功能，如Google Cloud Storage、AWS S3或者Azure存储容器等.&lt;/li>
&lt;/ul>
&lt;p>Hugo官方推荐使用&lt;code>扩展版&lt;/code>, 下面的安装过程也展示扩展版的安装.&lt;/p>
&lt;h3 id="环境准备">环境准备&lt;/h3>
&lt;p>使用Hugo时，&lt;code>Git&lt;/code>, &lt;code>Go&lt;/code>和&lt;code>Dart Sass&lt;/code>是经常使用的. 其中&lt;strong>Git是必须的&lt;/strong>，Go和Dart Sass如果不选择安装仅影响部分功能的使用.&lt;/p>
&lt;ol>
&lt;li>安装&lt;code>Git&lt;/code>(必要)&lt;/li>
&lt;li>安装&lt;code>Go&lt;/code>(可选)&lt;/li>
&lt;li>安装&lt;code>Dart Sass&lt;/code>(可选)&lt;/li>
&lt;/ol>
&lt;h3 id="直接下载">直接下载&lt;/h3>
&lt;h3 id="源码构建">源码构建&lt;/h3>
&lt;h3 id="仓库软件包">仓库软件包&lt;/h3>
&lt;h2 id="configuration">Configuration&lt;/h2>
&lt;h2 id="cli">CLI&lt;/h2></description></item><item><title>Bitcask</title><link>https://chhz0.github.io/blogs/2025/0405.bitcask-core/</link><pubDate>Sat, 05 Apr 2025 15:07:38 +0800</pubDate><guid>https://chhz0.github.io/blogs/2025/0405.bitcask-core/</guid><description>&lt;blockquote>
&lt;p>Bitcask是一个高性能的键值存储系统，设计之初的目的是提供高写入吞吐量和高效读取性能。采用了日志化结构哈希表(Log-Structured Hash Table)，核心是写前日志(WAL)、内存哈希表和定期merge.&lt;/p>&lt;/blockquote>
&lt;p>具体细节均在官方的设计论文 &lt;a href="https://riak.com/assets/bitcask-intro.pdf">Bitcask Design Paper&lt;/a> 中可以查看。&lt;/p>
&lt;blockquote>
&lt;p>官方论文中提到的bitcask应该具备的特性&lt;/p>
&lt;ul>
&lt;li>low latency per item read or written&lt;/li>
&lt;li>high throughput, especially when writing an incoming stream of random items&lt;/li>
&lt;li>ability to handle datasets much larger than RAM w/o degradation&lt;/li>
&lt;li>crash friendliness, both in terms of fast recovery and not losing data&lt;/li>
&lt;li>ease of backup and restore&lt;/li>
&lt;li>a relatively simple, understandable (and thus supportable) code structure and data format&lt;/li>
&lt;li>predictable behavior under heavy access load or large volume&lt;/li>
&lt;li>a license that allowed for easy default use in Riak&lt;/li>
&lt;/ul>&lt;/blockquote>
&lt;p>目前已经有优秀的开源实现：&lt;/p></description></item><item><title>About</title><link>https://chhz0.github.io/about/</link><pubDate>Sat, 05 Apr 2025 14:36:12 +0800</pubDate><guid>https://chhz0.github.io/about/</guid><description>&lt;h1 id="关于本站">关于本站&lt;/h1>
&lt;blockquote>
&lt;p>本站由 &lt;a href="https://gohugo.io/">Hugo&lt;/a> 搭建，使用&lt;a href="https://github.com/math-queiroz/rusty-typewriter">math-queiroz/Rusty-Typewriter&lt;/a> 扩展主题.&lt;/p>&lt;/blockquote>
&lt;p>计划在这里记录自己的学习笔记，包括但不限于 &lt;code>Golang&lt;/code>, &lt;code>Java&lt;/code>, &lt;code>Cangjie&lt;/code>, &lt;code>cs_base&lt;/code>, &lt;code>Git&lt;/code>, &lt;code>Docker&lt;/code>, &lt;code>Kubernetes&lt;/code>, &lt;code>Message Queue&lt;/code>, &lt;code>MySQL&lt;/code>, &lt;code>Redis&lt;/code>, &lt;code>HTML&lt;/code>, &lt;code>CSS&lt;/code>, &lt;code>JavaScript&lt;/code>, &lt;code>TypeScript&lt;/code>, &lt;code>Vue&lt;/code>, &lt;code>React&lt;/code>以及一些 &lt;strong>开源项目&lt;/strong> 等&amp;hellip;&lt;/p>
&lt;h2 id="文章结构">文章结构&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>this is a example of directory structure
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>content/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── archive
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── _index.md
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── projects
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── bitcask.md
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── _index.md
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── blogs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── 2025-04-08.goose.md
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── bitcask
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ │ ├── 2025-04-05.bitcask-core.md
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ │ └── 2025-04-08.build-your-own-bitcask.md
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── _index.md
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── hugoes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── build-my-hugo-site.md
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── hugo-docs.md
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── about.md
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── search.md
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在&lt;code>content/blogs&lt;/code> 目录下，将以 date.title.md 的markdown文件列表. &lt;code>content/archive/**/*&lt;/code> 将存在目录层级，以方便查找想要阅读的博客，&lt;/p></description></item><item><title>Go-常见设计模式</title><link>https://chhz0.github.io/notes/langs/golang/go-design-pattern/</link><pubDate>Tue, 19 Nov 2024 00:00:00 +0000</pubDate><guid>https://chhz0.github.io/notes/langs/golang/go-design-pattern/</guid><description>&lt;blockquote>
&lt;p>Go项目开发中比较常用的设计模式介绍&lt;/p>&lt;/blockquote>
&lt;ul>
&lt;li>创建型模式
&lt;ul>
&lt;li>单例模式&lt;/li>
&lt;li>工厂模式&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>结构型模式
&lt;ul>
&lt;li>策略模式&lt;/li>
&lt;li>模板模式&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>行为型模式
&lt;ul>
&lt;li>代理模式&lt;/li>
&lt;li>选项模式&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="创建型模式">创建型模式&lt;/h2>
&lt;h3 id="单例模式">单例模式&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">singleton&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#e6db74">&amp;#34;sync&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">singleton&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">ins&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">singleton&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">once&lt;/span> &lt;span style="color:#a6e22e">sync&lt;/span>.&lt;span style="color:#a6e22e">Once&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">GetInsOr&lt;/span>() &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">singleton&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">once&lt;/span>.&lt;span style="color:#a6e22e">Do&lt;/span>(&lt;span style="color:#66d9ef">func&lt;/span>(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ins&lt;/span> = &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">singleton&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用&lt;code>once.Do&lt;/code>可以确保ins实例全局被创建一次&lt;/p>
&lt;p>单例模式实际上有饿汉方式和懒汉方式，这里只介绍在Go项目中单例模式最优雅的实现方式&lt;/p>
&lt;h3 id="工厂模式">工厂模式&lt;/h3>
&lt;p>工厂模式是&lt;strong>面向对象编程中的常用模式&lt;/strong>。可以通过不同的工厂模式来带得Go项目变得简洁&lt;/p>
&lt;ul>
&lt;li>简单工厂模式&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">factory&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Person&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Name&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Age&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">p&lt;/span> &lt;span style="color:#a6e22e">Person&lt;/span>) &lt;span style="color:#a6e22e">Greet&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;name := %s, age := %s&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">Name&lt;/span>, &lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">Age&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">NewPerson&lt;/span>(&lt;span style="color:#a6e22e">name&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">age&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Person&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">Person&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Name&lt;/span>: &lt;span style="color:#a6e22e">name&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Age&lt;/span>: &lt;span style="color:#a6e22e">age&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过&lt;code>NewPerson&lt;/code>创建实例，可以确保实例的Name和Age属性被设置&lt;/p>
&lt;ul>
&lt;li>抽象工厂模式&lt;/li>
&lt;/ul>
&lt;p>抽象工厂模式和简单工厂模式的唯一区别，返回的是&lt;strong>接口&lt;/strong>而不是结构体&lt;/p>
&lt;p>通过返回接口，可以在不公开内部实现的情况下，让调用者使用提供的各种功能&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">factory&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">PersonIntf&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Greet&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">person&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">name&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">age&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">p&lt;/span> &lt;span style="color:#a6e22e">person&lt;/span>) &lt;span style="color:#a6e22e">Greet&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Hi! My name is %s&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">name&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Here, NewPerson returns an interface, and not the person struct itself&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">NewPerson&lt;/span>(&lt;span style="color:#a6e22e">name&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">age&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#a6e22e">PersonIntf&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">person&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">name&lt;/span>: &lt;span style="color:#a6e22e">name&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">age&lt;/span>: &lt;span style="color:#a6e22e">age&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>工厂方式模式&lt;/li>
&lt;/ul>
&lt;p>在工厂方法模式，依赖工厂函数，通过实现工厂函数来创建多种工厂，将对象创建从由一个对象辅助所有具体类的实例化，变成由一群子类来负责具体类的实例化&lt;/p></description></item><item><title>[计网] HTTP</title><link>https://chhz0.github.io/notes/cs/net/http/</link><pubDate>Thu, 31 Oct 2024 00:00:00 +0000</pubDate><guid>https://chhz0.github.io/notes/cs/net/http/</guid><description>&lt;p>接下来将从以下6个方面，逐渐学习和了解HTTP&lt;/p>
&lt;ol>
&lt;li>HTTP基本概念&lt;/li>
&lt;li>Get与Post&lt;/li>
&lt;li>HTTP特征&lt;/li>
&lt;li>HTTP缓存&lt;/li>
&lt;li>HTTPS与HTTP&lt;/li>
&lt;li>HTTP/1.1、HTTP/2、HTTP/3演变&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=YzgxNTk2MGIwMjM0ODdhZWNiYjM1YTdhNTM0NTMwOTJfaDdMekY5THZXQ0plelVaR2lCV1ZWWGptTUZISUMzcElfVG9rZW46TU5pOWJ0elBEbzVIa0p4bzdvTGM1N1VybkxoXzE3MjE4Mzk5Nzc6MTcyMTg0MzU3N19WNA" alt="">&lt;/p>
&lt;h2 id="http基本概念">&lt;strong>HTTP基本概念&lt;/strong>&lt;/h2>
&lt;hr>
&lt;h3 id="1http是什么">&lt;strong>1.HTTP是什么？&lt;/strong>&lt;/h3>
&lt;blockquote>
&lt;p>HTTP是超文本传输协议，也就是&lt;strong>HyperText&lt;/strong> &lt;strong>Transfer Protocol&lt;/strong>&lt;/p>&lt;/blockquote>
&lt;p>HTTP的名字【超文本传输协议】，可以拆成三个部分：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>超文本&lt;/p>
&lt;/li>
&lt;li>
&lt;p>传输&lt;/p>
&lt;/li>
&lt;li>
&lt;p>协议&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=MWVjMWE4ZmI3M2M3YjczMWRmMDE3OWVmZjUwYTE0ODBfRXhVcm5qbEUxNlZaVGpid3I5Z25sQTJzV1ZlSVpGUTdfVG9rZW46UHhGZGJVNFI2b25hWDl4TmlsS2NoaVI2bjJpXzE3MjE4Mzk5Nzc6MTcyMTg0MzU3N19WNA" alt="">&lt;/p>
&lt;p>针对 HTTP &lt;strong>协议&lt;/strong>，我们可以这么理解。&lt;/p>
&lt;ol start="7">
&lt;li>&lt;em>「协议」&lt;/em>&lt;/li>
&lt;/ol>
&lt;p>HTTP 是一个用在计算机世界里的&lt;strong>协议&lt;/strong>。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范（&lt;strong>两个以上的参与者&lt;/strong>），以及相关的各种控制和错误处理方式（&lt;strong>行为约定和规范&lt;/strong>）。&lt;/p>
&lt;ol start="8">
&lt;li>&lt;em>「传输」&lt;/em>&lt;/li>
&lt;/ol>
&lt;p>HTTP 协议是一个&lt;strong>双向协议&lt;/strong>。&lt;/p>
&lt;p>针对&lt;strong>传输&lt;/strong>，我们可以进一步理解了 HTTP。&lt;/p>
&lt;p>HTTP 是一个在计算机世界里专门用来在&lt;strong>两点之间传输数据&lt;/strong>的约定和规范。&lt;/p>
&lt;ol start="9">
&lt;li>&lt;em>「超文本」&lt;/em>&lt;/li>
&lt;/ol>
&lt;p>HTTP 传输的内容是「超文本」。&lt;/p>
&lt;p>理解「超文本」，它就是&lt;strong>超越了普通文本的文本&lt;/strong>，它是文字、图片、视频等的混合体，最关键有超链接，能从一个超文本跳转到另外一个超文本。&lt;/p>
&lt;p>&lt;strong>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>HTTP是用于从互联网服务器传输超文本到本地浏览器的协议，这个说法是错误的，因为HTTP也可以服务于【服务器&amp;lt;&amp;mdash;&amp;gt;服务器】，所有采用&lt;strong>两点之间&lt;/strong>的描述比较准确&lt;/p>&lt;/blockquote>
&lt;h3 id="2http常见的状态码">&lt;strong>2.HTTP常见的状态码&lt;/strong>&lt;/h3>
&lt;p>&lt;img src="https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=NzMzNjU4MzA0ZWM3ZGY0ZWRjM2MzOWQyMzA1NmIyMjJfN01YaTBhejQ1RVlOMFdWcWphQXNXaHNLYUhGekNOWFdfVG9rZW46WFRQcGJWUWdBb1VYdVp4YmM2ZWNWdmd0bnJjXzE3MjE4Mzk5Nzc6MTcyMTg0MzU3N19WNA" alt="">&lt;/p>
&lt;p>&lt;code>1xx&lt;/code> 类状态码属于&lt;strong>提示信息&lt;/strong>，是协议处理中的一种中间状态，实际用到的比较少。&lt;/p>
&lt;p>&lt;code>2xx&lt;/code> 类状态码表示服务器&lt;strong>成功&lt;/strong>处理了客户端的请求，也是我们最愿意看到的状态。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>「&lt;strong>200 OK&lt;/strong>」是最常见的成功状态码，表示一切正常。如果是非 &lt;code>HEAD&lt;/code> 请求，服务器返回的响应头都会有 body 数据。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>「&lt;strong>204 No Content&lt;/strong>」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>「&lt;strong>206 Partial Content&lt;/strong>」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;code>3xx&lt;/code> 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是&lt;strong>重定向&lt;/strong>。&lt;/p></description></item><item><title>[计网] 键入网址的过程</title><link>https://chhz0.github.io/notes/cs/net/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E7%9A%84%E8%BF%87%E7%A8%8B/</link><pubDate>Thu, 31 Oct 2024 00:00:00 +0000</pubDate><guid>https://chhz0.github.io/notes/cs/net/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E7%9A%84%E8%BF%87%E7%A8%8B/</guid><description>&lt;h2 id="当键入网址后到网页显示期间发生了什么">当键入网址后，到网页显示，期间发生了什么？&lt;/h2>
&lt;h3 id="http">&lt;strong>HTTP&lt;/strong>&lt;/h3>
&lt;blockquote>
&lt;p>浏览器做的第一步工作是&lt;strong>解析****URL&lt;/strong>&lt;/p>&lt;/blockquote>
&lt;p>首先浏览器做的第一步工作就是要对&lt;code>URL&lt;/code>进行解析，从而生成发生给&lt;code>Web&lt;/code>服务器的请求信息&lt;/p>
&lt;p>在一条长长的URL里的各个元素的代表是什么&lt;/p>
&lt;p>&lt;img src="https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=NWQ4MGEyMTY1MWRiNGE0MjliMjBhNTRhNmM3OTkwOWZfS0tDMENDOUNRb05hZkxXZ0JJNkZIZWRFTklGZDI5R1VfVG9rZW46RnF1TWJpVklTb0pUSUR4Njg3N2NMVGRvbkZlXzE3MjE4Mzk5MzY6MTcyMTg0MzUzNl9WNA" alt="">&lt;/p>
&lt;blockquote>
&lt;p>这里的URL实际上是请求服务器里的文件资源&lt;/p>
&lt;p>当上图的蓝色部分URL元素都省略了，那么请求的是哪个文件呢？&lt;/p>&lt;/blockquote>
&lt;p>当没有路径名时，就代表访问根目录下事先设置的&lt;strong>默认文件&lt;/strong>，也就是&lt;code>/index.html&lt;/code>或者&lt;code>/default.html&lt;/code>这些文件，这样就不好发生混乱&lt;/p>
&lt;blockquote>
&lt;p>生产HTTP请求信息&lt;/p>&lt;/blockquote>
&lt;p>对&lt;code>URL&lt;/code>进行解析之后，浏览器确定了Web服务器和文件名，接下来就是根据这些信息来生产HTTP请求信息&lt;/p>
&lt;p>&lt;img src="https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=YjQ5OTZhMDE0M2U1NDg3YjkxOGM0YTBlMmZmZGNhODNfSU5nQW93c3pXYUppT1FKaGJ4WWd1VEZrU0hIUVVDd2JfVG9rZW46R1U3bWJ4aTZ6b0l5b1Z4VzdUUmN1a1FlblFQXzE3MjE4Mzk5MzY6MTcyMTg0MzUzNl9WNA" alt="">&lt;/p>
&lt;h3 id="真实地址查询dns">&lt;strong>真实地址查询——DNS&lt;/strong>&lt;/h3>
&lt;hr>
&lt;p>通过浏览器解析URL并生成HTTP消息后，需要委托操作系统将消息发送给&lt;code>Web&lt;/code>服务器&lt;/p>
&lt;p>但是在发送之前，还需要&lt;strong>查询服务器域名对应的IP地址&lt;/strong>，因为委托操作系统发送消息时，必须提供通信对象的IP地址&lt;/p>
&lt;p>这里，有一种服务器就专门保存了&lt;code>Web&lt;/code>服务器域名与&lt;code>IP&lt;/code>的对应关系——DNS服务器&lt;/p>
&lt;blockquote>
&lt;p>域名的层级关系&lt;/p>&lt;/blockquote>
&lt;p>DNS中的域名都是用&lt;strong>句点&lt;/strong>来分隔的，比如&lt;code>www.server.com&lt;/code>，这里的句点带不了不同层次之间的界限&lt;/p>
&lt;p>在域名中，&lt;strong>越靠右&lt;/strong>的位置表示其&lt;strong>层级越高&lt;/strong>&lt;/p>
&lt;p>实际上&lt;strong>域名&lt;/strong>最后还有一个点，比如&lt;code>www``.server.com.&lt;/code>，这个最后一个点代表根域名&lt;/p>
&lt;p>也就是说，&lt;code>.&lt;/code>根域是最顶层，它的下一层是&lt;code>.com&lt;/code>顶级域,再下面是&lt;code>server.com&lt;/code>&lt;/p>
&lt;p>所以，域名的层级关系类似一个树状结构&lt;/p>
&lt;ul>
&lt;li>
&lt;p>根DNS服务器&lt;code>.&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>顶级域DNS服务器&lt;code>.com&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>权威DNS服务器&lt;code>server.com&lt;/code>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=YzA0NDVhMjA2MDAxMDFkNTUxNTg4Yzg2MDhlYjk0ZTRfcVJsVzU0WHl0cXZFT1h5WHpDMEpjYnlRWnkxSEhWUkNfVG9rZW46RUhFTWIwWFBFb04yZ3V4RHVNSGM1V0dBbnc0XzE3MjE4Mzk5MzY6MTcyMTg0MzUzNl9WNA" alt="">&lt;/p>
&lt;blockquote>
&lt;p>根域的DNS服务器信息保存在互联网中所有的DNS服务器中，这样一来任何DNS服务器都可以找到并访问根域DNS服务器&lt;/p>
&lt;p>因此，客户端只要能够找到任意一台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 DNS 服务器。&lt;/p>
&lt;p>域名解析的工作流程&lt;/p>&lt;/blockquote>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>客户端&lt;/strong>首先会发出一个DNS请求，问&lt;a href="http://www.server.com">www.server.com&lt;/a>的IP是啥，并发给本地DNS服务器（也就是客户端的TCP/IP设置中填写的DNS服务器地址）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>本地域名服务器收到客户端的请求后，如果&lt;strong>缓存里的表格&lt;/strong>能找到&lt;a href="http://www.server.com">www.server.com&lt;/a>，则直接返回IP地址，如果没有，本地DNS会去问它的根域名服务器， 根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>根DNS收到本地DNS的请求后，根据&lt;a href="http://www.server.com">www.server.com&lt;/a>的后置是&lt;code>.com&lt;/code>，这个域名归于&lt;code>.com&lt;/code>区域管理，返回&lt;code>.com&lt;/code>顶级域名服务器地址给本地&lt;/p>
&lt;/li>
&lt;li>
&lt;p>本地DNS收到顶级域名服务器地址后，向顶级域名服务器请求负责&lt;a href="http://www.server.com">www.server.com&lt;/a>的权威DNS服务器的地址，&lt;/p>
&lt;/li>
&lt;li>
&lt;p>本地DNS最后向权威DNS服务器请求&lt;a href="http://www.server.com">www.server.com&lt;/a>的IP地址，该server.com的权威服务器就是域名解析结果的出处。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>权威DNS服务器查询结后将对应的IP地址X.X.X.X返回到本地DNS&lt;/p>
&lt;/li>
&lt;li>
&lt;p>本地DNS再将IP地址返回客户端，客户端和目标建立连接&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>至此，DNS的解析过程完成了，其过程可见下图&lt;/p>
&lt;p>&lt;img src="https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjI2MmYzMWEzODdiOWY0YjcxMjZjMmEzZmUzNzEwZDFfTENsN3NZRWxDc1pVVlpKaTB3RzJwWEpGOEdhU1NBYU5fVG9rZW46SE9EVmJ5NzFlb3VHdlV4cHBPV2NiRVZ5bjZnXzE3MjE4Mzk5MzY6MTcyMTg0MzUzNl9WNA" alt="">&lt;/p>
&lt;blockquote>
&lt;p>域名解析并不是每次都需要经过这么多步骤&lt;/p>&lt;/blockquote>
&lt;p>还有&lt;strong>缓存&lt;/strong>的存在。&lt;/p>
&lt;p>浏览器会先看自身有没有对这个域名的缓存，如果有，就直接返回，如果没有，就去问操作系统，操作系统也会去看自己的缓存，如果有，就直接返回，如果没有，再去 hosts 文件看，也没有，才会去问「本地 DNS 服务器」。&lt;/p>
&lt;h3 id="协议栈">&lt;strong>协议栈&lt;/strong>&lt;/h3>
&lt;hr>
&lt;p>通过DNS获取IP后，就可以把HTTP的传输工具交给操作系统中的&lt;strong>协议栈&lt;/strong>&lt;/p>
&lt;p>协议栈的内部分为几个部分，分别承担不同的工作。上下关系是有一定的规则的，上面的部分会向下面的部分委托工作，下面的部分收到委托的工作并执行。&lt;/p>
&lt;p>&lt;img src="https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=OTJiYWJjOTQwZjU3YTI3ODUyMWExMzU2MTlhNjkxZTNfaU5halB3SXMwdzRTdTdXVUVWQnBPYjhTWnpIN1ZEbWhfVG9rZW46WDJTQWIyU3R6b1RvQzN4aGc2OWNWczZJblNiXzE3MjE4Mzk5MzY6MTcyMTg0MzUzNl9WNA" alt="">&lt;/p>
&lt;p>应用程序（浏览器）通过调用 Socket 库，来委托协议栈工作。协议栈的上半部分有两块，分别是负责收发数据的 TCP 和 UDP 协议，这两个传输协议会接受应用层的委托执行收发数据的操作。&lt;/p>
&lt;p>协议栈的下面一半是用 IP 协议控制网络包收发操作，在互联网上传数据时，数据会被切分成一块块的网络包，而将网络包发送给对方的操作就是由 IP 负责的。&lt;/p></description></item><item><title/><link>https://chhz0.github.io/interviews/mysql/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://chhz0.github.io/interviews/mysql/</guid><description>&lt;h2 id="0-sql语法">0. SQL语法&lt;/h2>
&lt;h3 id="01-count主键和count非主键结果会不同吗">0.1 count主键和count非主键结果会不同吗？&lt;/h3>
&lt;p>分析：count()函数是返回表中某个列的非NULL值数量&lt;/p>
&lt;ul>
&lt;li>主键不能存储NULL值，所以count(主键)返回的结果，可以表示数据库中所有行数据的量&lt;/li>
&lt;li>非主键可以保存NULL值，所以count(非主键)返回表中非主键列的非NULL值的数量&lt;/li>
&lt;/ul>
&lt;p>回答：
主键不能存NULL值，所以count主键代表统计表中所有行数据的数量
而非主键可以存储NULL值，所以count非主键返回的是表中这个列的非NULL值的数量&lt;/p>
&lt;h2 id="一索引面试题">一、索引面试题&lt;/h2>
&lt;h3 id="11-mysql有哪些索引">1.1 MySQL有哪些索引？&lt;/h3>
&lt;p>分析：索引是由存储引擎来实现的，不同存储引擎支持的索引类型也是不同的，大多数存储引擎都是支持&lt;/p>
&lt;p>B+树索引，哈希索引，全文索引的区别：&lt;/p>
&lt;ul>
&lt;li>B+树索引：InnoDB引擎默认的索引，支持排序，分组，模糊查询等，并且性能稳定&lt;/li>
&lt;li>哈希索引：多用于等值查询，时间复杂度为O(1)，效率非常高，但不支持排序，范围查询以及模糊查询&lt;/li>
&lt;li>全文索引：一般用于查询文本中的关键字，而不是直接比较是否相等等，主要用来解决 WHERE name LIKE &amp;ldquo;%aaaa%&amp;rdquo;&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://dev.mysql.com/doc/refman/8.0/en/storage-engines.html">dev.mysql.com&lt;/a>&lt;/p>
&lt;p>回答：我了解到Mysql支持B+树索引，哈希索引，全文索引这三种索引类型，比较常用的是B+树索引，因为它是InnoDB引擎默认使用的索引类型，支持排序，分组，范围查询，模糊查询等&lt;/p>
&lt;h3 id="12-innodb引擎的索引数据结构是什么">1.2 InnoDB引擎的索引数据结构是什么？&lt;/h3>
&lt;p>回答：InnoDB引擎是采用B+树作为索引的数据结构&lt;/p>
&lt;h3 id="130-mysql为什么使用b树">1.3.0 mysql为什么使用B+树？&lt;/h3>
&lt;p>分析：这里要回答对平衡树、红黑树，跳表，B树等的对比&lt;/p>
&lt;p>回答：&lt;/p>
&lt;ul>
&lt;li>B+树是多叉树，平衡二叉树、红黑树是二叉树，在同等数据量下，平衡二叉树、红黑树高度更高，磁盘IO次数更多，性能更差，而且它们会频繁执行在平衡过程，来保证树形结构平衡&lt;/li>
&lt;li>和B+树相比，跳表在极端情况下会退化为链表，平衡性差，而数据库查询需要一个可预期的查询时间，并且跳表需要更多的内存&lt;/li>
&lt;li>和B+树相比，B树的数据结构存储在全部节点，对范围查询不友好，非叶子节点存储了数据，导致内存中难以放下全部非叶子节点，如果内存放不下非叶子节点，那么意味着查询非叶子节点的时候都需要磁盘IO&lt;/li>
&lt;/ul>
&lt;p>学习：&lt;a href="https://leeshengis.com/archives/672553">10｜数据库索引：为什么MySQL用B+树而不用B树？ | JUST DO IT&lt;/a>&lt;/p>
&lt;h3 id="13-为什么索引用b树而不用红黑树">1.3 为什么索引用B+树？而不用红黑树？&lt;/h3>
&lt;p>分析：InnoDB引擎的数据是存储在磁盘上的，所以选择数据结构的第一优先级是考虑从磁盘查询数据的成本，如果树的高度越高，意味着磁盘I/O就越多，这样会影响查询性能&lt;/p>
&lt;p>对于N个叶子节点的B+树，其搜索复杂度为&lt;code>O(logdN)&lt;/code> ，其中d表示节点允许的最大子节点个数为d&lt;/p>
&lt;p>在实际的应用中，即使数据达到了千万级别，B+树的高度依旧维持在3&lt;del>4层，也就是说一次数据查询操作只需要做3&lt;/del>4次的磁盘I/O操作&lt;/p>
&lt;p>而红黑树本质上是二叉树，二叉树的每个父节点的儿子节点只能是2个，意味着其搜索复杂度为&lt;code>O(logN)&lt;/code> ，这已经比B+Tree高出不少，因此二叉树搜索到目标数据所经历的磁盘I/O次数要更多&lt;/p>
&lt;p>回答：主要原因是随着数据量的增多，红黑树的树高会比B+树高 ，这样查询数据的时候会面临更多的磁盘I/O，查询性能没那么好。&lt;/p>
&lt;p>因为红黑树本质是二叉树，而b+树是多叉树，存储相同数量的数据量下，红黑树的树高会比B+树的树高，由于InnoDB引擎的数据都是存储在磁盘上的，如果树的高度过高，意味着磁盘I/O就越多，会影响到查询性能，所以InnoDB引擎的索引选择了B+树&lt;/p>
&lt;h3 id="14-为什么索引用b树而不是b树">1.4 为什么索引用B+树？而不是B树？&lt;/h3>
&lt;p>分析：考察对B+树 和 B 树的理解，可以从三个角度分析&lt;/p>
&lt;ul>
&lt;li>
&lt;p>磁盘I/O角度&lt;/p>
&lt;/li>
&lt;li>
&lt;p>范围查询角度&lt;/p>
&lt;/li>
&lt;li>
&lt;p>增删改查角度&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>回答：我觉得主要有三个原因：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>B+树的磁盘读写代价更低：B+树只有叶子节点存储索引和数据，非叶子节点只存放索引，而B树所有节点都会存放索引和数据，因此存储相同数据量的情况下，B+树可以比B树更矮胖，查询叶子节点的磁盘I/O次数也少&lt;/p>
&lt;/li>
&lt;li>
&lt;p>B+树便于范围查询：MySQL经常需要使用范围查询，B+树所有叶子节点间都有链表进行连接，这种设计对范围查询查询非常有帮助，B树没有将所有叶子节点用链表串联起来的结构，只能用中序遍历来完成范围查询，这会比B+树范围查询涉及多个节点的磁盘I/O操作，一次范围查询的效率不如B+树&lt;/p>
&lt;/li>
&lt;li>
&lt;p>B+树增删改查效率更加稳定：B+树有大量冗余节点，这些冗余数据可以让B+树在插入、删除的效率都更高，比如删除根节点的时候，不会像B树那样会发生复杂的树的变化。另外，B+树把所有指向数据的指针都放在叶子节点，因此查询、插入、删除数据都需要走到最后一层，这不同于B树可能在任意一层找到数据，所以B+树更为稳定&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="15-为什么索引用b树而不用哈希表">1.5 为什么索引用B+树？而不用哈希表？&lt;/h3>
&lt;p>分析：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>哈希表的数据是散列分布的，不具有序性，无法进行范围和排序&lt;/p>
&lt;/li>
&lt;li>
&lt;p>哈希表存在哈希冲突，哈希冲突严重，也会降低查询效率&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>回答：MySQL会有会多范围和排序的场景，虽然哈希表的搜索时间复杂度是O(1)，但是由于哈希表的数据都是通过哈希函数计算后散列分布的，所以哈希表索引不支持范围和排序操作，不支持联合索引最左匹配原则，如果重复键比较多，还容易操作哈希碰撞导致效率进一步降低。而B+树可以满足这些应用&lt;/p>
&lt;h3 id="16聚簇索引和非聚簇索引有什么区别">1.6聚簇索引和非聚簇索引有什么区别？&lt;/h3>
&lt;p>分析：先说聚簇索引和非聚簇索引B+树叶子节点存放内容的区别，然后再引出回表查询和覆盖索引查询&lt;/p></description></item><item><title/><link>https://chhz0.github.io/interviews/network/http/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://chhz0.github.io/interviews/network/http/</guid><description>&lt;h2 id="http的协议有什么特点">HTTP的协议有什么特点？&lt;/h2>
&lt;p>HTTP协议&lt;strong>基于文本传输&lt;/strong>的，&lt;strong>支持不同的****数据格式&lt;/strong>，例如HTML、JSON、XML等数据格式，并且&lt;strong>http是无状态的&lt;/strong>，每个http请求之间相互独立，&lt;strong>采用了请求-应答模式&lt;/strong>，&lt;strong>有很好的扩展性&lt;/strong>，可以通过扩展头部、方法等支持行方式&lt;/p>
&lt;h2 id="http报文格式怎么分割">HTTP报文格式？怎么分割&lt;/h2>
&lt;p>http的报文格式分为请求头、请求行、请求体，请求头包含了请求方式、url、http版本，请求行包含了key-value对的信息，有connection，content-lenth等字段，请求体包含了实际的请求数据；请求头和请求行通过/r/n进行分割，请求行和请求体通过一行空白行进行分割&lt;/p>
&lt;h2 id="http有什么方法">HTTP有什么方法？&lt;/h2>
&lt;p>GET、PUT、DELETE、post、head、options、trace、connect&lt;/p>
&lt;h2 id="哪些http方法是安全的哪些是幂等的">哪些http方法是安全的？哪些是幂等的&lt;/h2>
&lt;p>get、head是安全的
post、put、delete是不安全的&lt;/p>
&lt;p>get、head、put、delete是幂等的
post是不幂等的&lt;/p>
&lt;h2 id="get和post请求的区别追问get请求一定是安全且幂等的吗">GET和POST请求的区别？追问：GET请求一定是安全且幂等的吗？&lt;/h2>
&lt;p>get请求是从服务器获取资源，post请求向服务器提交数据，&lt;/p>
&lt;p>get请求是读操作，是安全且幂等的；post请求因为会修改服务器的资源，且多次post请求会创建多个资源，所以是不安全且不幂等的
get请求一般是将请求参数放在url的查询字符串中，浏览器对url的长度有限制，所以get请求的请求参数有长度限制。post请求的数据放在请求体，post请求的请求参数没有长度限制&lt;/p>
&lt;h2 id="http有哪些状态码">HTTP有哪些状态码？&lt;/h2>
&lt;p>100类：属于提示信息，为协议处理中的中间状态
200类：表示服务器成功处理客户端的请求&lt;/p>
&lt;ul>
&lt;li>200：表示成功处理，返回期望的结果&lt;/li>
&lt;li>204：与200状态码相似，但是响应头没有body数据&lt;/li>
&lt;li>206：http分块下载或断点续传的几次，
300类：表示请求的资源发生了变动，需要客户端用新的URL重新发送请求，就是重定向&lt;/li>
&lt;li>301：永久性的重定向，后续请求可以直接重定向访问&lt;/li>
&lt;li>302：临时访问，&lt;/li>
&lt;li>304：
400类：表示客户端发送的报文有误，服务器无法处理&lt;/li>
&lt;li>403：请求的权限不够&lt;/li>
&lt;li>404：请求的资源不存在
500类：表示服务器处理 时内部发生了错误，属于服务器端的错误码&lt;/li>
&lt;/ul>
&lt;h2 id="什么情况下会出现502错误码">什么情况下会出现502错误码？&lt;/h2>
&lt;p>502（Bad GateWay）表示码表示服务器在充当网关或代理时，在尝试满足请求时从它访问的入站服务器接收到无效响应
如果客户端访问服务是通过nginx来反向代理到应用服务器，那么如果应用服务器出现故障，导致nginx无法从应用服务获得响应，这时候nginx就会返回502错误码给客户端&lt;/p>
&lt;h2 id="有个服务出现504错误码这个服务出现了什么问题">有个服务出现504错误码，这个服务出现了什么问题&lt;/h2>
&lt;p>504是网关超时错误，通过nginx将请求代理到后端应用，后端程序没有在规定时间内返回数据，需要开发检查接口超时问题，比如是否出现死循环、sql慢查询等&lt;/p>
&lt;h2 id="重定向是哪一类状态码临时重定向和永久重定向有什么区别">重定向是哪一类状态码？临时重定向和永久重定向有什么区别？&lt;/h2>
&lt;p>重定向是300类状态码，301表示永久重定向，302表示临时重定向
永久重定向，客户端会记忆重定向后的url，下次访问的时候不需要访问旧url，直接跳转新url访问
临时重定向，客户端会收到302状态码，不会记忆重定向后的url，下次访问依旧访问旧url，再跳转到新的url&lt;/p>
&lt;h2 id="http11和20的区别">HTTP1.1和2.0的区别&lt;/h2>
&lt;p>2.0引入stream概念，可以在同一个tcp连接中，实现并发传输，而1.1不能并发传输，必须在一个请求结束之后才能进行下一个请求应答，浏览器是通过建立多个tcp连接，实现http1.1的并发，比较消耗内存&lt;/p>
&lt;p>报文改进，1.1发生的是文本数据，2.0发生二进制数据，通过HPACK算法压缩HTTP头部，提高了传输效率&lt;/p>
&lt;p>http2.0支持服务器主动推送数据&lt;/p>
&lt;h2 id="http20和http30的区别">HTTP2.0和HTTP3.0的区别？&lt;/h2>
&lt;p>HTTP2.0和HTTP3.0的最大区别是传输层使用的协议不同了，HTTP2.0使用的是TCP协议连接，HTTP3.0使用UDP协议；&lt;/p>
&lt;p>HTTP2.0会出现TCP队头阻塞问题，（http2.0的tcp阻塞问题，是因为http2.0的并发传输是在一条TCP连接上实现的，在传输过程中，如果某个stream发生了丢包，服务端不仅不能处理这个stream，也不会处理其他的stream，必须等丢失的包重传，才能继续处理其他stream，这个就发生了tcp队头阻塞），但是HTTP3.0通过一个在UDP协议上实现了一个可靠的QUIC协议，当stream发生丢包时，只会阻塞这个stream，其他stream不会受影响&lt;/p>
&lt;p>http3.0建立连接比http2.0高效，http3.0：3次握手就能建立连接+TLS握手成功；http2.0需要3次TCP握手+TLS四次握手&lt;/p>
&lt;p>http3.0在网络切换的环境下无需重新建立连接，通过在应用层的唯一id来确定连接&lt;/p>
&lt;h2 id="简述jwt的原理和校验机制">简述JWT的原理和校验机制&lt;/h2>
&lt;p>jwt的数据个数是header.payload.signature，头部、负载、签名三部分组成，&lt;/p>
&lt;p>header包含：令牌的类型以及令牌签名的算法&lt;/p>
&lt;p>payload：向服务器传递的数据，比如包含认证信息&lt;/p>
&lt;p>签名：对前面两部分的签名，防止数据篡改（使用在Header中公开的特点签名算法，通过特定的密钥（由服务器进行保密），对前面两部分进行加密计算&lt;/p>
&lt;p>验证JWT令牌的流程：&lt;/p>
&lt;ul>
&lt;li>服务端接收到客户端发来的JWT，取出header+payload，然后服务端根据自己的加密密钥进行加密计算&lt;/li>
&lt;li>把加密的结果和客户端发来JWT的signature进行对比，如果完全相同，则表示前面两部分没有动，如果不相同表示被篡改了&lt;/li>
&lt;li>当令牌没有被篡改后，服务端可以进行其它验证：令牌过期，用户是否有权限访问等&lt;/li>
&lt;/ul>
&lt;p>jwt令牌是由3个部分组成，分别是头部、负载、签名，头部包括类型和签名算法，负载包含了用户信息等数据，签名是对头部和负载两部分的签名，使用头部的签名算法，通过服务器的密钥对前面两部分内容进行加密计算&lt;/p>
&lt;p>校验jwt的过程是服务端接收到客户端发过来的jwt令牌后，服务端会取出头部和负载数据，然后用自己的密钥对头部和负载进行加密计算，将得到的加密结果和客户端发送过来的jwt的签名机械能对比，如果相同，表示前面两部分没有内中间人篡改，这个时候服务器可以进行其他检查，比如检查jwt是否过期，如果没有问题，正常执行业务逻辑&lt;/p>
&lt;h2 id="什么是跨域什么情况下会发生跨域">什么是跨域？什么情况下会发生跨域？&lt;/h2>
&lt;p>当网页尝试访问不同源的资源的使用，就会发生跨域，只要域名、协议、端口这三个信息任意一个不同，都认为是不同源的URL
可以用跨域资源共享技术，在服务器需要的响应头上添加Access-Control-Allow-Origin的字段，&lt;/p>
&lt;h2 id="什么是restfulrestful请求的url有什么特点">什么是Restful？RestFul请求的url有什么特点？&lt;/h2>
&lt;p>restful是一种api接口设计规范，用url定位资源，用http方法表示接口的动作，用http状态码表示接口处理的情况&lt;/p>
&lt;h2 id="http和https有什么区别">HTTP和HTTPS有什么区别？&lt;/h2>
&lt;p>安全性：HTTP使用明文传输，HTTPS通过SSL/TLS协议对数据进行加密处理，提供更高的安全性和数据保护&lt;/p>
&lt;p>建立连接：HTTP建立只需要TCP三次握手；HTTPS在TCP三次握手后还需要进行SSL/TLS的握手过程&lt;/p>
&lt;p>端口：HTTP的端口是80；HTTPS的端口是443&lt;/p>
&lt;p>证书：HTTPS需要使用数字证书来验证服务器的身份，并确保数据传输的安全性。证书由第三方机构颁发，用于证明服务器的身份和所有权。而HTTP没有使用证书进行身份验证和加密。&lt;/p></description></item><item><title/><link>https://chhz0.github.io/interviews/network/tcp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://chhz0.github.io/interviews/network/tcp/</guid><description>&lt;h2 id="tcp三次握手">TCP三次握手&lt;/h2>
&lt;h3 id="tcp头部有哪些字段">TCP头部有哪些字段？&lt;/h3>
&lt;p>tcp报文段 ： tcp头部+tcp数据部分&lt;/p>
&lt;ul>
&lt;li>
&lt;p>tcp头部：&lt;/p>
&lt;ul>
&lt;li>源端口：16位&lt;/li>
&lt;li>目的端口：16位&lt;/li>
&lt;li>序号：32位&lt;/li>
&lt;li>确认号：32位&lt;/li>
&lt;li>数据偏移：4位&lt;/li>
&lt;li>保留：6位&lt;/li>
&lt;li>窗口：16位&lt;/li>
&lt;li>校验和：16位&lt;/li>
&lt;li>紧急指针：16位&lt;/li>
&lt;li>选项和填充：最多为40字节&lt;/li>
&lt;li>控制位：
&lt;ul>
&lt;li>URG：紧急指针标志，为1时标识紧急指针有效，该报文应该优先传送，为0则忽略紧急指针&lt;/li>
&lt;li>ACK：确认序号标志，为1时表示确认号有效。携带ACK标识的TCP报文段被称为确认报文段&lt;/li>
&lt;li>RST：重置连接&lt;/li>
&lt;li>SYN：表示请求建立一个连接&lt;/li>
&lt;li>FIN：用于释放连接&lt;/li>
&lt;li>PSH：为1表示带有push标志的数据，优先将这个报文提交给应用程序，而不是缓冲区排队&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>tcp头部的最长是60字节&lt;/p>&lt;/blockquote>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>数据部分：。。。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>回答：tcp头部主要是源端口、目的端口、序列号、确认号、标记位：SYN、RST、ACK、FIN、头部长度、窗口大小，可扩展的选项等&lt;/p>
&lt;p>其中序列号和确认号的大小为32位，序列号保证数据的有序性，接收方按照发送方顺序发来的数据来组装有序的数据；确认号保证数据的可靠性，当发送方已发送的数据，超过一段时间没收到确认报文，就会重传报文。&lt;/p>
&lt;p>源端口和目的端口的大小是16位，源端口是发送方的端口号，目的端口是接收方使用的端口号，端口的作用是标识TCP连接是哪个进程&lt;/p>
&lt;p>&lt;a href="https://www.cnblogs.com/Jummyer/p/11026966.html">TCP之报文首部格式 - Jummyer - 博客园&lt;/a>&lt;/p>
&lt;h3 id="tcp三次握手连接过程">TCP三次握手连接过程&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>客户端和服务端一开始都处于close状态，服务端会监听一个端口，处于listen状态&lt;/p>
&lt;/li>
&lt;li>
&lt;p>第一次握手：客户端产生随机初始化序号，放到tcp报文头部的序号字段，同时把SYN标志设置位1，标识SYN报文。接着把SYN报文发送给服务端，之后客户端处于SYN_SEND状态&lt;/p>
&lt;/li>
&lt;li>
&lt;p>服务端收到SYN报文后，服务端也生成随机初始化序号，放到TCP报文头部的序号字段中，对客户端的初始化序号+1作为确认号，放到TCP报文头部的确认应答字段中，并将SYN和ACK标志设置为1，表示SYN-ACK报文，把报文发送给客户端，之后服务端处于SYN_RECD状态&lt;/p>
&lt;/li>
&lt;li>
&lt;p>客户端收到服务端SYN-ACK报文后，客户端发送一个ACK确认报文，该报文的确认号为服务端的初始化序号+1，并将ACK标志设置为1。客户端处于ESTABLISHED状态&lt;/p>
&lt;/li>
&lt;li>
&lt;p>服务端收到ACK确认报文，服务端也处于ESTABLISHED状态&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>以上就是TCP三次握手的过程&lt;/p>
&lt;p>&lt;a href="https://xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-%E5%A4%B4%E6%A0%BC%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B">4.1 TCP 三次握手与四次挥手面试题&lt;/a>&lt;/p>
&lt;h3 id="为什么需要三次握手两次握手不行吗">为什么需要三次握手？两次握手不行吗？&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>避免历史连接的建立，避免资源浪费&lt;/p>
&lt;/li>
&lt;li>
&lt;p>三次握手可以确认客户端和服务端是否同时具备发送和接收的能力&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="如果第二次握手丢包会发送什么">如果第二次握手丢包，会发送什么？&lt;/h3>
&lt;p>超时重传机制，第二次SYN-ACK报文中有&lt;/p>
&lt;p>第二次报文中的ACK，是第一次握手的确认报文，那么当第二次报文丢包时，会导致客户端一直没有接收到ACK而触发超时重传机制，重传SYN包，即第一次握手&lt;/p>
&lt;p>第二次报文中的SYN，是服务端建立TCP连接的报文，当第二次报文丢失后，客户端没有发送ACK报文，服务端没有收到第三次握手，于是服务端会触发超时重传机制，重传SYN-ACK报文&lt;/p>
&lt;h3 id="如果第三次握手丢包会发生什么">如果第三次握手丢包，会发生什么？&lt;/h3>
&lt;p>我的理解是第三次握手如果发生丢包，服务端会迟迟接收不到第三次握手的ACK包，触发超时重传机制，服务端会重新发生第二次握手的SYN-ACK包，直到最大重传次数的限制，或者收到第三次握手&lt;/p>
&lt;h3 id="tcp的半连接队列和全连接队列">TCP的半连接队列和全连接队列？&lt;/h3>
&lt;p>在tcp三次握手的时候，linux内核会维护两个队列，分别是：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>syn队列：半连接队列&lt;/p>
&lt;/li>
&lt;li>
&lt;p>accept队列：全连接队列&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>服务端收到客户端发起的SYN请求后，内核会将为握手完成的连接存储到半连接队列，等待完成三次握手后转移到全连接队列&lt;/p>
&lt;p>全连接队列：服务端收到客户端的第三次握手，内核会将连接从半连接队列移除，然后创建新的完全连接，并将其添加到全连接队列，等待进程调用accept函数将连接取出&lt;/p>
&lt;p>&lt;a href="https://xiaolincoding.com/network/3_tcp/tcp_queue.html">4.4 TCP 半连接队列和全连接队列&lt;/a>&lt;/p>
&lt;h2 id="tcp四次挥手">TCP四次挥手&lt;/h2>
&lt;h3 id="tcp四次挥手的过程">TCP四次挥手的过程&lt;/h3>
&lt;p>tcp的四次挥手（断开连接）是可以客户端或者服务端断开&lt;/p>
&lt;p>客户端关闭连接，此时会发生一个fin报文，之后客户端进入fin_wait_1状态，&lt;/p>
&lt;p>服务端收到fin报文后，将向客户端发送ack报文，接着服务端进入close_wait状态&lt;/p>
&lt;p>客户端接收到ack应答报文后，之后进入fin_wait_2状态&lt;/p>
&lt;p>等待服务端处理完数据后，向客户端发送fin报文，服务端进入last_ack状态&lt;/p>
&lt;p>客户端收到服务端的fin报文后，回一个ack应答报文，客户端进入time_wait状态&lt;/p></description></item><item><title/><link>https://chhz0.github.io/interviews/network/%E7%BD%91%E7%BB%9C%E5%B1%82/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://chhz0.github.io/interviews/network/%E7%BD%91%E7%BB%9C%E5%B1%82/</guid><description>&lt;h2 id="ping的原理简述">ping的原理简述：&lt;/h2>
&lt;p>ping命令是用来探测目标ip地址是否可以访问
Ping是通过ICMP协议实现的，ping的时候，会向接收方发送回送请求的ICMP报文，对方接收到后，会回复类型为回送应答的ICMP报文&lt;/p>
&lt;h2 id="交换机和路由器有什么区别">交换机和路由器有什么区别？&lt;/h2>
&lt;ul>
&lt;li>交换机工作在MAC层，称为二层网络设备，主要负责数据帧的转发和交换，交换机会根据MAC地址来转发数据包，是实现局域网内设备的通信&lt;/li>
&lt;li>路由器工作在IP层，称为三层网络设备，主要负责IP数据包的转发和路由选择，路由器会根据IP地址来转发数据包，实现不同网络间的通信&lt;/li>
&lt;/ul>
&lt;h2 id="ip地址和mac地址有什么区别">IP地址和MAC地址有什么区别？&lt;/h2>
&lt;ul>
&lt;li>IP地址用于网络中唯一标识和定位设备，它是网络层使用的地址，用于实现不同网络之间的通信&lt;/li>
&lt;li>MAC地址用于局域网中唯一标识和定位设备，它在数据链路层使用的地址，实现局域网内设备之间的通信&lt;/li>
&lt;/ul>
&lt;h2 id="nat协议">NAT协议&lt;/h2>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/26992935">网络地址转换协议NAT功能详解及NAT基础知识介绍&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://xiaolincoding.com/network/4_ip/ip_base.html">5.1 IP 基础知识全家桶&lt;/a>&lt;/p>
&lt;h2 id="192168110024中斜杠代表什么意思">192.168.1.100/24中斜杠代表什么意思？&lt;/h2>
&lt;p>斜杠（/）后面的数字表示子网掩码的位数&lt;/p>
&lt;p>比如，192.168.1.100/24中的斜杠后面数字表示子网掩码的位数，子网掩码用于划分IP地址中的网络部分和主机部分。将子网掩码和IP地址进行与运算，就可以得到网络号&lt;/p>
&lt;p>具体来说：192.168.1.100/24表示前24位是网络部分，后8位是主机部分&lt;/p></description></item><item><title/><link>https://chhz0.github.io/interviews/network/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://chhz0.github.io/interviews/network/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</guid><description>&lt;h2 id="osi的7层网络模型各层的协议有什么">OSI的7层网络模型？各层的协议有什么？&lt;/h2>
&lt;ul>
&lt;li>应用层：确定进程间通信的性质以及满足用户需要以及提高网络和用户应用&lt;/li>
&lt;li>表示层：主要解决用户信息的语法表达&lt;/li>
&lt;li>会话层：复制建立、管理和终止表示层实体之间的通信会话&lt;/li>
&lt;li>传输层：实现网络不同主机上的用户进程间的数据通信，可靠和不可靠的传输&lt;/li>
&lt;li>网络层：本层通过IP寻址来建立两个节点之间的连接&lt;/li>
&lt;li>数据链路层：将上层数据封装成帧，用MAC地址访问媒介&lt;/li>
&lt;li>物理层：设备之间比特流的传输，物理接口&lt;/li>
&lt;/ul>
&lt;p>回答：
OSI参考模型有7层，应用层、表示层、会话层、传输层、网络层、数据链路层、物理层
应用层有HTTP、HTTPS，传输层有TCP和UDP协议，网络层有IP、ICMP、ARP协议&lt;/p>
&lt;blockquote>
&lt;p>网络分层的好处：对各层之间进行解耦，层与层之间不产生关联，比如应用层HTTP协议从HTTP1.1升级到HTTP2.0的时候，不会对传输层和网络层有影响，或者网络层的IPv4协议升级到IPv6协议的时候，不会影响到应用，传输层&lt;/p>&lt;/blockquote>
&lt;blockquote>
&lt;p>TCP/IP协议是将OSI模型的应用层、表示层、会话层统一为应用层，数据链路层和物理层统一为网络接口层&lt;/p>&lt;/blockquote>
&lt;h2 id="tcpip的四层网络模型">TCP/IP的四层网络模型？&lt;/h2>
&lt;ul>
&lt;li>应用层&lt;/li>
&lt;li>传输层&lt;/li>
&lt;li>网络层&lt;/li>
&lt;li>数据链路层（网络接口层）&lt;/li>
&lt;/ul>
&lt;h2 id="五层因特网协议栈">五层因特网协议栈？&lt;/h2>
&lt;p>应用层、运输层、网络层、链路层、物理层&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>OSI七层网络协议&lt;/th>
 &lt;th>TCP/IP四层概念模型&lt;/th>
 &lt;th>对于网络协议&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>应用层&lt;br>&amp;mdash;&lt;br>表示层&lt;br>&amp;mdash;&lt;br>会话层&lt;/td>
 &lt;td>应用层（4）&lt;/td>
 &lt;td>HTTP、TFTP、FTP、NFS、WAIS、SMTP&lt;br>&amp;ndash;&lt;br>Telnet、Rlogin、SNMP、Gopher&lt;br>&amp;ndash;&lt;br>SMTP、DNS&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;h2 id="键入网址场景问题">键入网址场景问题&lt;/h2>
&lt;h3 id="键入网址后期间发送了什么">键入网址后，期间发送了什么？&lt;/h3>
&lt;blockquote>
&lt;p>http/https -&amp;gt; dns -&amp;gt; tcp -&amp;gt; ip -&amp;gt; arp&lt;/p>&lt;/blockquote>
&lt;ol>
&lt;li>浏览器会解析网址，解析出域名，资源路径，端口等信息，构造HTTP请求报文&lt;/li>
&lt;li>将域名解析为IP地址，先查看系统缓存是否有域名信息，有的话返回IP地址；没有就查看本地host文件没有域名信息，有就返回IP地址；如果再没有就查看本地DNS服务器，如果本地DNS服务器中有域名信息，就返回IP地址，否则本地DNS服务器分别去根域名服务器-&amp;gt;顶级域名服务器-&amp;gt;权威域名服务器询问，最后拿到IP地址&lt;/li>
&lt;li>HTTP协议是基于TCP协议传输的，所以要先进行TCP三次握手，&lt;/li>
&lt;li>然后到网络层，加上IP头，同时填上目标IP地址和源IP地址&lt;/li>
&lt;li>然后到数据链路层，通过ARP协议，获取路由器的MAC地址，然后加上MAC头，填上目标MAC地址和源MAC地址&lt;/li>
&lt;li>然后到物理层，直接把数据包转发给路由器，路由器再通过下一跳，找到最终的目的服务器&lt;/li>
&lt;li>当双方完成三次握手后，如果是HTTP协议，客户端就会把HTTP请求发送给目标服务器；如果是HTTPS协议，还需要进行TLS四次握手，客户端才会把HTTP报文发送给目标服务器&lt;/li>
&lt;li>目标服务器收到HTTP报文后，返回HTTP响应消息，浏览器对响应消息进行解析渲染，呈现给用户&lt;/li>
&lt;/ol>
&lt;h3 id="dns是如何解析的属于哪一层的协议">DNS是如何解析的？属于哪一层的协议？&lt;/h3>
&lt;p>DNS属于应用层的协议，客户端在进行DNS解析时，首先会查看浏览器和操作系统是否缓存域名对应的IP地址，如果没有就向本地DNS服务器发出查询请求，接着本地DNS向根DNS发送查询请求，根DNS服务器返回顶级域名服务器地址，本地DNS服务器向顶级域名服务器发送查询请求，顶级域名服务器返回权威域名服务器的IP地址，本地DNS服务器再向权威域名服务器发出查询请求，权威域名服务器收到请求后，就返回域名对应的IP地址了，本地DNS服务器返回查询结果给客户端，然后将本次查询得到的结果保存到缓存里，以备下次使用&lt;/p>
&lt;h3 id="dns域名解析使用的是什么协议">DNS域名解析使用的是什么协议？&lt;/h3>
&lt;p>DNS中，域名的解析是通过UDP协议进行的&lt;/p>
&lt;p>UPD是一种无连接的传输层协议，提供了一种简单的传输机制，适用于实时性比较高的应用场景。DNS使用UDP协议进行域名解析是因为域名解析是短小且频繁的请求，UDP的无连接特性可以减少建立连接和断开连接的开销，提高传输效率&lt;/p>
&lt;p>UPD协议对于TCP协议的缺点是没办法保证数据传输的可靠性，针对这个缺点可以在应用层实现超时重传机制，如果域名解决请求在一定的时间内没有收到响应，那么就重发域名解析&lt;/p>
&lt;h3 id="输入域名怎么找到端口号">输入域名怎么找到端口号？&lt;/h3>
&lt;p>http的默认端口是80；https的默认端口号是443；
如果用户指定了端口，可以在url中获取，比如域名:8080，这时候使用的端口是8080&lt;/p>
&lt;h2 id="网络传输场景">网络传输场景&lt;/h2>
&lt;h3 id="tcp连接一个不存在的ip地址会发生什么">tcp连接一个不存在的IP地址会发生什么？&lt;/h3>
&lt;ul>
&lt;li>如果IP地址是局域网内，客户端的内核在发生arp请求的时候，广播这个目标IP是谁的，但是由于网络中不存在这个IP地址，所以没有设备应答，会卡在arp协议，客户端的SYN报文无法发送出去&lt;/li>
&lt;li>如果这个IP地址不是局域网的，客户端会将SYN报文交给路由器，由路由器继续转发，由于目标IP地址是不存在的，该SYN报文会在网络中消亡；客户端由于一直接收不到SYN报文的确认报文，会触发超时重传机制，直到最大的重试次数，客户端的连接会被释放&lt;/li>
&lt;/ul>
&lt;h3 id="tcp连接一个ip地址存在但是端口不存在的服务端会发生什么">tcp连接一个IP地址存在但是端口不存在的服务端会发生什么？&lt;/h3>
&lt;p>端口不存在的话，代表服务端没有监听这个端口，服务端在接收到客户端的SYN包后，返回RST报文，客户端接收到RST报文后，会断开连接&lt;/p>
&lt;h3 id="udp发送一个ip地址存在但是端口不存在报文会发生什么">UDP发送一个IP地址存在但是端口不存在报文会发生什么？&lt;/h3>
&lt;p>服务端会回ICMP报文，报告端口不可用&lt;/p></description></item><item><title/><link>https://chhz0.github.io/notes/cs/net/tcpip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://chhz0.github.io/notes/cs/net/tcpip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</guid><description>&lt;h2 id="21-tcpip网络模型">2.1 TCP/IP网络模型&lt;/h2>
&lt;blockquote>
&lt;p>&lt;a href="https://xiaolincoding.com/network/1_base/tcp_ip_model.html">2.1 TCP/IP 网络模型有哪几层？&lt;/a>&lt;/p>&lt;/blockquote>
&lt;p>前言：为什么要有TCP/IP网络模型？&lt;/p>
&lt;blockquote>
&lt;p>答：为了提供一套 &lt;strong>通用的&lt;/strong> 网络协议&lt;/p>&lt;/blockquote>
&lt;p>因为在一台设备上的进程间通信有很多方式，比如管道、消息队列、共享内存、信号等方式，而对于不同的设备上的进程间通信，就需要网络通信，而设备是多样性的，需要兼容多种多样的设备，就需要一套 &lt;code>通用的网络协议&lt;/code>&lt;/p>
&lt;p>这个网络协议是分层的，每一层都有各自的作用和责任&lt;/p>
&lt;p>TCP/IP网络模型分为4层：应用层&amp;ndash;&amp;gt;传输层&amp;ndash;&amp;gt;网络层&amp;ndash;&amp;gt;网络接口层(由上到下)&lt;/p>
&lt;p>接下来根据 [TCP/IP 网络模型 ]分别对每一层进行介绍：&lt;/p>
&lt;h3 id="应用层最上层">&lt;strong>应用层（最上层）&lt;/strong>&lt;/h3>
&lt;p>最上层的，也是我们能直接接触到的就是&lt;strong>应用层&lt;/strong>(Application Layer)，我们使用的应用软件都是在应用层实现的，当两台不同的设备的应用需要通信的时候，应用就把应用数据传给下一层，也就是&lt;strong>传输层&lt;/strong>。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>应用层&lt;/strong>接收数据后把数据传入&lt;strong>传输层&lt;/strong>&lt;/p>&lt;/blockquote>
&lt;p>所以，&lt;strong>应用层&lt;/strong>只需要专注于为用户提供应用功能，比如HTTP、FTP、Telnet、DNS、SMTP等&lt;/p>
&lt;p>应用层不用关心数据是如何传输&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>应用层&lt;/strong>是工作在操作系统的用户态，&lt;strong>传输层****及其一下&lt;/strong>则工作在内核态&lt;/p>&lt;/blockquote>
&lt;h3 id="传输层">&lt;strong>传输层&lt;/strong>&lt;/h3>
&lt;p>&lt;strong>应用层&lt;/strong>的数据包会传输到传输层，&lt;strong>传输层&lt;/strong>(Transport Layer) 是为应用层提供网络支持&lt;/p>
&lt;p>&lt;img src="https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=OTM5NGVmNjMyYmZhOTE2Y2JiZTlhZjRkMzJhMGU4NTVfM3F5dVFqUnppQzA2cXFoQ2F6c1RwdVlpa3QzR0U2N3lfVG9rZW46RTgwT2JPenk5b1VQaW14Y1pFY2NkYTBmbmtoXzE3MjE4Mzk4OTE6MTcyMTg0MzQ5MV9WNA" alt="">&lt;/p>
&lt;p>在&lt;strong>传输层&lt;/strong>会有两个传输协议，分别为&lt;code>TCP&lt;/code>和&lt;code>UDP&lt;/code>&lt;/p>
&lt;p>&lt;strong>TCP&lt;/strong>的全称是“传输控制协议”(Transmission Control Protocol)，大部分应用使用的正是TCP传输层协议，比如HTTP应用层协议。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>TCP&lt;/strong>有很多特征：流量控制、超时重传、拥塞控制等，这些保证了数据包能可靠地传输给对方&lt;/p>&lt;/blockquote>
&lt;p>&lt;strong>UDP&lt;/strong>相对来说比较协议，简单到&lt;strong>只负责发送数据包&lt;/strong>，不保证数据包是否能抵达对方，但是实时性相对更好，传输效率也高。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>UDP&lt;/strong>也可以实现可靠传输，把&lt;strong>TCP&lt;/strong>的特性在应用层上实现就行，（不过要实现一个商用的可靠UDP传输协议也不简单）&lt;/p>&lt;/blockquote>
&lt;p>应用需要传输的数据可能会非常大，如果直接传输就不好控制，因此当传输层的数据包大小超过&lt;strong>MSS&lt;/strong>（TCP最大报文段长度），就要将数据包分块，这样即使在传输过程中一个分块缺失或者损坏了，只需要重新发送这一分开，而不用重新发送整个数据包。&lt;/p>
&lt;p>在TCP协议中，每一个分块称为一个&lt;strong>TCP段&lt;/strong>(TCP Segment)&lt;/p>
&lt;p>&lt;img src="https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=OTE4YjBkOWU1ZTVlYmViZDkxNDQ1NTFmYWZkMTQzMTFfNllQajladEFQVERJUDFNWUZHNWxZRGVaWFZoanVZeE9fVG9rZW46VG5ZM2JrUzVGb1ZrN1N4UkF5b2NMdW5KbmZrXzE3MjE4Mzk4OTE6MTcyMTg0MzQ5MV9WNA" alt="">&lt;/p>
&lt;p>当设备作为接收方时，传输层则要负责把数据包传给应用层，但是一台设备上可能会有很多应用在接收或者传输数据，因此需要一个编号将应用区分开来，这个编号就是&lt;strong>端口&lt;/strong>&lt;/p>
&lt;p>比如 80 端口通常是 Web 服务器用的，22 端口通常是远程登录服务器用的。而对于浏览器（客户端）中的每个标签栏都是一个独立的进程，操作系统会为这些进程分配临时的端口号。&lt;/p>
&lt;p>由于传输层的报文中会携带端口号，因此接收方可以识别出该报文是发送给哪个应用。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>传输层&lt;/strong>并不负责将数据从一个设备传输到另一个设备&lt;/p>&lt;/blockquote>
&lt;h3 id="网络层">&lt;strong>网络层&lt;/strong>&lt;/h3>
&lt;p>在实际场景中，一个设备的数据要传输给另一个设备，就需要在各种各样的路径和节点进行选择，其中的网络环节是错综复杂的。而&lt;strong>传输层&lt;/strong>的设计理念是简单、高效、专注，如果传输层还负责这一块功能就有点违背设计原则&lt;/p>
&lt;p>我们不希望传输层协议处理太多的事情，只需要服务好应用即可，让其作为应用间数据传输的媒介，帮助实现应用到应用的通信，而实际的传输功能就交给下一层，也就是&lt;strong>网络层&lt;/strong>(Internet Layer)&lt;/p>
&lt;p>&lt;img src="https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=NDBiZTU5ZmFlMmQyNGNiYzdkMTA1M2YxNmZmNmMwYjhfeUhWM2IyVzAxbWdwdHZud0N3eWtsbVdDbHZoMGNiR1RfVG9rZW46RmIxTWJ2TEF6b1RaZU94S29SRmNIazNRbnJFXzE3MjE4Mzk4OTE6MTcyMTg0MzQ5MV9WNA" alt="">&lt;/p>
&lt;blockquote>
&lt;p>个人理解：应用层把大量的数据发送给传输层，传输层将这些大量的数据进行打包，分段，确定好目的应用，然后由网络层进行传输。&lt;/p>&lt;/blockquote>
&lt;p>&lt;strong>网络层&lt;/strong>最常用的是&lt;strong>IP协议&lt;/strong>(Internet Protocol)，IP协议会将传输层的报文作为数据部分，再加上IP包头组装成&lt;strong>IP报文&lt;/strong>，如果IP报文大小超过了&lt;strong>MTU&lt;/strong>(以太网中一般为1500字节)就会&lt;strong>再次进行分片&lt;/strong>，得到一个继续发送网络的IP报文&lt;/p>
&lt;p>&lt;img src="https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=YjBhODFlM2VmZWRiYWI5MTYyOTdjY2Q3NTlmNGQ4OTNfMWhGUGlQbmszY2FmYnhmYlhUU1dHTGw3VmxEU0JXV3pfVG9rZW46WnFoWmJwM09Ub2F6VDV4ek5FMGN6dnY3bmpmXzE3MjE4Mzk4OTE6MTcyMTg0MzQ5MV9WNA" alt="">&lt;/p>
&lt;p>&lt;strong>网络层&lt;/strong>负责将数据从一个设备传输到另一个设备，但是世界上那么多设备，如何找到对方呢，因此，网络层需要有区分设备的编号&lt;/p>
&lt;p>一般用&lt;strong>IP地址&lt;/strong>给设备进行编号，对于IPv4协议，IP地址共32位，分成了四段（比如127.0.0.1，分成四段，每段8位）。但是寻址起来特别麻烦，不能一个一个去匹配。&lt;/p>
&lt;p>因此，需要将IP地址分成两种意义：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>一个是&lt;strong>网络号&lt;/strong>，负责标识该IP地址是属于那个[ 子网 ]的&lt;/p></description></item><item><title>Search</title><link>https://chhz0.github.io/search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://chhz0.github.io/search/</guid><description>&lt;h1 id="search">Search&lt;/h1>
&lt;p>Here you can search for indexable pages, like posts and alike. There&amp;rsquo;s also support for URL param &amp;ldquo;q&amp;rdquo; which then auto searches upon page load event.&lt;/p>
&lt;blockquote>
&lt;p>你可以在此处搜索可索引的页面，例如帖子等内容。该功能还支持 URL 参数 &amp;ldquo;q&amp;rdquo;，在页面加载时会自动根据该参数进行搜索。&lt;/p>&lt;/blockquote>
&lt;p class="hidden">&lt;/p>
&lt;p class="search-loading hidden">加载中...&lt;/p>

&lt;form id="search-form" class="search-form" action="#" method="post" accept-charset="UTF-8" role="search">
 &lt;div class="search-bar">
 &lt;label for="query" class="hidden">搜索...&lt;/label>
 &lt;input id="query" class="search-text" type="text" placeholder="搜索. . ."/>
 &lt;/div>
&lt;/form>

&lt;div class="search-results">&lt;/div>

&lt;template>
 &lt;article class="search-result list-view">
 &lt;header>
 &lt;h2 class="title">&lt;a href="#">&lt;/a>&lt;/h2>
 &lt;div class="submitted">
 &lt;time class="created-date">&lt;/time>
 &lt;/div>
 &lt;/header>
 &lt;p class="content">&lt;/p>
 &lt;/article>
&lt;/template></description></item></channel></rss>